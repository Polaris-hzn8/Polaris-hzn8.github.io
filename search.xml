<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第五章：IO管理</title>
      <link href="/2023/03/01/operatingSystem/5.%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9AIO%E7%AE%A1%E7%90%86/"/>
      <url>/2023/03/01/operatingSystem/5.%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9AIO%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章：IO管理"><a href="#第五章：IO管理" class="headerlink" title="第五章：IO管理"></a>第五章：IO管理</h1><hr><h3 id="一、IO管理概述"><a href="#一、IO管理概述" class="headerlink" title="一、IO管理概述"></a>一、IO管理概述</h3><h4 id="1-IO设备"><a href="#1-IO设备" class="headerlink" title="1.IO设备"></a>1.IO设备</h4><p>IO设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。</p><table><thead><tr><th>按特性分类</th><th>特点</th></tr></thead><tbody><tr><td>人机交互类外部设备</td><td>数据传输速度较慢，如鼠标、键盘、打印机等</td></tr><tr><td>数据存储设备</td><td>数据传输速度较快，如移动硬盘、光盘等</td></tr><tr><td>网络通信设备</td><td>数据传输速度一般，如调制解调器等网络通信</td></tr></tbody></table><table><thead><tr><th>按信息交换单位分类</th><th>特点</th></tr></thead><tbody><tr><td>块设备</td><td>传输速率较高、可寻址（随机读写某个块），如磁盘等数据传输基本单位为块</td></tr><tr><td>字符设备</td><td>传输速率较慢、不可寻址（在IO时常采用<font color='#BAOC2F'>中断驱动的方式</font>），如鼠标、键盘等数据传输基本单位为字符</td></tr></tbody></table><h4 id="2-IO控制器"><a href="#2-IO控制器" class="headerlink" title="2.IO控制器"></a>2.IO控制器</h4><h5 id="（1）IO控制器功能："><a href="#（1）IO控制器功能：" class="headerlink" title="（1）IO控制器功能："></a>（1）IO控制器功能：</h5><ul><li>IO设备的机械部件主要用来执行具体的IO操作，如鼠标、键盘的按钮、显示器的LED屏、移动硬盘的磁臂、</li><li>IO设备的电子部件通常是一块<font color='#BAOC2F'>插入主板扩充槽的印刷电路板</font>。</li></ul><p>CPU无法直接控制IO设备的机械部件，因此需要<font color='#BAOC2F'>电子部件</font>作为CPU和机械部分之间的中介，实现CPU对设备的控制。</p><p>该电子部件就是IO控制器（设备控制器），CPU可<font color='#BAOC2F'>控制IO控制器</font>从而实现对IO设备机械部件的控制。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006103218184.png" alt="image-20221006103218184"></p><h5 id="（2）IO控制器组成："><a href="#（2）IO控制器组成：" class="headerlink" title="（2）IO控制器组成："></a>（2）IO控制器组成：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006103717236.png" alt="image-20221006103717236"></p><ol><li>1个IO控制器可能会对应多个设备。</li><li>数据寄存器、控制寄存器、状态寄存器可能会有多个，其这些寄存器都要<font color='#BAOC2F'>有相应的地址</font>才能方便CPU操作。</li><li>寄存器占用内存地址的一部分，则称为<font color='#BAOC2F'>内存映像IO</font>；寄存器占用IO专用地址，则称为<font color='#BAOC2F'>寄存器独立编址</font>。</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006104555089.png" alt="image-20221006104555089"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006104726001.png" alt="image-20221006104726001"></p><h4 id="3-IO控制方式"><a href="#3-IO控制方式" class="headerlink" title="3.IO控制方式"></a>3.IO控制方式</h4><h5 id="（1）程序直接控制："><a href="#（1）程序直接控制：" class="headerlink" title="（1）程序直接控制："></a>（1）程序直接控制：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006110601888.png" alt="image-20221006110601888"></p><ol><li>CPU干预的频率：非常频繁，IO操作开始前后都需要CPU介入，并且在等待IO完成的过程中CPU需要不断地轮询检查。</li><li>数据传送单位：每次读写一个字</li><li>数据的流向：内存、CPU寄存器、IO设备</li><li>优点：实现简单，在读写指令之后加上<font color='#BAOC2F'>实现循环检查</font>的一系列指令即可（程序直接控制）。</li><li>缺点：CPU和IO设备只能串行工作，CPU需要一直轮询检查导致<font color='#BAOC2F'>长期处于忙等状态</font>，CPU利用率较低。</li></ol><h5 id="（2）中断驱动控制："><a href="#（2）中断驱动控制：" class="headerlink" title="（2）中断驱动控制："></a>（2）中断驱动控制：</h5><p>在程序直接控制的基础上引入中断机制，由于IO设备速度很慢，可将等待IO的进程阻塞先切换到别的进程执行。</p><p>当IO完成后控制器会向CPU发出一个中断信号，CPU检测到中断信号后会保存当前进程的运行环境信息，转向执行中断处理程序。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006112331033.png" alt="image-20221006112331033"></p><ol><li>CPU干预的频率：干预频率降低，IO操作开始前后都需要CPU介入，并且在等待IO完成的过程中CPU可以切换到其他进程。</li><li>数据传送单位：每次读写一个字</li><li>数据的流向：内存、CPU寄存器、IO设备</li><li>优点：在中断驱动方式中，IO控制器会通过中断信号主动报告IO已完成，CPU不再需要不停的轮询，CPU和IO设备可并行工作。</li><li>缺点：每个字在IO设备与内存之间的传输都需要经过CPU，而频繁的中断处理会消耗掉较多的CPU时间。</li></ol><h5 id="（3）DMA控制："><a href="#（3）DMA控制：" class="headerlink" title="（3）DMA控制："></a>（3）DMA控制：</h5><p>DMA直接存储器存取，Direct Memory Access<font color='#BAOC2F'>主要用于块设备</font>的IO控制，主要改进包括：</p><table><thead><tr><th align="center">主要改进</th></tr></thead><tbody><tr><td align="center">1.数据的传送单位为块，不再以字为单位传输数据。</td></tr><tr><td align="center">2.数据的流向从内存直接放入设备，不再需要CPU寄存器作为中间传输</td></tr><tr><td align="center">3.仅在传送一个&#x2F;多个数据块的开始和结束时，才需要CPU干预</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006113237280.png" alt="image-20221006113237280"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006114303547.png" alt="image-20221006114303547"></p><ol><li>CPU干预的频率：CPU介入频率进一步降低，仅在传送一个或多个数据块的开始和结束时，才需要CPU的干预。</li><li>数据传送单位：每次读写一个或多个块（每次读写只能是连续的多个块，读入内存后在内存中也必须是连续的）</li><li>数据的流向：内存、IO设备</li><li>优点：数据传输以块为单位，数据传输不需要经过CPU可直接写入内存，数据传输效率进一步提升。</li><li>缺点：CPU每发出一条IO指令，只能读写一个或多个连续的数据块（离散的数据块需要CPU发出多条指令，进行多次中断处理）。</li></ol><h5 id="（4）通道控制："><a href="#（4）通道控制：" class="headerlink" title="（4）通道控制："></a>（4）通道控制：</h5><p>通道是一种硬件设备（低配版的CPU），可以识别并执行一系列的通道指令。</p><p>与CPU相比通道可以执行的指令单一，并且通道程序存放在主机内存中（通道与CPU共享内存）。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006115345578.png" alt="image-20221006115345578"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006115020481.png" alt="image-20221006115020481"></p><ol><li>CPU干预的频率：极低，通道会根据CPU指示执行对应的通道程序，只有完成一组数据块读写后才发出中断信号，请求CPU干预</li><li>数据传送单位：每次读写一组数据块</li><li>数据的流向（在通道的控制下进行）：内存、IO设备</li><li>优点：CPU、通道、IO设备可并行工作，资源利用率特别高</li><li>缺点：实现复杂并需要专门的硬件通道的支持</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006115829294.png" alt="image-20221006115829294"></p><h4 id="4-IO软件层次"><a href="#4-IO软件层次" class="headerlink" title="4.IO软件层次"></a>4.IO软件层次</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006124234679.png" alt="image-20221006124234679"></p><p>设备独立性软件又称设备无关性软件，与设备的<font color='#BAOC2F'>硬件特性无关</font>的功能几乎都在这一层完成。</p><p>设备独立性软件功能：</p><ol><li>向上层提供统一的调用接口，如read&#x2F;write系统调用</li><li>实现设备的保护功能（原理与文件保护类似）</li><li>对设备的错误进行处理（非重点）</li><li>设备的分配与回收</li><li>数据缓冲区的管理（屏蔽设备之间数据交换单位大小和传输速度的差异）</li><li>建立<font color='#BAOC2F'>逻辑设备名</font>到<font color='#BAOC2F'>物理设备名</font>的映射关系，根据设备的类型选择调用相应的驱动程序</li></ol><h4 id="5-IO与设备驱动应用程序接口"><a href="#5-IO与设备驱动应用程序接口" class="headerlink" title="5.IO与设备驱动应用程序接口"></a>5.IO与设备驱动应用程序接口</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006214456995.png" alt="image-20221006214456995"></p><h5 id="（1）IO应用程序接口："><a href="#（1）IO应用程序接口：" class="headerlink" title="（1）IO应用程序接口："></a>（1）IO应用程序接口：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006211045868.png" alt="image-20221006211045868"></p><ul><li>阻塞IO：应用程序发出IO系统调用，<font color='#BAOC2F'>进程需要转换为阻塞态</font>进行等待，例如字符设备接口（从键盘读入一个字符get）</li><li>非阻塞IO：应用程序发出IO系统调用，系统调用可迅速返回<font color='#BAOC2F'>进程无需阻塞等待</font>，例如块设备接口（往磁盘写数据write）</li></ul><h5 id="（2）设备应用程序接口："><a href="#（2）设备应用程序接口：" class="headerlink" title="（2）设备应用程序接口："></a>（2）设备应用程序接口：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006214440272.png" alt="image-20221006214440272"></p><h3 id="二、设备独立性软件"><a href="#二、设备独立性软件" class="headerlink" title="二、设备独立性软件"></a>二、设备独立性软件</h3><p>IO核心子系统要实现的功能就是IO软件层次中间三层要实现的功能，</p><p>主要包括IO调度、设备保护、假脱机技术SPOOLing技术、设备分配与回收、缓冲区管理（缓冲与高速缓存）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006215336506.png" alt="image-20221006215336506"></p><h4 id="1-假脱机技术"><a href="#1-假脱机技术" class="headerlink" title="1.假脱机技术"></a>1.假脱机技术</h4><h5 id="（1）脱机技术原理："><a href="#（1）脱机技术原理：" class="headerlink" title="（1）脱机技术原理："></a>（1）脱机技术原理：</h5><p>脱机技术：脱离主机的控制进行的输入输出操作</p><p>脱机技术缓解了CPU与IO设备的速度矛盾，即使<font color='#BAOC2F'>CPU</font>忙碌也可<font color='#BAOC2F'>提前将数据输入磁带</font>，即使慢速<font color='#BAOC2F'>输出设备</font>忙碌也可<font color='#BAOC2F'>提前将数据输出磁带</font>。</p><p>基于脱机技术发明了SPOOLing假脱机技术，是用软件的方式模拟脱机技术，SPOOLing系统的组成如下：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006222347857.png" alt="image-20221006222347857"></p><blockquote><p>注：要实现SPOOLing技术必须要有多道程序技术的支持，系统会建立输入进程和输出进程。</p></blockquote><h5 id="（2）脱机技术案例："><a href="#（2）脱机技术案例：" class="headerlink" title="（2）脱机技术案例："></a>（2）脱机技术案例：</h5><p>SPOOLing技术可将独占式打印机改造称为共享式打印机，实现共享打印机：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221006225216679.png" alt="image-20221006225216679"></p><p>当多个用户进程提出输出打印的请求时，系统会答应它们的请求但是并不会真正把打印机分配给他们，</p><p>而是由假脱机管理进程为每个进程做两件事：</p><ol><li>在磁盘输出井中为进程申请一个空闲缓冲区（缓冲区在磁盘上非内存），并将要打印的数据输入其中</li><li>为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（用于说明用户的打印数据存放位置等信息），再将该表挂到假脱机文件队列上。</li><li>当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，根据表中的要求打印的数据从输出井传输到输出缓冲区，最后输出到打印机进行打印，用这种方式可依次处理完全部的打印任务。</li></ol><p>虽然系统中只有一台打印机，但是当每个进程提出的打印请求时，系统都会<font color='#BAOC2F'>在输出井中为其分配一个存储区</font>（相当于分配了一个逻辑设备），使每个用户都觉得自己在独占一台打印机，从而实现对打印机的共享。即SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，从而改造成共享打印机。</p><h4 id="2-设备的分配与回收"><a href="#2-设备的分配与回收" class="headerlink" title="2.设备的分配与回收"></a>2.设备的分配与回收</h4><h5 id="（1）设备分配方式："><a href="#（1）设备分配方式：" class="headerlink" title="（1）设备分配方式："></a>（1）设备分配方式：</h5><ol><li>静态分配：进程运行前为其分配全部所需资源，运行结束后归还资源（破坏了<font color='#BAOC2F'>请求和保持条件</font>，不会发生死锁）</li><li>动态分配：进程运行的过程中动态申请设备资源</li><li>安全分配方式：为进程分配一个设备后就将进程阻塞，本次IO完成之后才会将进程唤醒（CPU和IO设备只能串行工作、不会死锁）</li><li>不安全分配方式：一个进程可以同时使用多个设备（进程的CPU计算任务与IO任务可以并行处理快速推进，有可能发生死锁）</li></ol><h5 id="（2）设备分配的步骤："><a href="#（2）设备分配的步骤：" class="headerlink" title="（2）设备分配的步骤："></a>（2）设备分配的步骤：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221007085859371.png" alt="image-20221007085859371"></p><p>&#x3D;&#x3D;设备分配数据结构&#x3D;&#x3D;：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221007092742057.png" alt="image-20221007092742057"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221007092750313.png" alt="image-20221007092750313"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221007092757176.png" alt="image-20221007092757176"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221007092805043.png" alt="image-20221007092805043"></p><p>&#x3D;&#x3D;设备分配步骤&#x3D;&#x3D;：</p><ol><li>根据进程请求的<font color='#BAOC2F'>物理设备名</font>查找SDT（物理设备名是<font color='#BAOC2F'>进程请求分配设备时提供的参数</font>）</li><li>根据SDT找到DCT，若设备忙碌则将进程PCB挂到<font color='#BAOC2F'>设备等待队列</font>中，不忙碌则将设备分配给进程</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到<font color='#BAOC2F'>控制器等待队列</font>中，不忙碌则将控制器分配给进程</li><li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到<font color='#BAOC2F'>通道等待队列</font>中，不忙碌则将通道分配给进程</li></ol><h5 id="（3）设备分配步骤改进："><a href="#（3）设备分配步骤改进：" class="headerlink" title="（3）设备分配步骤改进："></a>（3）设备分配步骤改进：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221007093356841.png" alt="image-20221007093356841"></p><p>改进：建立逻辑设备名与物理设备名的<font color='#BAOC2F'>映射机制</font>（利用逻辑设备表LUT），用户编程时只需提供<font color='#BAOC2F'>逻辑设备名</font>。</p><p>&#x3D;&#x3D;设备分配步骤&#x3D;&#x3D;：</p><ol><li>根据进程请求的<font color='#BAOC2F'>逻辑设备名</font>查找SDT（用户编程时提供的逻辑设备名其实就是设备类型）</li><li>查找SDT找到用户进程指定类型的、并且空闲的设备，将其分配给该进程。操作系统在逻辑设备LUT中新增一个表项。</li><li>根据DCT找到COCT，若控制器忙碌则将进程PCB挂到<font color='#BAOC2F'>控制器等待队列</font>中，不忙碌则将控制器分配给进程</li><li>根据COCT找到CHCT，若通道忙碌则将进程PCB挂到<font color='#BAOC2F'>通道等待队列</font>中，不忙碌则将通道分配给进程</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221007094115814.png" alt="image-20221007094115814"></p><h4 id="3-缓冲区管理"><a href="#3-缓冲区管理" class="headerlink" title="3.缓冲区管理"></a>3.缓冲区管理</h4><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可以利用内存作为缓冲区。</p><ul><li>使用硬件作为缓冲区的成本较高、容量小，如存储器管理中使用的<font color='#BAOC2F'>联想寄存器（快表）</font>，由于对页表的访问频率极高因此使用。</li><li>更多的情况是<font color='#BAOC2F'>使用内存作为缓冲区</font>，设备独立性软件的缓冲区管理就是组织管理这些缓冲区。</li></ul><p>缓冲区的作用：</p><ol><li>缓和CPU与IO设备之间速度不匹配的问题</li><li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制</li><li>解决数据粒度不匹配的问题</li><li>提高CPU与IO设备之间的并行性</li></ol><h5 id="（1）单缓冲策略："><a href="#（1）单缓冲策略：" class="headerlink" title="（1）单缓冲策略："></a>（1）单缓冲策略：</h5><p>假设某用户进程请求某种设备读入若干块的数据，</p><p>若采用单缓冲的策略，操作系统会在主存中为其<font color='#BAOC2F'>分配一个缓冲区</font>（若没有特别说明一个缓冲区大小就是一个块）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221007100705709.png" alt="image-20221007100705709"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221007101147983.png" alt="image-20221007101147983"></p><blockquote><p>总结：采用单缓冲策略，处理一块数据平均耗时<code>Max(C, T)+M</code></p></blockquote><h5 id="（2）双缓冲策略："><a href="#（2）双缓冲策略：" class="headerlink" title="（2）双缓冲策略："></a>（2）双缓冲策略：</h5><p>假设某用户进程请求某种设备读入若干块的数据，</p><p>若采用双缓冲的策略，操作系统会在主存中为其<font color='#BAOC2F'>分配两个缓冲区</font>（若没有特别说明一个缓冲区大小就是一个块）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221007101811570.png" alt="image-20221007101811570"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221007101955905.png" alt="image-20221007101955905"></p><blockquote><p>总结：采用双缓冲策略，处理一个数据块的平均耗时为<code>Max(T, C+M)</code></p></blockquote><h5 id="（3）单-x2F-双缓冲在通信时的区别："><a href="#（3）单-x2F-双缓冲在通信时的区别：" class="headerlink" title="（3）单&#x2F;双缓冲在通信时的区别："></a>（3）单&#x2F;双缓冲在通信时的区别：</h5><p>两台机器之间进行通信时，可以配置缓冲区用于数据的发送和接受：</p><ul><li>若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输。</li><li>若两个相互通信的机器只设置双缓冲区，在任一时刻只能实现数据的双向传输。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221007102629040.png" alt="image-20221007102629040"></p><h5 id="（4）循环缓冲区策略："><a href="#（4）循环缓冲区策略：" class="headerlink" title="（4）循环缓冲区策略："></a>（4）循环缓冲区策略：</h5><p>将多个大小相等的缓冲区连接成一个循环队列，橙色表示已充满数据的缓冲区，绿色表示空缓冲区：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221007103001872.png" alt="image-20221007103001872"></p><h5 id="（5）缓冲池策略："><a href="#（5）缓冲池策略：" class="headerlink" title="（5）缓冲池策略："></a>（5）缓冲池策略：</h5><p>缓冲池有系统中共用的缓冲区组成，</p><p>缓冲区<font color='#BAOC2F'>按使用状况</font>可以分为：空缓冲队列、装满输入数据的缓冲队列（输入队列）、装满输出数据的缓冲队列（输出队列）。</p><p>缓冲区<font color='#BAOC2F'>按实际运算中扮演的功能</font>可以分为：用于收容输入数据的工作缓冲区hin、用于提取输入数据的工作缓冲区sin、用于收容输出数据的工作换从区hout、用于提取输出数据的工作缓冲区sout。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221007103636077.png" alt="image-20221007103636077"></p><h3 id="三、磁盘与固态硬盘"><a href="#三、磁盘与固态硬盘" class="headerlink" title="三、磁盘与固态硬盘"></a>三、磁盘与固态硬盘</h3><h4 id="1-磁盘结构"><a href="#1-磁盘结构" class="headerlink" title="1.磁盘结构"></a>1.磁盘结构</h4><p>&#x3D;&#x3D;盘面与柱面&#x3D;&#x3D;：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221004142357865.png" alt="image-20221004142357865"></p><p>&#x3D;&#x3D;磁盘、磁道、扇区&#x3D;&#x3D;：</p><p>磁盘表面由<font color='#BAOC2F'>磁性物质</font>组成可以用来<font color='#BAOC2F'>记录二进制数据</font>，磁盘的盘面被划分成一个个磁道，一个圈就是一个独立的磁道。</p><p>磁道又被划分成为一个个扇区，每一个扇区就是一个磁盘块（各个扇区存放的数据量相同）。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221004131222565.png" alt="image-20221004131222565"></p><blockquote><p>注意：最内侧磁道上的<font color='#BAOC2F'>扇区面积最小</font>，因此<font color='#BAOC2F'>数据密度最大</font>。</p></blockquote><p>&#x3D;&#x3D;磁盘读写的过程&#x3D;&#x3D;：</p><p>根据<font color='#BAOC2F'>磁盘物理地址</font>（柱面号，扇面号，扇区号）读取任意一个磁块：</p><ol><li>根据柱面号移动磁臂，让磁头指向指定柱面</li><li>激活指定盘面对应的磁头</li><li>磁盘旋转的过程中，指定的扇区会从磁头下划过，便完成了对指定扇区的读&#x2F;写。</li></ol><h4 id="2-磁盘调度算法："><a href="#2-磁盘调度算法：" class="headerlink" title="2.磁盘调度算法："></a>2.磁盘调度算法：</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221004134130874.png" alt="image-20221004134130874"></p><h5 id="（1）磁盘读写耗费的时间："><a href="#（1）磁盘读写耗费的时间：" class="headerlink" title="（1）磁盘读写耗费的时间："></a>（1）磁盘读写耗费的时间：</h5><p>一次磁盘读写操作需要花费的时间包括：寻找时间、延迟时间与传输时间：</p><p>&#x3D;&#x3D;寻道时间Ts&#x3D;&#x3D;：在读&#x2F;写数据前，<font color='#BAOC2F'>将磁头移动到指定磁道</font>所花的时间。</p><ol><li>启动磁头臂是需要时间的，假设时间消耗为s</li><li>移动磁头也是需要时间的，假设磁头匀速移动每跨越一个磁道耗时为m，共需要跨越n条磁道</li><li>则寻道时间Ts &#x3D; s + m * n</li></ol><p>&#x3D;&#x3D;延迟时间T<sub>R</sub>&#x3D;&#x3D;：通过<font color='#BAOC2F'>旋转磁盘</font>，使<font color='#BAOC2F'>磁头定位到目标扇区</font>所需要的时间。</p><ol><li>设磁盘转速为r（单位：r&#x2F;s、r&#x2F;min）</li><li>则平均所需的延迟时间Tr &#x3D; (1&#x2F;2) * (1&#x2F;r) &#x3D; 1&#x2F;(2r)</li></ol><blockquote><p>注意：1&#x2F;r为磁盘转一圈所花费的时间，找到目标扇区平均需要转半圈，因此需要乘1&#x2F;2。</p></blockquote><p>&#x3D;&#x3D;传输时间Tt&#x3D;&#x3D;：从磁盘<font color='#BAOC2F'>读出 or 向磁盘写入数据</font>所经历的时间，</p><ol><li>假设磁盘转速为 r，此次读&#x2F;写的字节数为b，每个磁道上的字节数为N。</li><li>则传输时间Tt &#x3D; (1&#x2F;r) * (b&#x2F;N) &#x3D; b&#x2F;(rN)</li></ol><p>&#x3D;&#x3D;所以总的平均存取时间&#x3D;&#x3D;：Ta &#x3D; Ts + 1&#x2F;2r + b&#x2F;(rN)</p><blockquote><p>注意：可以发现延迟时间和传输时间都与<font color='#BAOC2F'>磁盘转速</font>线性相关（转速为硬件固有属性），操作系统<font color='#BAOC2F'>磁盘调度算法只能影响寻道时间</font>。</p></blockquote><h5 id="（2）先来先服务（FCFS）"><a href="#（2）先来先服务（FCFS）" class="headerlink" title="（2）先来先服务（FCFS）"></a>（2）先来先服务（FCFS）</h5><p>根据进程<font color='#BAOC2F'>请求访问磁盘的先后顺序</font>进行调度：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221004132515531.png" alt="image-20221004132515531"></p><ul><li>优点：非常公平，如果请求<font color='#BAOC2F'>访问的磁道比较集中</font>，算法性能还算过得去。</li><li>缺点：如果有大量进程竞争使用磁盘，请求<font color='#BAOC2F'>访问的磁道很分散</font>，则FCFS在性能上很差，寻道时间很长。</li></ul><h5 id="（3）最短寻找时间（SSTF）"><a href="#（3）最短寻找时间（SSTF）" class="headerlink" title="（3）最短寻找时间（SSTF）"></a>（3）最短寻找时间（SSTF）</h5><p>SSTF算法优先处理与当前磁头最接近的磁道，可以保证每次的寻道时间最短（但总的寻道时间不一定最短，贪心思想）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221004132629242.png" alt="image-20221004132629242"></p><ul><li>优点：性能较好，平均寻道时间短</li><li>缺点：可能产生饥饿现象（特殊情况下，某些磁道得不到服务）</li></ul><h5 id="（4）扫描算法（SCAN）"><a href="#（4）扫描算法（SCAN）" class="headerlink" title="（4）扫描算法（SCAN）"></a>（4）扫描算法（SCAN）</h5><p>为了防止出现SSTF出现的饥饿问题，提出扫描算法：只有磁头移动到最外侧磁道的时候才能向内移动，移动到最内侧时才能向外移动。</p><p>由于磁头移动的方式很像电梯，因此扫描算法也叫电梯算法。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221004132832321.png" alt="image-20221004132832321"></p><ul><li>优点：性能较好，平均寻道时间较短，<font color='#BAOC2F'>不会产生饥饿现象</font>。</li><li>缺点：只有到达最边上的磁道时才能改变磁头移动的方向。SCAN算法对于各位置磁道的响应频率不平均。</li></ul><h5 id="（5）LOOK调度算法："><a href="#（5）LOOK调度算法：" class="headerlink" title="（5）LOOK调度算法："></a>（5）LOOK调度算法：</h5><p>LOOK调度算法解决了只有到达最边上磁道时，才能改变移动的方向的缺点。（如果在磁头移动方向上没有请求，则立即改变磁头方向）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221004132939424.png" alt="image-20221004132939424"></p><ul><li>优点：相比与SCAN算法，不需要不需要每次都移动到最外侧or内侧才改变磁头方向，使寻道时间进一步缩短。</li></ul><h5 id="（6）循环扫描算法（C-SCAN）"><a href="#（6）循环扫描算法（C-SCAN）" class="headerlink" title="（6）循环扫描算法（C-SCAN）"></a>（6）循环扫描算法（C-SCAN）</h5><p>C-SCAN算法解决了SCAN算法对于各位置磁道的响应频率不平均的问题。</p><p>其规定了只有磁头朝某个特定方向移动时，才能处理磁道访问请求，而返回时<font color='#BAOC2F'>直接快速移动至起始端</font>而不处理任何请求。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221004133034852.png" alt="image-20221004133034852"></p><ul><li>优点：相比与SCAN算法，对于各个位置磁道的响应频率很平均。</li><li>缺点：只有到达最边上的磁道时才能改变磁头移动的方向，相比SCAN算法平均寻道时间更长。</li></ul><h5 id="（7）C-LOOK算法："><a href="#（7）C-LOOK算法：" class="headerlink" title="（7）C-LOOK算法："></a>（7）C-LOOK算法：</h5><p>C-SCAN算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动的方向，并且磁头返回时不一定需要返回到最边缘的磁道上。</p><p>C-LOOK算法解决了这个问题，如果磁头移动方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要<font color='#BAOC2F'>返回到有磁道访问请求的位置</font>即可。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221004133731593.png" alt="image-20221004133731593"></p><ul><li>优点：比起C-SCAN算法不需要每次都移动到最外侧or最内侧才改变磁头方向，使寻道时间进一步缩短。</li></ul><h4 id="3-磁盘管理"><a href="#3-磁盘管理" class="headerlink" title="3.磁盘管理"></a>3.磁盘管理</h4><h5 id="（1）引导块："><a href="#（1）引导块：" class="headerlink" title="（1）引导块："></a>（1）引导块：</h5><p>计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行<font color='#BAOC2F'>初始化程序</font>（自举程序）完成的。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221004135357670.png" alt="image-20221004135357670"></p><h5 id="（2）磁盘初始化："><a href="#（2）磁盘初始化：" class="headerlink" title="（2）磁盘初始化："></a>（2）磁盘初始化：</h5><ul><li>step1：进行低级格式化（物理格式化）将磁盘的各个磁道划分为扇区。一个扇区通常可分为头、数据区域、尾三个部分。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误）</li><li>step2：将磁盘分区，每个分区由若干柱面组成（即分为C盘、D盘、E盘）</li><li>step3：进行逻辑格式化创建文件系统，包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表)</li></ul><h5 id="（3）坏块的管理："><a href="#（3）坏块的管理：" class="headerlink" title="（3）坏块的管理："></a>（3）坏块的管理：</h5><ul><li><p>对于简单的磁盘：在逻辑格式化时（建立文件系统时）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，如在FAT表上标明。该处理方式中坏块对操作系统透明。</p></li><li><p>对于复杂的磁盘：磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表，在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化。会保留一些<font color='#BAOC2F'>备用扇区</font>用于替换坏块。该处理方式中坏块对操作系统透明。</p></li></ul><h4 id="4-固态硬盘SSD"><a href="#4-固态硬盘SSD" class="headerlink" title="4.固态硬盘SSD"></a>4.固态硬盘SSD</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221004140511378.png" alt="image-20221004140511378"></p>]]></content>
      
      
      <categories>
          
          <category> operating system </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：文件管理</title>
      <link href="/2023/03/01/operatingSystem/4.%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
      <url>/2023/03/01/operatingSystem/4.%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章：文件管理"><a href="#第四章：文件管理" class="headerlink" title="第四章：文件管理"></a>第四章：文件管理</h1><hr><h3 id="一、文件目录★"><a href="#一、文件目录★" class="headerlink" title="一、文件目录★"></a>一、文件目录★</h3><h4 id="1-文件控制块"><a href="#1-文件控制块" class="headerlink" title="1.文件控制块"></a>1.文件控制块</h4><p>文件控制块FCB，File Control Block是实现文件目录的关键数据结构，</p><p>双击打开目录时，操作系统会在该目录中找到关键字<code>照片</code>对应的目录项，从外存中将目录信息读入内存，目录中的内容就显示了。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221001105621519.png" alt="image-20221001105621519"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221001110232240.png" alt="image-20221001110232240"></p><ol><li>FCB的有序集合称为文件目录，1个FCB就是1个文件目录项，</li><li>FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等）、存取控制信息（读写权限）、使用信息（创建时间）</li></ol><h4 id="2-目录结构"><a href="#2-目录结构" class="headerlink" title="2.目录结构"></a>2.目录结构</h4><h5 id="（1）单级目录结构："><a href="#（1）单级目录结构：" class="headerlink" title="（1）单级目录结构："></a>（1）单级目录结构：</h5><p>早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占用一个目录项（不适用与多用户操作系统）。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221001111353468.png" alt="image-20221001111353468"></p><h5 id="（2）两级目录结构："><a href="#（2）两级目录结构：" class="headerlink" title="（2）两级目录结构："></a>（2）两级目录结构：</h5><p>早期的多用户操作系统采用两级目录结构，分为主文件目录MFD，MasterFileDirectory和用户文件目录UFD，UserFileDirectory</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221001111730325.png" alt="image-20221001111730325"></p><h5 id="（3）多级目录结构："><a href="#（3）多级目录结构：" class="headerlink" title="（3）多级目录结构："></a>（3）多级目录结构：</h5><p>在多级目录结构&#x2F;树形目录结构中，用户要访问某个文件时需要用文件路径名标识文件，文件路径名是个字符串各级目录之间用&#x2F;隔开。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221001112019129.png" alt="image-20221001112019129"></p><p>树形目录结构可以很方便地对文件进行分类，层次结构清晰能更有效地进行文件的管理和保护。</p><p>但是树形结构<font color='#BAOC2F'>不便于实现对文件的共享</font>，于是提出了无环图目录结构。</p><h5 id="（4）无环图目录结构："><a href="#（4）无环图目录结构：" class="headerlink" title="（4）无环图目录结构："></a>（4）无环图目录结构：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221001112325540.png" alt="image-20221001112325540"></p><p>可以用不同文件名指向同一个文件or目录，需要为每个结点设置一个共享计数器用于记录此时有多少个地方在共享该结点。</p><h4 id="3-索引结点"><a href="#3-索引结点" class="headerlink" title="3.索引结点"></a>3.索引结点</h4><p>索引结点是对文件控制块的优化，在查找各级目录的过程中只需用到文件名这个信息，只有文件名匹配时才需要读出文件的其他信息，</p><p>因此可考虑让目录表简化，当文件找到对应的目录项时才需要将索引结点调入内存，存放在外存中的索引结点称为磁盘索引结点，当索引结点放入内存后称为内存索引结点（相比磁盘结点需要增加一些信息）。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221001113156098.png" alt="image-20221001113156098"></p><h3 id="二、文件的逻辑结构"><a href="#二、文件的逻辑结构" class="headerlink" title="二、文件的逻辑结构"></a>二、文件的逻辑结构</h3><p>无结构文件：文件内部的数据就是<font color='#BAOC2F'>一系列二进制流or字符流</font>组成又称为流式文件，如<code>.txt</code>文件</p><p>有结构文件：由一组<font color='#BAOC2F'>相似的记录</font>组成又称记录式文件，每条记录又称若干个数据项组成，如数据库表文件。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221001104540618.png" alt="image-20221001104540618"></p><h4 id="1-顺序文件："><a href="#1-顺序文件：" class="headerlink" title="1.顺序文件："></a>1.顺序文件：</h4><p>顺序文件：文件中的记录一个个顺序排列（逻辑上），记录可以是定长的or可变长的。各个记录在物理上可以顺序存储or链式存储。</p><ul><li>串结构：记录之间的顺序与关键字无关</li><li>顺序结构：记录之间的顺序按关键字顺序排列</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221001103257983.png" alt="image-20221001103257983"></p><h4 id="2-索引文件："><a href="#2-索引文件：" class="headerlink" title="2.索引文件："></a>2.索引文件：</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221001103455876.png" alt="image-20221001103455876"></p><p>索引表本身是定长记录的顺序文件，因此可以快速找到第<code>i</code>个记录对应的索引项。</p><p>可以将关键字作为索引号内容，按照<font color='#BAOC2F'>关键字排序排列</font>则还可以支持按照关键字折半查找。</p><p>每当要增加&#x2F;删除一个记录时，需要对索引表进行修改，由于索引文件有很快的检索速度，因此主要用于对信息处理及时性高的场景。</p><h4 id="3-索引顺序文件："><a href="#3-索引顺序文件：" class="headerlink" title="3.索引顺序文件："></a>3.索引顺序文件：</h4><p>索引顺序文件是索引文件与顺序文件的结合，索引顺序文件中会建立一张索引表，一组文件对应一个索引表项：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221001104157922.png" alt="image-20221001104157922"></p><p>为了进一步提高检索的效率，可以为顺序文件建立多级索引表：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221001104407911.png" alt="image-20221001104407911"></p><h3 id="三、文件的物理结构★"><a href="#三、文件的物理结构★" class="headerlink" title="三、文件的物理结构★"></a>三、文件的物理结构★</h3><p>文件的物理结构主要讨论的是文件数据应该怎样存放在外存中。</p><p>与内存管理相同，在外存管理中为了方便对文件数据的管理，文件的逻辑地址空间被分为了一个个文件块。</p><p>文件的逻辑地址可以表示为（逻辑块号，块内地址）的形式。</p><blockquote><p>注：需要关注操作系统如何将<font color='#BAOC2F'>文件块号</font>映射为<font color='#BAOC2F'>物理块号</font>。</p></blockquote><h4 id="1-连续分配"><a href="#1-连续分配" class="headerlink" title="1.连续分配"></a>1.连续分配</h4><p>连续分配方式要求每个文件在磁盘上占有一组连续的块，</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003112120176.png" alt="image-20221003112120176"></p><p>用户只需要给出访问的逻辑块号，操作系统找到该文件对应的目录项PCB，则可算出<code>物理块号=起始块号+逻辑块号</code>。</p><ul><li>优点：连续分配支持顺序访问和直接访问（随机访问），连续分配的文件在顺序读&#x2F;写时速度最快。</li><li>缺点：物理上采用连续分配的文件不方便扩展，存储空间利用率较低，会产生难以利用的磁盘碎片。</li></ul><h4 id="2-链接分配"><a href="#2-链接分配" class="headerlink" title="2.链接分配"></a>2.链接分配</h4><p>链接分配采用离散分配的方式，可以为文件采用离散的磁盘块，分为隐式链接和显式链接两种。</p><h5 id="（1）隐式链接："><a href="#（1）隐式链接：" class="headerlink" title="（1）隐式链接："></a>（1）隐式链接：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003112423587.png" alt="image-20221003112423587"></p><p>用户只需要给出访问的逻辑块号i，操作系统找到该文件对应的目录项PCB，</p><p>从目录中找到起始块号，将0块号逻辑块读入内存，由此知道1号逻辑块存放的物理块号，于是读入1号逻辑快……</p><ul><li>优点：便于文件的扩展，不会有碎片问题，外存利用率很高。</li><li>缺点：采用链式分配方式的文件只支持顺序访问不支持随机访问，查找效率很低，存储指针需要耗费少量空间。</li></ul><h5 id="（2）显式链接："><a href="#（2）显式链接：" class="headerlink" title="（2）显式链接："></a>（2）显式链接：</h5><p>把用于链接文件各个物理块的指针显式的存放在一张表中，即文件分配表FAT，FileAllocationTable。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003112555170.png" alt="image-20221003112555170"></p><blockquote><ol><li>一个磁盘仅需要设置1张FAT，开机时读入内存并常驻。</li><li>各个表项在物理上连续存储，每个表项长度相同，因此物理块号字段可以是隐藏的。</li></ol></blockquote><p>用户只需要给出访问的逻辑块号i，操作系统找到该文件对应的目录项PCB，</p><p>从目录中找到起始块号，若i&gt;0则查询内存中的文件分配表FAT，往后找到i号逻辑块对应的物理块号，</p><p>逻辑块号转换成物理块号的过程不需要读磁盘操作。</p><ul><li>优点：<ul><li>采用显示链式分配方式的文件，支持顺序访问和随机访问。</li><li>由于块号转换过程无需访问磁盘，较隐式链接访问速度快很多。</li><li>便于文件的扩展，不会产生外部碎片。</li></ul></li><li>缺点：文件分配表需要占用一定的内存存储空间。</li></ul><h4 id="3-索引分配"><a href="#3-索引分配" class="headerlink" title="3.索引分配"></a>3.索引分配</h4><p>索引分配允许文件离散的分布在各个磁盘中，系统会为每个文件建立一张索引表，索引表中记录了文件的各个逻辑块对应的物理块。</p><p>索引表存放的磁盘块称为<font color='#BAOC2F'>索引块</font>，文件数据存放的磁盘块称为<font color='#BAOC2F'>数据块</font>。</p><blockquote><ul><li>在显式链接的链式分配方式中，文件分配表FAT是一个磁盘对应一张。</li><li>而索引分配方式中，索引表是一个文件对应一张。</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003112754861.png" alt="image-20221003112754861"></p><p>用户只需要给出访问的逻辑块号i，操作系统找到该文件对应的目录项PCB，</p><p>从目录中可以知道索引表的存放位置，将索引表从外存读入内存，并查找索引表即可知<code>i</code>号逻辑块在外存中的存放位置。</p><ul><li>优点：索引分配方式可以支持随机访问，文件拓展也很容易实现（只需给文件分配一个空闲块，并增加一个索引表项即可）。</li><li>缺点：索引表需要占用一定的存储空间。</li></ul><p>如果一个文件的大小超过了256块，那么一个磁盘块是装不下文件的整张索引表的，如何解决该问题？</p><p>&#x3D;&#x3D;链接方案&#x3D;&#x3D;：如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003112942220.png" alt="image-20221003112942220"></p><p>如果想要访问文件的最后一个逻辑块，就必须顺序地读入前255个索引块，这样显然是十分低效的。</p><p>&#x3D;&#x3D;多层索引&#x3D;&#x3D;：原理类似于多级页表，使第一层索引块指向第二层的索引块，还可以根据文件大小的要求再建立第三层、第四层索引块。</p><blockquote><p>注：若采用多层索引，则各层索引表的大小不能超过一个磁盘块。</p></blockquote><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221002202152056.png" alt="image-20221002202152056"></p><p>&#x3D;&#x3D;混合索引&#x3D;&#x3D;：多种索引分配方式的结合，顶级索引表中</p><p>既可以包含<font color='#BAOC2F'>直接地址索引</font>（直接指向数据块），又包含<font color='#BAOC2F'>一级间接索引</font>（指向单层索引表）、还包含<font color='#BAOC2F'>两级间接索引</font>（指向两层索引表）。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221002203459930.png" alt="image-20221002203459930"></p><p>重要考点：</p><ol><li>根据多层索引、混合索引的结构计算出文件的最大长度（key：各级索引表最大不能超过一个块）</li><li>能够分析访问某个数据块所需要的读磁盘的次数（key：FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块）</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221002204009235.png" alt="image-20221002204009235"></p><h3 id="四、文件存储空间管理"><a href="#四、文件存储空间管理" class="headerlink" title="四、文件存储空间管理"></a>四、文件存储空间管理</h3><ul><li>目录区：主要存放目录信息FCB、用于磁盘存储空间管理的信息。</li><li>文件区：主要用于存放文件数据</li><li>存储空间初始化：将各个文件卷划分为目录区</li></ul><h4 id="1-空闲表法："><a href="#1-空闲表法：" class="headerlink" title="1.空闲表法："></a>1.空闲表法：</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003113327135.png" alt="image-20221003113327135"></p><ul><li>存储分配：与内存管理中的动态分区分配相似<font color='#BAOC2F'>分配连续的存储空间</font>，同样可采用<font color='#BAOC2F'>首次适应等算法</font>来确定分配的区间。</li><li>存储回收：与内存管理中的动态分区分配相似，当回收某个存储区时有4种情况，总之需要<font color='#BAOC2F'>注意表项的合并问题</font>。</li></ul><h4 id="2-空闲链表法："><a href="#2-空闲链表法：" class="headerlink" title="2.空闲链表法："></a>2.空闲链表法：</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003113950846.png" alt="image-20221003113950846"></p><p>&#x3D;&#x3D;空闲盘块链&#x3D;&#x3D;：</p><p>以盘块为单位组成一条空闲链，操作系统<font color='#BAOC2F'>保存着链头、链尾指针</font>。</p><ul><li>存储分配：若某文件申请K个盘块，则从链头开始依次摘下K个盘块分配，并修改空闲的链头指针。</li><li>存储回收：回收的盘块依次挂到链尾，并修改空闲链的链尾指针。</li></ul><p>这种方式适用于离散分配的物理结构，为文件分配盘块时可能需要重复多次操作。</p><p>&#x3D;&#x3D;空闲盘区链&#x3D;&#x3D;：</p><p>以盘区为单位组成一条空闲链，操作系统<font color='#BAOC2F'>保存着链头、链尾指针</font>。</p><ul><li>存储分配：若某文件申请K个盘块，则可以采用<font color='#BAOC2F'>首次适应等算法</font>从链头开始检索，按照算法规则找到大小符要求的空闲盘区，</li><li>存储回收：若会收区和某个空闲盘相邻，则需要将会收区合并到空闲盘区中。若回收区没有和任何空闲区相邻，将回收区作为单独的一个空闲盘区挂到链尾。</li></ul><p>这种管理方式对于离散分配、连续分配都适用，为1个文件分配多个盘块时效率更高。</p><h4 id="3-位示图法：★"><a href="#3-位示图法：★" class="headerlink" title="3.位示图法：★"></a>3.位示图法：★</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003115729986.png" alt="image-20221003115729986"></p><ul><li>存储分配：若某文件申请K个盘块，<ul><li>step1：顺序扫描位示图找到K个相邻or不相邻的未分配存储空间<code>0</code></li><li>step2：根据字号位号算出对应的盘块号，将相应盘块分配给文件</li><li>step3：将相应位设置为1</li></ul></li><li>存储回收：<ul><li>step1：根据回收的盘块号计算出对应的字号、位号</li><li>step2：将相应二进制位设置为0</li></ul></li></ul><h4 id="4-成组链接法："><a href="#4-成组链接法：" class="headerlink" title="4.成组链接法："></a>4.成组链接法：</h4><p>空闲表法、空闲链表法不适用于大型的文件系统（空闲表&#x2F;空闲链表可能过大），UNIX系统中采用了<font color='#BAOC2F'>成组链接法</font>对磁盘空闲块进行管理。</p><p>文件卷的目录中区中<font color='#BAOC2F'>专门用一个磁盘作为超级块</font>，当系统启动时需要将超级块读入内存，并且要保证内存与外存中的超级块数据一致。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003124713037.png" alt="image-20221003124713037"></p><h3 id="五、文件的基本操作"><a href="#五、文件的基本操作" class="headerlink" title="五、文件的基本操作"></a>五、文件的基本操作</h3><h4 id="1-创建文件create"><a href="#1-创建文件create" class="headerlink" title="1.创建文件create"></a>1.创建文件create</h4><p>用户进行Create系统调用时，需要提供的<font color='#BAOC2F'>几个主要参数</font>：</p><ul><li>所需的外存空间大小，如一个盘块即1KB</li><li>文件存放路径，如”D:&#x2F;Demo”</li><li>文件名，默认为新建文本文件.txt</li></ul><p>操作系统处理create系统调用时，主要做的工作：</p><ol><li>在外存中找到文件所需的空间（使用空闲链表法、位示图、成组链接法等管理策略来寻找空闲空间）</li><li>根据<font color='#BAOC2F'>文件存放路径的信息</font>找到该目录对应的目录文件，在目录中创建该文件对应的目录项（目录中包含了文件名、外存存放位置等重要信息）。</li></ol><h4 id="2-删除文件delete"><a href="#2-删除文件delete" class="headerlink" title="2.删除文件delete"></a>2.删除文件delete</h4><p>用户进行Delete系统调用时，需要提供的<font color='#BAOC2F'>几个主要参数</font>：</p><ul><li>文件存放路径，如”D:&#x2F;Demo”</li><li>文件名，”test.txt”</li></ul><p>操作系统处理Delete系统调用时，主要做的工作：</p><ol><li>根据<font color='#BAOC2F'>文件存放路径</font>找到相应的目录文件，从目录中找到对应的目录项。</li><li>根据<font color='#BAOC2F'>目录项记录的文件信息</font>回收文件占用的磁盘块（回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略来做不同处理）</li><li>从目录表中删除文件对应的目录项。</li></ol><h4 id="3-打开文件open"><a href="#3-打开文件open" class="headerlink" title="3.打开文件open"></a>3.打开文件open</h4><p>在很多操作系统中在对文件进行操作之前，要求用户先使用opne系统调用<font color='#BAOC2F'>打开文件</font>，需要提供的<font color='#BAOC2F'>几个主要参数</font>：</p><ul><li>文件存放路径，如”D:&#x2F;Demo”</li><li>文件名，”test.txt”</li><li>要对文件的操作类型，如r、w、rw</li></ul><p>&#x3D;&#x3D;操作系统处理open系统调用时，主要做的工作&#x3D;&#x3D;：</p><ol><li>根据<font color='#BAOC2F'>文件存放路径</font>找到相应的目录文件，从目录中找到对应的目录项，然后<font color='#BAOC2F'>检查该用户是否有指定的权限操作</font>。</li><li>将<font color='#BAOC2F'>目录项</font>复制到内存中的<font color='#BAOC2F'>打开文件表</font>中，并将<font color='#BAOC2F'>对应表目的编号</font>返回给用户。</li><li>最后用户使用<font color='#BAOC2F'>打开文件表的编号</font>来指明要操作的文件。</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003180925270.png" alt="image-20221003180925270"></p><h4 id="4-关闭文件close"><a href="#4-关闭文件close" class="headerlink" title="4.关闭文件close"></a>4.关闭文件close</h4><p>&#x3D;&#x3D;操作系统处理close系统调用时，主要做的工作&#x3D;&#x3D;：</p><ol><li>将进程的<font color='#BAOC2F'>打开文件表</font>相应表项进行删除</li><li>回收分配给该文件的<font color='#BAOC2F'>内存空间等资源</font></li><li>系统打开文件表的打开计数器count减1，若count&#x3D;0则删除对应表项。</li></ol><h4 id="5-读文件read"><a href="#5-读文件read" class="headerlink" title="5.读文件read"></a>5.读文件read</h4><p>用户进行read系统调用时，需要提供的<font color='#BAOC2F'>几个主要参数</font>：</p><ul><li>指明是哪个文件（在支持<font color='#BAOC2F'>打开文件</font>操作的系统中，只需要提供文件在打开文件表中的<font color='#BAOC2F'>索引号</font>即可），</li><li>指明要读入多少数据，如读入1KB</li><li>指明读入的数据存放在内存中的位置</li></ul><p>操作系统在处理read系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p><h4 id="6-写文件write"><a href="#6-写文件write" class="headerlink" title="6.写文件write"></a>6.写文件write</h4><p>用户进行write系统调用时，需要提供的<font color='#BAOC2F'>几个主要参数</font>：</p><ul><li>指明是哪个文件（在支持<font color='#BAOC2F'>打开文件</font>操作的系统中，只需要提供文件在打开文件表中的索引号即可）</li><li>指明要写出多少数据，如写出1KB</li><li>指明写回外存的数据存放在外存中的位置</li></ul><p>操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003153744093.png" alt="image-20221003153744093"></p><h3 id="六、文件的共享与保护"><a href="#六、文件的共享与保护" class="headerlink" title="六、文件的共享与保护"></a>六、文件的共享与保护</h3><p>操作系统为用户提供文件共享功能，可以让多个用户共享地使用同一个文件，文件共享的实现方式包括硬链接和软链接。</p><p>多个用户共享1个文件，只要某个用户修改了该文件的数据，其他用户也可以看到文件数据的变化。</p><h4 id="1-文件共享"><a href="#1-文件共享" class="headerlink" title="1.文件共享"></a>1.文件共享</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003155025690.png" alt="image-20221003155025690"></p><h5 id="（1）硬链接"><a href="#（1）硬链接" class="headerlink" title="（1）硬链接"></a>（1）硬链接</h5><p>基于索引结点的共享方式（硬链接）</p><p>索引结点中设置一个链接计数变量count，用于表示链接到本索引结点上的用户目录数量。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003154604504.png" alt="image-20221003154604504"></p><h5 id="（2）软链接"><a href="#（2）软链接" class="headerlink" title="（2）软链接"></a>（2）软链接</h5><p>基于符号链的共享方式（软链接），如windows操作系统中的快捷方式：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003154821249.png" alt="image-20221003154821249"></p><h4 id="2-文件保护"><a href="#2-文件保护" class="headerlink" title="2.文件保护"></a>2.文件保护</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003161427509.png" alt="image-20221003161427509"></p><h5 id="（1）口令保护"><a href="#（1）口令保护" class="headerlink" title="（1）口令保护"></a>（1）口令保护</h5><p>口令一般存放在文件对应的FCBor索引结点中，用户访问文件前需要先输入口令，口令正确则允许用户访问该文件。</p><ul><li>优点：保存口令的空间开销不多，验证口令的时间开销也很小</li><li>缺点：正确的口令存放在系统内部不够安全</li></ul><h5 id="（2）加密保护："><a href="#（2）加密保护：" class="headerlink" title="（2）加密保护："></a>（2）加密保护：</h5><p>使用某个密码对文件进行加密，在访问文件时需要提供正确的密码才能对文件进行正确的解密。</p><ul><li>优点：保密性强不需要在系统中存储密码</li><li>缺点：加密&#x2F;解密需要花费一定的时间</li></ul><h5 id="（3）访问控制："><a href="#（3）访问控制：" class="headerlink" title="（3）访问控制："></a>（3）访问控制：</h5><p>系统在每个文件的FCB中增加一个访问控制列表ACL（Access-Control List），该表中记录了各用户可以对该文件执行哪些操作。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003161115844.png" alt="image-20221003161115844"></p><h3 id="七、文件系统的结构"><a href="#七、文件系统的结构" class="headerlink" title="七、文件系统的结构"></a>七、文件系统的结构</h3><h4 id="1-文件系统在外存中的结构"><a href="#1-文件系统在外存中的结构" class="headerlink" title="1.文件系统在外存中的结构"></a>1.文件系统在外存中的结构</h4><ol><li>原始磁盘</li><li>物理格式化&#x2F;低级格式化之后，并用备用扇区替换坏扇区</li><li>逻辑格式化&#x2F;高级格式化之后，磁盘分区&#x2F;分卷Volume（每个分区可以建立独立的文件系统），完成各分区的<font color='#BAOC2F'>文件系统</font>初始化</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003162922196.png" alt="image-20221003162922196"></p><h4 id="2-文件系统在内存中的结构"><a href="#2-文件系统在内存中的结构" class="headerlink" title="2.文件系统在内存中的结构"></a>2.文件系统在内存中的结构</h4><p>近期访问过的目录文件会缓存在内存中，不用每次都从磁盘读入，这样可以加快目录检索速度。</p><p>open系统调用打开文件的内部过程：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003163641240.png" alt="image-20221003163641240"></p><h3 id="八、虚拟文件系统"><a href="#八、虚拟文件系统" class="headerlink" title="八、虚拟文件系统"></a>八、虚拟文件系统</h3><h4 id="1-虚拟文件系统"><a href="#1-虚拟文件系统" class="headerlink" title="1.虚拟文件系统"></a>1.虚拟文件系统</h4><p>计算机内部有可能<font color='#BAOC2F'>同时存在各种各样的文件系统</font>，操作系统应向上层用户进行提供统一标准的函数接口（虚拟文件系统VFS），</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003165951083.png" alt="image-20221003165951083"></p><p>&#x3D;&#x3D;虚拟文件系统VFS特点&#x3D;&#x3D;：</p><ol><li>向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异。</li><li>要求下层的文件系统必须实现某些规定的函数功能，如open&#x2F;read&#x2F;write（新的文件系统想要在某操作系统上使用，就必须满足该操作系统VFS的要求）</li><li>每打开一个文件VFS就会在主存中新建一个vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统中。</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003172133399.png" alt="image-20221003172133399"></p><p>文件系统中的vnode只存在于主存中，而inode既会被调入主存也会在外存中存储。</p><p>打开文件后创建vnode，并将文件信息复制到vnode中，vnode的<font color='#BAOC2F'>函数功能指针</font>指向具体文件系统的函数功能。</p><h4 id="2-文件系统的挂载"><a href="#2-文件系统的挂载" class="headerlink" title="2.文件系统的挂载"></a>2.文件系统的挂载</h4><p>文件系统的挂载mounting即文件系统安装&#x2F;装载，如何将一个文件系统挂载到操作系统中：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003172840156.png" alt="image-20221003172840156"></p><p>&#x3D;&#x3D;文件挂载需要做的操作&#x3D;&#x3D;：</p><ol><li>在VFS中<font color='#BAOC2F'>注册新挂载的文件系统</font>，内存中的挂载表（mount table）包含每个文件系统的相关信息，包括文件系统类型、容量大小等。</li><li>新挂载的文件系统要向VFS提供一个<font color='#BAOC2F'>函数地址列表</font>，以便调用挂载文件系统的功能</li><li>将新文件系统加到挂载点（mount point），也就是将新文件系统挂载在某个父目录下</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221003173601938.png" alt="image-20221003173601938"></p>]]></content>
      
      
      <categories>
          
          <category> operating system </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：内存管理</title>
      <link href="/2023/03/01/operatingSystem/3.%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2023/03/01/operatingSystem/3.%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章：内存管理"><a href="#第三章：内存管理" class="headerlink" title="第三章：内存管理"></a>第三章：内存管理</h1><hr><h3 id="一、内存管理"><a href="#一、内存管理" class="headerlink" title="一、内存管理"></a>一、内存管理</h3><h4 id="1-内存管理内容"><a href="#1-内存管理内容" class="headerlink" title="1.内存管理内容"></a>1.内存管理内容</h4><h5 id="（1）地址转换："><a href="#（1）地址转换：" class="headerlink" title="（1）地址转换："></a>（1）地址转换：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220924075118384.png" alt="image-20220924075118384"></p><h6 id="Point1：程序装入"><a href="#Point1：程序装入" class="headerlink" title="Point1：程序装入"></a>Point1：程序装入</h6><p>&#x3D;&#x3D;绝对装入&#x3D;&#x3D;：在<font color='#BAOC2F'>编译时</font>如果知道程序将放入到内存中的哪个位置，编译程序将产生<font color='#BAOC2F'>绝对地址</font>的目标代码。装入程序按照装入模块中的地址，将程序的数据装入内存。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220924072557250.png" alt="image-20220924072557250"></p><p>&#x3D;&#x3D;可重定位装入（静态重定位）&#x3D;&#x3D;：根据内存的目前情况将装入模块装入到内存的适当位置（装入时对地址进行重定位），地址变换是在装入时一次完成的。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220924073124235.png" alt="image-20220924073124235"></p><p>&#x3D;&#x3D;动态运行时装入（动态重定位）&#x3D;&#x3D;：装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是<font color='#BAOC2F'>把地址转换推迟到程序真正要执行时</font>才进行（装入内存后所有的地址依然是逻辑地址），这种方式需要一个重定位寄存器的支持。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220924074040911.png" alt="image-20220924074040911"></p><p>动态重定位优点：</p><ol><li>允许程序在内存中发生移动。</li><li>可将程序分配到不连续的存储区中</li><li>在程序运行前只需装入部分代码即可投入运行</li><li>在程序运行期间，可根据需要动态申请分配内存空间</li><li>便于程序段的共享</li><li>可向用户提供一个比存储空间<font color='#BAOC2F'>大得多的地址空间</font></li></ol><h6 id="Point2：程序链接"><a href="#Point2：程序链接" class="headerlink" title="Point2：程序链接"></a>Point2：程序链接</h6><p>&#x3D;&#x3D;静态链接&#x3D;&#x3D;：在程序运行之前，先将<font color='#BAOC2F'>各目标模块</font>及<font color='#BAOC2F'>所需的库函数</font>连接成一个完整的可执行文件（装入模块），之后不再拆开。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220924084723863.png" alt="image-20220924084723863"></p><p>&#x3D;&#x3D;装入时动态链接&#x3D;&#x3D;：将各目标模块装入内存时，边装入边链接的方式。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220924084939171.png" alt="image-20220924084939171"></p><p>&#x3D;&#x3D;运行时动态链接&#x3D;&#x3D;：在程序执行中<font color='#BAOC2F'>需要该目标模块</font>时才对其进行链接，这种方式便于修改和更新，便于实现对目标模块的共享。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220924085235225.png" alt="image-20220924085235225"></p><h5 id="（2）内存保护："><a href="#（2）内存保护：" class="headerlink" title="（2）内存保护："></a>（2）内存保护：</h5><p>&#x3D;&#x3D;上下限寄存器&#x3D;&#x3D;：在CPU中设置一对上下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220924110023534.png" alt="image-20220924110023534"></p><p>&#x3D;&#x3D;重定位寄存器&#x3D;&#x3D;：采用重定位寄存器（基地址寄存器）和界地址寄存器（限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址，界地址寄存器中存放的是进程的最大逻辑地址。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220924110702272.png" alt="image-20220924110702272"></p><h5 id="（3）内存空间的扩充："><a href="#（3）内存空间的扩充：" class="headerlink" title="（3）内存空间的扩充："></a>（3）内存空间的扩充：</h5><h6 id="Point1：覆盖技术"><a href="#Point1：覆盖技术" class="headerlink" title="Point1：覆盖技术"></a>Point1：覆盖技术</h6><p>覆盖技术：将程序分为多个段，常用段常驻内存不常用段在需要时调入内存，以解决程序大小超过物理内存总和的问题。</p><ul><li>常用段：放在内存的固定区中，调入后就不再调出（除非运行结束）</li><li>非常用段：放在覆盖区，需要用到时调入内存，用不到时调出内存。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220924112306127.png" alt="image-20220924112306127"></p><h6 id="Point2：交换技术"><a href="#Point2：交换技术" class="headerlink" title="Point2：交换技术"></a>Point2：交换技术</h6><p>交换技术：内存空间紧张时，系统将内存中的某些进程<font color='#BAOC2F'>暂时换出外存</font>（进程的PCB保留在仍然内存中），把内存中某些已具备运行条件的<font color='#BAOC2F'>进程换入内存</font>（进程在内存与磁盘间动态调度）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220924114542054.png" alt="image-20220924114542054"></p><p>&#x3D;&#x3D;问题1：在外存的什么位置保存被换出的进程？&#x3D;&#x3D;</p><p>在具有交换功能的操作系统中，通常把磁盘分为文件区与对换区两部分。</p><ul><li>文件区：主要用于存放文件，追求存储空间的利用率（采用离散分配方式）</li><li>对换区：主要用于存储被换出的进程，追求换入换出速度（采用连续分配方式）</li></ul><p>&#x3D;&#x3D;问题2：什么时候进行进程交换？&#x3D;&#x3D;</p><p>交换通常在进程运行且内存吃紧的情况下发生，而当系统符合降低时就暂停。</p><p>例如：在发现许多进程运行时经常发生缺页，就说明内存紧张此时可以换出一些内存，而当缺页率下降时就可以暂停换出。</p><p>&#x3D;&#x3D;问题3：应该交换出哪些进程？&#x3D;&#x3D;</p><p>可优先换出阻塞的进程、优先换出优先级更低的进程、为了防止优先级低的进程饥饿，还会考虑进程在内存中驻留的时间问题。</p><blockquote><p>【补充】覆盖与交换的区别</p><ol><li>覆盖是在同一个程序或进程中进行的</li><li>交换是在不同的进程（或作业）之间进行的</li></ol></blockquote><h5 id="（4）内存空间的分配与回收："><a href="#（4）内存空间的分配与回收：" class="headerlink" title="（4）内存空间的分配与回收："></a>（4）内存空间的分配与回收：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220927072929670.png" alt="image-20220927072929670"></p><h4 id="2-连续分配管理方式"><a href="#2-连续分配管理方式" class="headerlink" title="2.连续分配管理方式"></a>2.连续分配管理方式</h4><h5 id="（1）单一连续分配："><a href="#（1）单一连续分配：" class="headerlink" title="（1）单一连续分配："></a>（1）单一连续分配：</h5><p>在单一连续分配方式中，内存被分为系统区与用户区</p><ul><li>系统区：通常位于内存的低地址部分，用于存放<font color='#BAOC2F'>操作系统</font>相关数据。</li><li>用户区：用于存放用户进程相关数据。</li><li>内存中只能有一道用户程序，用户程序独占整个用户区空间。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220924122030205.png" alt="image-20220924122030205"></p><h5 id="（2）固定分区分配："><a href="#（2）固定分区分配：" class="headerlink" title="（2）固定分区分配："></a>（2）固定分区分配：</h5><p>将整个用户空间划分为固定大小分区，每个分区中装入一道作业，为支持多道程序系统在内存中装入多道程序（且互不干扰）。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220924123215280.png" alt="image-20220924123215280"></p><h5 id="（3）动态分区分配："><a href="#（3）动态分区分配：" class="headerlink" title="（3）动态分区分配："></a>（3）动态分区分配：</h5><p>不预先划分内存分区，而是在进程装入内存时根据进程的大小动态的建立分区，并使分区的大小正好适合进程的需要，因此系统分区的大小和数量是可变的。</p><p>&#x3D;&#x3D;问题1：操作系统用什么数据结构记录内存的使用情况？&#x3D;&#x3D;</p><p>答：空闲分区表、空闲分区链</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220924123916602.png" alt="image-20220924123916602"></p><p>&#x3D;&#x3D;问题2：当有多个空闲分区满足需求时，应该选择哪个分区进行分配？&#x3D;&#x3D;</p><p>答：需要按照<font color='#BAOC2F'>动态分区分配算法</font>从空闲分区表或空闲分区链中选出一个分区分配该改作业，包含4中动态分区分配算法。</p><p>&#x3D;&#x3D;问题3：如何进行分区的分配与回收？&#x3D;&#x3D;</p><p>答：回收之后如果发现有一些空闲分区是相邻的，则需要对空闲分区进行合并。</p><blockquote><p>注：关于内部与外部碎片</p><ol><li>内部碎片：分配给某进程的内存区域中，有些部分没有用上</li><li>外部碎片：内存中的某些空闲分区由于太小而难以利用上。</li></ol></blockquote><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220924125341539.png" alt="image-20220924125341539"></p><h5 id="（4）动态分区分配算法："><a href="#（4）动态分区分配算法：" class="headerlink" title="（4）动态分区分配算法："></a>（4）动态分区分配算法：</h5><p>&#x3D;&#x3D;首次适应算法First Fit&#x3D;&#x3D;：</p><ul><li><p>算法思想：每次都从低地址开始查找，找到<font color='#BAOC2F'>第1个能够满足大小</font>的空闲分区。</p></li><li><p>算法实现：空闲分区以<font color='#BAOC2F'>地址递增</font>的次序进行排列，每次分配内存时顺序查找空闲分区链or空闲分区表，找到大小能够满足要求的第1个空闲分区。</p></li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220925105956412.png" alt="image-20220925105956412"></p><p>&#x3D;&#x3D;最佳适应算法Best Fit&#x3D;&#x3D;：</p><ul><li>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证大进程到来时能有连续的大片空间，可以尽可能多的留下大片的空闲区域，即<font color='#BAOC2F'>优先使用更小的空闲区域</font>。</li><li>算法实现：空闲分区按容量<font color='#BAOC2F'>递增次序链接</font>，分配内存时顺序查找空闲分区链or空闲分区表，找到大小满足要求的第1个空闲分区。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220925111230304.png" alt="image-20220925111230304"></p><blockquote><p>BestFit缺点：每次都选取最小的分区进行分配，会留下越来越多<font color='#BAOC2F'>很小的难以利用的内存块</font>（外部碎片）。</p></blockquote><p>&#x3D;&#x3D;最坏适应算法Worst Fit&#x3D;&#x3D;：</p><ul><li>算法思想：为解决BestFit算法的问题，可以在每次分配时优先使用<font color='#BAOC2F'>最大的连续空闲区</font>，这样分配后剩余的空闲区就不会太小。</li><li>算法实现：空闲分区按照容量<font color='#BAOC2F'>递减次序进行链接</font>，每次分配内存时顺序查找空闲分区链or空闲分区表，找到大小满足要求的第1个空闲分区。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220925111719745.png" alt="image-20220925111719745"></p><p>&#x3D;&#x3D;邻接适应算法NextFit&#x3D;&#x3D;：</p><ul><li>算法思想：首次适应算法每次都从链头开始查找，这可能会导致<font color='#BAOC2F'>低地址部分出现很多小的空闲分区</font>，而每次分配查找时都要经过这些分区，因此也增加了查找的开销。如果<font color='#BAOC2F'>每次都从上次查找结束的位置开始检索</font>就能解决这个问题</li><li>算法实现：空闲分区以<font color='#BAOC2F'>地址递增</font>的顺序排列（可排成循环链表便于检索），每次分配内存时<font color='#BAOC2F'>从上次查找结束的位置开始</font>查找空闲分区or空闲链表，找到大小能够满足要求的第1个空闲分区。</li></ul><blockquote><p>注：邻接适应与首次适应算法与最佳&#x2F;最坏算法相比，在空闲内存分区发生变化后，无需对整个链表进行重新排列（节省开销）。</p></blockquote><p>首次适应算法每次都从头查找检索低地址的小分区，其更有可能把高地址部分的大空闲分区保留下来（最佳适应算法优点）</p><p>邻接适应算法无论高低地址部分的空闲分区都被相同概论的使用，导致大分区被划分为小分区、无大分区可用（最坏适应算法的缺点）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220925115313809.png" alt="image-20220925115313809"></p><blockquote><p>注：综合来看四种算法中反而首次适应算法的空闲内存分区分配策略是最好的。</p></blockquote><h4 id="3-基本分页存储管理"><a href="#3-基本分页存储管理" class="headerlink" title="3.基本分页存储管理"></a>3.基本分页存储管理</h4><h5 id="（1）基本分页存储"><a href="#（1）基本分页存储" class="headerlink" title="（1）基本分页存储"></a>（1）基本分页存储</h5><p>将<font color='#BAOC2F'>内存空间</font>分为大小相等的分区，每个分区就是一个页框&#x2F;页帧&#x2F;内存块&#x2F;物理块&#x2F;物理页面Page Frame，每个页框有一个页框号从0开始。</p><p>将<font color='#BAOC2F'>进程的逻辑地址空间</font>也分为<font color='#BAOC2F'>与页框大小相等</font>的部分，每个部分称为一个页&#x2F;页面Page，每个页面有一个页号从0开始。</p><p>操作系统以页框为单位为各进程分配内存空间，进程的页面与内存的页框有映射关系（每个页面不必连续存放）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220927074257712.png" alt="image-20220927074257712"></p><p>操作系统为每个进程建立一张页表（1个进程对应1张页表），以获取页面在内存中存放的位置（页框位置）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220927074736519.png" alt="image-20220927074736519"></p><p>&#x3D;&#x3D;★问题1：每个页表项占多少字节？&#x3D;&#x3D;</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220927075326885.png" alt="image-20220927075326885"></p><p>&#x3D;&#x3D;★问题2：如何实现逻辑地址到物理地址的转换？&#x3D;&#x3D;</p><p>虽然进程的各个页面是离散存放的，但是页面内部是连续存放的，如果要访问逻辑地址A则：</p><ol><li>确定逻辑地址A对应的<font color='#BAOC2F'>页号P</font></li><li>确定逻辑地址A的<font color='#BAOC2F'>页内偏移量W</font></li><li>找到P号页面在内存中的起始地址（通过查询页表）</li><li>逻辑地址A对应的物理地址 &#x3D; P号页面在内存中的起始地址 + 页内偏移量W</li></ol><p>&#x3D;&#x3D;问题3：如何确定一个逻辑地址对应的页号P 和 页内偏移量W？&#x3D;&#x3D;</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220927084820388.png" alt="image-20220927084820388"></p><p>&#x3D;&#x3D;问题4：页面大小为2的整数次幂，为地址转换带来的好处？&#x3D;&#x3D;</p><ul><li>页号与页内偏移量的计算：如果页面大小为2<sup>k</sup>B，用二进制数表示逻辑地址则末尾k位即为页内偏移量，其余部分即为页号。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220927091711672.png" alt="image-20220927091711672"></p><ul><li>物理地址的计算：根据逻辑地址得到页号，根据页号在页表中找到页面存放的内存块号，将二进制表示的<font color='#BAOC2F'>内存块号</font>与<font color='#BAOC2F'>页内偏移量</font>拼接起来，就可以得到最终的物理地址。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220927091736737.png" alt="image-20220927091736737"></p><ul><li>分页存储管理的逻辑地址结构如下：</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220927092320624.png" alt="image-20220927092320624"></p><h5 id="（2）基本地址变换机构"><a href="#（2）基本地址变换机构" class="headerlink" title="（2）基本地址变换机构"></a>（2）基本地址变换机构</h5><p>基本地址变换机构可以<font color='#BAOC2F'>借助进程的页表</font>将逻辑地址转换为物理地址。</p><p>通常会在系统中设置一个<font color='#BAOC2F'>页表寄存器PTR</font>，存放页表在内存中的起始地址F和页表长度M，</p><p>进程执行时页表始址F和页表长度M存在PCB中，当进程被调度时操作系统内核会将这两个参数放到页表寄存器中。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220927101937966.png" alt="image-20220927101937966"></p><p>&#x3D;&#x3D;设页面大小为L，将逻辑地址A转换到物理地址E的过程如下&#x3D;&#x3D;：</p><ol><li>计算页号与页内偏移量：根据逻辑地址A，划分得到页号P和页内偏移量W（如果是十进制需要手算P&#x3D;A&#x2F;L、W&#x3D;A%L）</li><li>页号合法性检查：比较页号P与页表长度M，若P≥M则产生越界中断（特判P&#x3D;M也会发生中断！）</li><li>计算<font color='#BAOC2F'>页表项地址</font>以获取内存块号：<u>页表项地址&#x3D;页表起始地址F+页号P*页表项长度</u>，取出该页表项内容b即为内存块号</li><li>计算物理地址E：E&#x3D;b*L+W</li><li>用得到的物理地址E去访问内存</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220927102338985.png" alt="image-20220927102338985"></p><blockquote><p>注：在分页存储管理系统，只要确定了<font color='#BAOC2F'>每个页面的大小</font>逻辑地址结构就确定了（页式管理中地址是一维的）</p></blockquote><p>&#x3D;&#x3D;实际应用中通常使一个页框恰好能够放入整数个页表项&#x3D;&#x3D;：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220927103755569.png" alt="image-20220927103755569"></p><h5 id="（3）具有快表的地址变换机构"><a href="#（3）具有快表的地址变换机构" class="headerlink" title="（3）具有快表的地址变换机构"></a>（3）具有快表的地址变换机构</h5><p>具有快表的地址变换机构是对<font color='#BAOC2F'>基本地址变换结构的改进</font>，</p><p>TLB联想寄存器，translation lookaside buffer是一种访问速度比内存快很多的<font color='#BAOC2F'>高速缓存</font>（非内存），用于存放最近访问页表项的副本。</p><p>TLB联想寄存器可以加速地址变换的速度，因此内存中的页表项常被称为慢表。</p><p>&#x3D;&#x3D;引入快表后地址的变换过程&#x3D;&#x3D;：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220927112540176.png" alt="image-20220927112540176"></p><ol><li>CPU给出逻辑地址由硬件计算出页号、页内偏移量，将页号与块表中的所有页号进行比较。</li><li>如果找到匹配的页号，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接成物理地址后访问对应的内存单元。</li><li>如果没有找到匹配的页号，则需要访问内存中的页表找到对应的页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接成物理地址后访问对应的内存单元。（在找到页表项后应同时将其存入快表以便后续使用，若快表已满需按照一定的算法对旧的页表项进行替换）</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220927113438428.png" alt="image-20220927113438428"></p><blockquote><p>注：TLB和普通Cache的区别—TLB中只有<font color='#BAOC2F'>页表项的副本</font>，而普通Cache中可能会有其他的各种数据的副本</p></blockquote><h5 id="（4）两级页表"><a href="#（4）两级页表" class="headerlink" title="（4）两级页表"></a>（4）两级页表</h5><p>单级页表中存在需要改进的问题：</p><p>&#x3D;&#x3D;问题1：根据页号查询页表的方法，要求所有的页表项都连续存放&#x3D;&#x3D;（需要占用很多个连续的页框）</p><p>可将长长的页表进行分组，使每个内存块刚好可以放入一个分组，再将各分组离散的放到各个内存块中。另外要为离散分配的页表再建立一张页表，称为页目录表&#x2F;外层页表&#x2F;顶层页表。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220928120425294.png" alt="image-20220928120425294"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220928120435825.png" alt="image-20220928120435825"></p><p>两级页表实现逻辑地址转换：</p><ol><li>按照地址结构将逻辑地址拆分成三个部分</li><li>从PCB中读出页目录表的起始地址，再根据一级页号查询页目录表，找到下一级页表在内存中的存放位置。</li><li>根据二级页号查表，找到最终想要访问的内存块号</li><li>结合页内偏移量得到物理地址</li></ol><p>&#x3D;&#x3D;问题2：进程在一段时间内只需访问某几个特定的页面就可正常工作，没有必要让整个页表都常驻内存中&#x3D;&#x3D;</p><p>可以在需要访问页面时才将页面调入内存（虚拟存储技术），可以<font color='#BAOC2F'>在页表项中添加一个标志位</font>用于表示该页面是否已调入内存。如果想要访问的页面不再内存中，则产生缺页中断（内中断）然后将目标页面从外存中调入内存。</p><p>&#x3D;&#x3D;问题3：若采用多级页表机制，则各级页表的大小不能超过一个页面&#x3D;&#x3D;</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220928124821393.png" alt="image-20220928124821393"></p><blockquote><p>注：两级页表的分表使得访问内存的次数变多，具体访问次数为n级页面访问内存的次数为n+1次</p></blockquote><h4 id="4-基本分段存储管理"><a href="#4-基本分段存储管理" class="headerlink" title="4.基本分段存储管理"></a>4.基本分段存储管理</h4><h5 id="（1）基本分页存储-1"><a href="#（1）基本分页存储-1" class="headerlink" title="（1）基本分页存储"></a>（1）基本分页存储</h5><p>将进程的地址空间，<font color='#BAOC2F'>按照程序自身的逻辑关系</font>（程序可读性更高）划分为若干个段，每个段都有一个段名（每段从0开始编址）。</p><p>以段为单位进行内存的分配，每个段在内存中占据者连续的空间，但各段之间可以不相邻。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220928130149729.png" alt="image-20220928130149729"></p><p>为了能够<font color='#BAOC2F'>从物理内存中找到各个逻辑段的存放地址</font>，为此需要为各进程建立一张段映射表（段表）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220928132445118.png" alt="image-20220928132445118"></p><h5 id="（2）基本地址变换机构-1"><a href="#（2）基本地址变换机构-1" class="headerlink" title="（2）基本地址变换机构"></a>（2）基本地址变换机构</h5><p>&#x3D;&#x3D;基本分段存储管理地址转换的过程&#x3D;&#x3D;：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220928140929488.png" alt="image-20220928140929488"></p><h5 id="（3）分段存储与分页存储对比："><a href="#（3）分段存储与分页存储对比：" class="headerlink" title="（3）分段存储与分页存储对比："></a>（3）分段存储与分页存储对比：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220928134830805.png" alt="image-20220928134830805"></p><h4 id="5-段页式管理"><a href="#5-段页式管理" class="headerlink" title="5.段页式管理"></a>5.段页式管理</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220928135239068.png" alt="image-20220928135239068"></p><p>综合分段分页管理的优点，提出了段页式内存管理</p><h5 id="（1）段页式管理方式："><a href="#（1）段页式管理方式：" class="headerlink" title="（1）段页式管理方式："></a>（1）段页式管理方式：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220928135607785.png" alt="image-20220928135607785"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220928135727689.png" alt="image-20220928135727689"></p><h5 id="（2）段表页表："><a href="#（2）段表页表：" class="headerlink" title="（2）段表页表："></a>（2）段表页表：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220928140004786.png" alt="image-20220928140004786"></p><h5 id="（3）地址转换："><a href="#（3）地址转换：" class="headerlink" title="（3）地址转换："></a>（3）地址转换：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220928140822412.png" alt="image-20220928140822412"></p><h3 id="二、虚拟内存管理"><a href="#二、虚拟内存管理" class="headerlink" title="二、虚拟内存管理"></a>二、虚拟内存管理</h3><h4 id="1-虚拟内存"><a href="#1-虚拟内存" class="headerlink" title="1.虚拟内存"></a>1.虚拟内存</h4><p>操作系统将内存中暂时用不到的信息换出外存，从而实现内存的虚拟扩充就是虚拟内存技术，虚拟内存的三个特征：</p><ul><li>多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。</li><li>对换性：在作业运行时无序一直常驻内存，而是允许在作业运行过程中将作业换入、换出。</li><li>虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存远大于实际的容量。</li></ul><blockquote><p>注：虚拟内存的实现需要建立在<font color='#BAOC2F'>离散分配的内存管理</font>方式基础之上。</p></blockquote><h4 id="2-请求分页管理方式"><a href="#2-请求分页管理方式" class="headerlink" title="2.请求分页管理方式"></a>2.请求分页管理方式</h4><p>与传统的基本分页管理方式不同，在程序执行过程中</p><p>若所访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序（请求调页&#x2F;段）。</p><p>若内存空间不够时，由操作系统负责将内存中暂时用不到的信息换出到外存（页面&#x2F;段置换）。</p><h5 id="（1）页表机制："><a href="#（1）页表机制：" class="headerlink" title="（1）页表机制："></a>（1）页表机制：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220929190608230.png" alt="image-20220929190608230"></p><h5 id="（2）缺页中断机构："><a href="#（2）缺页中断机构：" class="headerlink" title="（2）缺页中断机构："></a>（2）缺页中断机构：</h5><p>在请求分页系统中，每当要<font color='#BAOC2F'>访问的页面不在内存时</font>便产生一个缺页中断，然后由操作系统的<font color='#BAOC2F'>缺页中断处理程序</font>处理中断。此时缺页的进程阻塞，放入阻塞队列。在调页完成后再将其唤醒，放回就绪队列。</p><ul><li>如果内存有空闲块则为进程分配一个空闲块，将所缺页面装入该块，并修该页表中相应的页表项。</li><li>如果内存中没有空闲块，则由页面置换算法选择一个页面淘汰。若该页面<font color='#BAOC2F'>在内存期间被修改过</font>，则要将其写回外存未修改的页面不用写回外存。</li></ul><h5 id="（3）地址变换机构："><a href="#（3）地址变换机构：" class="headerlink" title="（3）地址变换机构："></a>（3）地址变换机构：</h5><p>请求分页存储管理与基本分页存储管理的主要区别：</p><ol><li>请求调页（查到页表项时进行判断）</li><li>页面置换（需要调入页面，但没有空闲内存块时进行）</li><li>需要修改请求页表中新增的表项</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220929212124794.png" alt="image-20220929212124794"></p><h5 id="（4）页面置换算法："><a href="#（4）页面置换算法：" class="headerlink" title="（4）页面置换算法："></a>（4）页面置换算法：</h5><p>页面换入&#x2F;换出需要磁盘IO，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率。</p><p>&#x3D;&#x3D;OPT最佳置换算法，Optimal&#x3D;&#x3D;：每次选择淘汰的页面是<font color='#BAOC2F'>以后永不使用</font>or在最长时间内不被访问的页面，可以保证最低的缺页率。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220929215149579.png" alt="image-20220929215149579"></p><blockquote><p>注：最佳置换算法可以保证最低的缺页率，但实际上操作系统无法提前预判页面访问序列，因此OPT置换算法是无法实现的。</p></blockquote><p>&#x3D;&#x3D;FIFO先进先出置换算法&#x3D;&#x3D;：每次淘汰的页面是最早进入内存的页面。</p><p>将调入内存的页面根据<font color='#BAOC2F'>调入先后顺序</font>排成队列，换出页面时选择队头页面，队列的最大长度取决于系统为进程分配的内存块数量。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220929215313654.png" alt="image-20220929215313654"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220929215346399.png" alt="image-20220929215346399"></p><blockquote><p>注：FIFO会产生Belady异常，与进程实际运行时的规律不适应（先进入的页面也有可能是最进程被访问的）因此算法性能较差。</p></blockquote><p>&#x3D;&#x3D;LRU最近最久未置换算法，least recently used&#x3D;&#x3D;：每次淘汰的页面是最近最久未使用的页面，</p><p>在每个页面页表项的<font color='#BAOC2F'>访问字段</font>中，记录页面自上次被访问以来所经历的时间t，需要淘汰页面时选择现有页面中t值最大的即可。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220929220320078.png" alt="image-20220929220320078"></p><blockquote><p>注：LRU算法的实现需要专门的硬件支持，虽然算法性能好（最接近OPT）但是实现困哪、开销较大。</p></blockquote><p>&#x3D;&#x3D;CLOCK时钟置换算法&#x3D;&#x3D;：最近未用算法NRU，Not Recently Used</p><p>为每个页面设置一个访问位，将内存中的页面都通过链接指针链接成一个循环队列。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220929221219764.png" alt="image-20220929221219764"></p><p>&#x3D;&#x3D;改进型的时钟置换算法&#x3D;&#x3D;：</p><p>简单的时钟置换算法仅考虑了页面是否被访问过，</p><p>如果被淘汰的页面没有被修改过，则无需执行IO操作写回外存，只有被淘汰的页面被修改过时才需要写回外存。</p><p>因此除了考虑一个页面的访问、还应考虑是否被修改过，在其他条件都相同时应该优先淘汰没有被修改过的页面。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220929222745608.png" alt="image-20220929222745608"></p><h5 id="（5）页面分配置换策略："><a href="#（5）页面分配置换策略：" class="headerlink" title="（5）页面分配置换策略："></a>（5）页面分配置换策略：</h5><p>驻留集：请求分页存储管理中给进程分配的<font color='#BAOC2F'>物理块&#x2F;页框的集合</font>。如果驻留集太小会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少。如果驻留集太大又会导致多道程序并发度下降，资源利用率降低。</p><p>页面分配策略：</p><ul><li>固定分配：驻留集大小不变，操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。</li><li>可变分配：驻留集大小可变，先为每个进程分配一定数目的物理块，在进程运行期间可根据情况适当做增加与减少。</li></ul><p>页面置换策略：</p><ul><li>局部置换：发生缺页时只能选进程自己的物理块进行置换。</li><li>全局置换：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，在分配给缺页进程。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220930115120463.png" alt="image-20220930115120463"></p><p>&#x3D;&#x3D;固定分配局部置换策略&#x3D;&#x3D;：</p><ol><li>系统为每个进程分配一定数量的物理块，在运行期间都不改变。</li><li>若进程在运行中发生缺页，则只能从该进程在内存中的页面中换出一页，然后再调入需要的页面。</li><li>缺点：很难在刚开始就确定应该为每个进程分配多少个物理块才算合理。</li></ol><p>&#x3D;&#x3D;可变分配局部置换策略&#x3D;&#x3D;：</p><ol><li>刚开始系统为每个进程分配一定数量的物理块，操作系统会保持一个空闲物理块队列，</li><li>当某进程发生缺页时，从空闲物理块中取出一块分配给该进程。若已无空闲物理块则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。</li><li>采用这种策略时，<font color='#BAOC2F'>只要某进程发生缺页都将获得新的物理块</font>，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页面可能是系统中的任何一个进程的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。</li></ol><p>&#x3D;&#x3D;可变分配全局置换策略&#x3D;&#x3D;：</p><ol><li>刚开始会为每个进程分配一定数量的物理块，当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。</li><li>如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势当程度。</li><li>如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</li></ol><blockquote><ul><li>可变分配全局置换：只要缺页就给分配新物理块。</li><li>可变分配局部置换：要<font color='#BAOC2F'>根据发生缺页的频率</font>来动态地增加或减少进程的物理块。</li></ul></blockquote><p>&#x3D;&#x3D;何时调入页面&#x3D;&#x3D;：</p><ul><li>预调页策略：预测不久之后可能访问到的页面，将预先调入内存。该策略主要用于进程的首次调入，由程序员指出先调入的部分。</li><li>请求调页策略：进程在运行期间<font color='#BAOC2F'>发现缺页时</font>才将所缺页面调入内存。该策略调入的页面一定会被访问到，但IO开销比较大。</li></ul><p>&#x3D;&#x3D;何处调入页面&#x3D;&#x3D;：</p><ul><li><p>系统拥有足够的对换区空间时</p><p>  页面的调入调出都是在内存与对换区之间进行的，从而保证页面的调入调出速度，</p><p>  在进程运行前需要将进程相关的数据从文件区复制到对换区。</p></li><li><p>系统缺少足够的对换区空间时</p><p>  对于不会被修改的数据都直接从文件区调入，由于文件不会被修改因此换出时不必写回磁盘，下次需要时再从文件区调入即可。</p><p>  对于可能会被修改的部分，换出时需要写回磁盘对换区，下次需要时再从对换区调入。</p></li><li><p>UNIX方式：</p><p>  运行之前进程有关的数据全部放在文件区，故未使用过的页面都可从文件区调入。</p><p>  若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</p></li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220930124929826.png" alt="image-20220930124929826"></p><h5 id="（6）抖动和工作集："><a href="#（6）抖动和工作集：" class="headerlink" title="（6）抖动和工作集："></a>（6）抖动和工作集：</h5><ul><li>抖动：刚换出的页面马上又要换入内存，刚换入的页面马上又要换出内存，这种频繁的页面调度行为称为抖动&#x2F;颠簸。产生抖动的主要原因是进程频繁访问的页面数量高于可用的物理块数量（分配给进程的物理块不够）</li><li>工作集：在某段时间间隔里，进程实际访问页面的集合。</li><li>驻留集：请求分页存储管理中给进程分配的<font color='#BAOC2F'>物理块&#x2F;页框的集合</font>。</li></ul><blockquote><p>注：驻留集的大小一般不能小于工作集的大小，否则进程运行过程中将发生频繁的缺页。</p></blockquote><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220930130711259.png" alt="image-20220930130711259"></p>]]></content>
      
      
      <categories>
          
          <category> operating system </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：进程管理</title>
      <link href="/2023/03/01/operatingSystem/2.%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
      <url>/2023/03/01/operatingSystem/2.%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章：进程管理"><a href="#第二章：进程管理" class="headerlink" title="第二章：进程管理"></a>第二章：进程管理</h1><hr><h3 id="一、进程与线程"><a href="#一、进程与线程" class="headerlink" title="一、进程与线程"></a>一、进程与线程</h3><h4 id="1-进程概述"><a href="#1-进程概述" class="headerlink" title="1.进程概述"></a>1.进程概述</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916100902297.png" alt="image-20220916100902297"></p><h5 id="（1）进程PCB："><a href="#（1）进程PCB：" class="headerlink" title="（1）进程PCB："></a>（1）进程PCB：</h5><p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个单位。</p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>程序</td><td>是指静态的存放在磁盘里、的可执行的文件，实际上为一系列的指令集合</td></tr><tr><td>进程</td><td>是指动态的、程序的一次执行过程</td></tr></tbody></table><ol><li>一个程序可以同时创建多个进程，当进程被创建时操作系统会为该进程分配<font color='#BAOC2F'>唯一不重复的身份证号PID</font>。</li><li>PCB是进程存在的唯一标志，当进程被创建时系统会为其创建PCB，结束时会收回其PCB。</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916100515094.png" alt="image-20220916100515094"></p><p>这些信息<font color='#BAOC2F'>都将被保存在一个数据结构PCB</font>（Process Control Block）中，即<font color='#BAOC2F'>进程控制块</font>。</p><p>操纵系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息都将被放入在PCB中。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916100603637.png" alt="image-20220916100603637"></p><h5 id="（2）进程的组成："><a href="#（2）进程的组成：" class="headerlink" title="（2）进程的组成："></a>（2）进程的组成：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916100818249.png" alt="image-20220916100818249"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916100722728.png" alt="image-20220916100722728"></p><p>一个进程实体（进程映像）由<font color='#BAOC2F'>PCB、程序段、数据段组成</font>，进程实体反应了进程在某一时刻的状态。</p><p>进程是动态的，进程实体（进程映像）是静态的。进程是进程实体的<font color='#BAOC2F'>运行过程</font>，是系统进行<font color='#BAOC2F'>资源分配和调度</font>的一个独立单位。</p><blockquote><p>注：PCB是为操作系统而准备的，而程序段和数据段是给进程使用的，PCB是进程存在的唯一标志。</p></blockquote><h5 id="（3）进程的特征："><a href="#（3）进程的特征：" class="headerlink" title="（3）进程的特征："></a>（3）进程的特征：</h5><p>程序是静态的，进程是动态的，相比于程序<font color='#BAOC2F'>进程拥有以下特征</font>：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916100424456.png" alt="image-20220916100424456"></p><h4 id="2-进程的状态与转换"><a href="#2-进程的状态与转换" class="headerlink" title="2.进程的状态与转换"></a>2.进程的状态与转换</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916074422225.png" alt="image-20220916074422225"></p><h5 id="（1）进程的状态："><a href="#（1）进程的状态：" class="headerlink" title="（1）进程的状态："></a>（1）进程的状态：</h5><p>&#x3D;&#x3D;创建态&#x3D;&#x3D;：</p><p>进程<font color='#BAOC2F'>正在被创建时</font>其状态为创建态，在该阶段操作系统会为<font color='#BAOC2F'>进程分配资源、初始化PCB</font>。</p><p>&#x3D;&#x3D;就绪态&#x3D;&#x3D;：</p><p>当进程创建完成后便进入就绪态，处于就绪态的进程已经具备运行条件，但是由于<font color='#BAOC2F'>没有空闲的CPU</font>暂时不能运行。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916100330745.png" alt="image-20220916100330745"></p><p>&#x3D;&#x3D;运行态&#x3D;&#x3D;：</p><p>如果一个进程此时在CPU上运行就处于运行态，CPU会执行<font color='#BAOC2F'>该进程对应的程序</font>（执行指令序列）。</p><p>&#x3D;&#x3D;阻塞态&#x3D;&#x3D;：</p><p>在进程运行的过程中，可能会请求<font color='#BAOC2F'>等待某个事件的发生</font>。（如等待某种系统资源的分配、等待其他进程的响应等）</p><p>在等待过程中进程无法继续往下执行，OS会将进程下CPU，使其进入阻塞状态。</p><p>&#x3D;&#x3D;终止态&#x3D;&#x3D;：</p><p>一个进程可以执行<code>exit</code>系统调用，请求操作系统<font color='#BAOC2F'>终止该进程</font>。</p><p>此时该进程会进入终止态，操作系统会让该进程下CPU并<font color='#BAOC2F'>回收内存空间</font>等资源包括进程的PCB。</p><h5 id="（2）进程状态的转换："><a href="#（2）进程状态的转换：" class="headerlink" title="（2）进程状态的转换："></a>（2）进程状态的转换：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916073432909.png" alt="image-20220916073432909"></p><ol><li>运行态转换到阻塞态是一种<font color='#BAOC2F'>进程自身做出的主动行为</font>。</li><li>阻塞态转换到就绪态不是进程自身能控制的（CPU决定），是<font color='#BAOC2F'>进程的一种被动行为</font>。</li><li>不能直接由<font color='#BAOC2F'>阻塞态转换为运行态</font>，也不能直接由<font color='#BAOC2F'>就绪态转换为阻塞态</font>（阻塞态是进程主动请求的，而只有在运行态的进程才能发）</li><li>有时进程能够直接从运行态转换为就绪态，例如：时间片用尽、处理机被抢占等情况。</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916073550858.png" alt="image-20220916073550858"></p><p>在进程PCB中会有一个state变量来表示进程的当前状态，如创建态1、就绪态2、运行态3、阻塞态4、终止态5。</p><p>操作系统会将<font color='#BAOC2F'>各个进程的PCB组织起来</font>，实现对<font color='#BAOC2F'>相同状态的各个进程</font>进行管理。</p><h5 id="（3）进程的组织"><a href="#（3）进程的组织" class="headerlink" title="（3）进程的组织"></a>（3）进程的组织</h5><p>&#x3D;&#x3D;链接方式（队列）&#x3D;&#x3D;：</p><p>操作系统会<font color='#BAOC2F'>管理一系列的队列</font>，每个队列都会指向相应状态下的PCB：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916074147552.png" alt="image-20220916074147552"></p><p>&#x3D;&#x3D;索引方式（索引表）&#x3D;&#x3D;：</p><p>操作系统会给各种状态的进程建立<font color='#BAOC2F'>相应的索引表</font>，每个索引表的<font color='#BAOC2F'>表项会指向相应的PCB</font>：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916074217829.png" alt="image-20220916074217829"></p><h4 id="3-进程控制"><a href="#3-进程控制" class="headerlink" title="3.进程控制"></a>3.进程控制</h4><h5 id="（1）进程控制实现："><a href="#（1）进程控制实现：" class="headerlink" title="（1）进程控制实现："></a>（1）进程控制实现：</h5><p>进程控制的主要功能是对系统中的<font color='#BAOC2F'>所有进程实施有效的管理</font>，具有<font color='#BAOC2F'>创建新进程</font>、<font color='#BAOC2F'>撤销已有进程</font>、实现<font color='#BAOC2F'>进程状态转换</font>等功能。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916074939736.png" alt="image-20220916074939736"></p><p>进程控制通过<font color='#BAOC2F'>原语</font>来实现。</p><p>而原语是一种特殊的程序，其<font color='#BAOC2F'>执行具有原子性</font>。即该程序的执行（进程状态转换）必须<font color='#BAOC2F'>一次完成，不可被中断</font>。</p><p>如果原语的执行（进程的状态转换）不能一次完成，就可能导致OS中某些<font color='#BAOC2F'>关键数据结构信息不统一</font>影响管理工作。</p><p>可以使用<font color='#BAOC2F'>关中断指令</font>和<font color='#BAOC2F'>开中断指令</font>这连个特权指令，来实现原语的原子性。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916080919676.png" alt="image-20220916080919676"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916081129097.png" alt="image-20220916081129097"></p><h5 id="（2）进程控制相关原语："><a href="#（2）进程控制相关原语：" class="headerlink" title="（2）进程控制相关原语："></a>（2）进程控制相关原语：</h5><p>&#x3D;&#x3D;创建原语&#x3D;&#x3D;：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916081413848.png" alt="image-20220916081413848"></p><p>&#x3D;&#x3D;撤销原语&#x3D;&#x3D;：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916081634713.png" alt="image-20220916081634713"></p><p>&#x3D;&#x3D;阻塞与唤醒原语&#x3D;&#x3D;：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916081839206.png" alt="image-20220916081839206"></p><p>&#x3D;&#x3D;切换原语&#x3D;&#x3D;：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916082003113.png" alt="image-20220916082003113"></p><h4 id="4-进程通信"><a href="#4-进程通信" class="headerlink" title="4.进程通信"></a>4.进程通信</h4><p>进程是分配系统资源的单位（包括内存地址），因此<font color='#BAOC2F'>各进程拥有的内存地址空间相互独立</font>。</p><p>为了保证进程安全，1个进程<font color='#BAOC2F'>不能直接访问</font>另1个进程的地址空间，为了保证进程通信间的安全性，操作系统提供了一些方法。</p><h5 id="（1）共享存储"><a href="#（1）共享存储" class="headerlink" title="（1）共享存储"></a>（1）共享存储</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916085106365.png" alt="image-20220916085106365"></p><ol><li>共享存储中两个进程必须<font color='#BAOC2F'>对共享空间的访问互斥</font>（访问互斥通过操作系统提供的工具实现）</li><li>操作系统只负责提供共享空间与同步互斥工具（如P、V操作）</li></ol><p>&#x3D;&#x3D;基于数据结构的共享&#x3D;&#x3D;：</p><p>基于数据结构，共享空间里只能存放一个长度为10的数组。这种共享方式速度慢、限制多是一种低级的通信方式。</p><p>&#x3D;&#x3D;基于存储区的共享&#x3D;&#x3D;：</p><p>基于存储区，在内存中的共享存储区<font color='#BAOC2F'>数据的形式、存放的位置</font>都由<font color='#BAOC2F'>进程控制</font>而不是操作系统。共享速度更快是一种高级的通信方式。</p><h5 id="（2）消息传递"><a href="#（2）消息传递" class="headerlink" title="（2）消息传递"></a>（2）消息传递</h5><p>进程间的数据交换以<font color='#BAOC2F'>格式化的消息</font>Message为单位，进程通过操作系统提供的<font color='#BAOC2F'>发送消息&#x2F;接收消息</font>两个<font color='#BAOC2F'>原语</font>进行数据交换。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916085244047.png" alt="image-20220916085244047"></p><p>&#x3D;&#x3D;直接通信方式&#x3D;&#x3D;：</p><p>直接通信方式，是指将格式化消息直接<font color='#BAOC2F'>挂到接收进程的消息缓冲队列</font>上，如图：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916085822629.png" alt="image-20220916085822629"></p><p>&#x3D;&#x3D;间接通信方式&#x3D;&#x3D;：</p><p>间接通信方式，是指需要先将格式化的消息发送到<font color='#BAOC2F'>中间实体</font>（信箱）中，因此也被称为信箱通信方式（电子邮件系统）。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916090102725.png" alt="image-20220916090102725"></p><h5 id="（3）管道通信"><a href="#（3）管道通信" class="headerlink" title="（3）管道通信"></a>（3）管道通信</h5><p>管道是指用于<font color='#BAOC2F'>连接读写进程的一个共享文件</font>（pipe文件），本质是在内存中开辟的<font color='#BAOC2F'>一个大小固定的缓冲区</font>。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916090752050.png" alt="image-20220916090752050"></p><ol><li>各个进程也需要<font color='#BAOC2F'>互斥的访问管道</font>（操作系统实现）。</li><li>管道只能采用半双工通信，<font color='#BAOC2F'>某一时间段内只能实现单向传输</font>。</li><li>数据以字节流的形式写入管道，当管道写满时，写进程的<code>write()</code>系统调用将被阻塞，等待读进程将数据全部取走。</li><li>数据以字节流的形式读出管道，当管道读空后，读进程的<code>read()</code>系统调用将被阻塞。</li><li>数据从管道中<font color='#BAOC2F'>一旦读出就会彻底消失</font>，即读进程最多只能有一个，否则可能会有读错数据的情况。</li></ol><h4 id="5-线程与多线程模型"><a href="#5-线程与多线程模型" class="headerlink" title="5.线程与多线程模型"></a>5.线程与多线程模型</h4><h5 id="（1）线程TCB"><a href="#（1）线程TCB" class="headerlink" title="（1）线程TCB"></a>（1）线程TCB</h5><p>传统的进程只能<font color='#BAOC2F'>串性地执行一系列程序</font>，为此引入了线程的概念来<font color='#BAOC2F'>增加并发度</font>。</p><p>传统的进程是<font color='#BAOC2F'>程序执行流</font>的最小单位，引入线程后<font color='#BAOC2F'>线程成了程序执行流的最小单位</font>，是一个<font color='#BAOC2F'>基本的CPU执行单元</font>。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916091646310.png" alt="image-20220916091646310"></p><p>&#x3D;&#x3D;线程引入带来的变化&#x3D;&#x3D;：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916092021217.png" alt="image-20220916092021217"></p><h5 id="（2）线程特点"><a href="#（2）线程特点" class="headerlink" title="（2）线程特点"></a>（2）线程特点</h5><p>&#x3D;&#x3D;线程基本属性&#x3D;&#x3D;：</p><ol><li>线程是处理机调度的单位</li><li>每一个线程都有线程ID、线程控制块（TCB）</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li>多CPU计算机中，各个线程可占用不同的CPU</li><li>同一进程的不同线程间共享进程资源，所以同一进程中的线程间<font color='#BAOC2F'>通信无需系统干预</font>。</li></ol><p>&#x3D;&#x3D;线程切换中的属性&#x3D;&#x3D;：</p><ol><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销很大</li></ol><h5 id="（3）线程实现方式"><a href="#（3）线程实现方式" class="headerlink" title="（3）线程实现方式"></a>（3）线程实现方式</h5><p>&#x3D;&#x3D;用户级线程&#x3D;&#x3D;：</p><p>ULT用户级线程User-Level Thread，早期的操作系统<font color='#BAOC2F'>只支持进程、不支持线程</font>，线程是由<font color='#BAOC2F'>线程库</font>实现的。</p><p>很多编程语言提供了强大的线程库，可以<font color='#BAOC2F'>实现线程的创建、销毁、调度等</font>功能。</p><ol><li>线程管理是由应用程序通过线程库来完成的，并不是操作系统</li><li>线程切换<font color='#BAOC2F'>不需要CPU从用户态转换为内核态</font>，线程切换是由线程库应用程序完成的，不需要操作系统干涉。</li><li>操作系统不会意识到用户级线程的存在。</li></ol><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1.线程切换在用户空间就能够完成，不需要切换到核心态。</td><td>1.某个用户级线程阻塞后，整个进程都会阻塞并发度不高。</td></tr><tr><td>2.线程管理的<font color='#BAOC2F'>系统开销小、效率高</font>。</td><td>2.多个线程<font color='#BAOC2F'>不可在多核处理机上并行运行</font>。</td></tr></tbody></table><p>&#x3D;&#x3D;内核级线程&#x3D;&#x3D;：</p><p>KLT内核级线程Kernel-Level Thread，内核支持的线程。</p><ol><li>线程管理是由操作系统完成</li><li>线程切换<font color='#BAOC2F'>需要CPU从用户态转换为内核态</font>，线程切换是由操作系统完成的。</li><li>操作系统意识到用内核线程的存在。</li></ol><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1.当一个线程被阻塞后，其他线程能继续并发能力强。</td><td>1.一个用户进程占用多个内核级线程，线程切换由操作系统完成。</td></tr><tr><td>2.多线程<font color='#BAOC2F'>可在多核处理机上并行执行</font>。</td><td>2.线程切换需要切换到核心态，因此线程管理的成本高、开销大。</td></tr></tbody></table><blockquote><p>注：操作系统只看得见内核级线程，因此<font color='#BAOC2F'>只有内核级线程才是处理机分配的单位</font>。</p></blockquote><h5 id="（4）多线程模型"><a href="#（4）多线程模型" class="headerlink" title="（4）多线程模型"></a>（4）多线程模型</h5><p>在支持内核级线程的操作系统中再引入线程库，实现用户级线程与内核级线程结合使用。</p><h6 id="lt-1-gt-nv1模型（内核级线程）"><a href="#lt-1-gt-nv1模型（内核级线程）" class="headerlink" title="&lt;1&gt;nv1模型（内核级线程）"></a>&lt;1&gt;nv1模型（内核级线程）</h6><p>一个用户级线程映射到一个内核级线程，<font color='#BAOC2F'>每个用户进程</font>与<font color='#BAOC2F'>用户级线程</font>同等数量的内核级线程。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916095036118.png" alt="image-20220916095036118"></p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1.当一个线程被阻塞后，其他线程能够继续并发能力强。</td><td>1.用户进程会占用多个内核级线程，线程切换由操作系统内核完成</td></tr><tr><td>2.多线程可在多核处理机上并行执行。</td><td>2.线程切换需要切换到核心态，因此线程管理的成本高、开销大。</td></tr></tbody></table><h6 id="lt-2-gt-1v1模型（用户级线程）"><a href="#lt-2-gt-1v1模型（用户级线程）" class="headerlink" title="&lt;2&gt;1v1模型（用户级线程）"></a>&lt;2&gt;1v1模型（用户级线程）</h6><p>多个用户级线程映射到一个内核级线程，且<font color='#BAOC2F'>1个进程</font>只被分配<font color='#BAOC2F'>1个内核级线程</font>。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916095249937.png" alt="image-20220916095249937"></p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>1.线程切换在用户空间即可完成，不需要切换到核心态。</td><td>1.某个用户级线程阻塞后，整个进程都会阻塞，并发度不高。</td></tr><tr><td>2.线程管理的<font color='#BAOC2F'>系统开销小、效率高</font>。</td><td>2.多个线程<font color='#BAOC2F'>不可在多核处理机上并行运行</font>。</td></tr></tbody></table><h6 id="lt-3-gt-nvn模型"><a href="#lt-3-gt-nvn模型" class="headerlink" title="&lt;3&gt;nvn模型"></a>&lt;3&gt;nvn模型</h6><p>多对多模型：n个用户及线程映射到m个内核级线程（n&gt;&#x3D;m），每个用户进程对应m个内核级线程。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220916095504820.png" alt="image-20220916095504820"></p><ol><li>克服了nv1模型并<font color='#BAOC2F'>发度不高的缺点</font>。</li><li>克服了1v1模型中<font color='#BAOC2F'>1个用户进程占用太多内核级线程</font>，导致开销太大。</li></ol><h3 id="二、处理机调度"><a href="#二、处理机调度" class="headerlink" title="二、处理机调度"></a>二、处理机调度</h3><h4 id="1-处理机调度"><a href="#1-处理机调度" class="headerlink" title="1.处理机调度"></a>1.处理机调度</h4><p>当有一堆任务需要处理时，由于资源有限无法全部同时处理。这时需要某种规则来决定处理这些任务的顺序，这就是调度的问题。</p><h5 id="（1）处理机调度层次"><a href="#（1）处理机调度层次" class="headerlink" title="（1）处理机调度层次"></a>（1）处理机调度层次</h5><p>&#x3D;&#x3D;高级调度：作业调度&#x3D;&#x3D;</p><ol><li>按照一定的原则从外存的作业后备队列中<font color='#BAOC2F'>挑选一个作业调入内存，并创建进程</font>。</li><li>每个作业只调入一次、调出一次，作业调入时会建立PCB，调出时才撤销PCB。</li></ol><blockquote><p>作业：是指一项具体的任务。用户向系统提交一个作业：用户让操作系统启动一个程序（处理一个具体的任务）。</p></blockquote><p>&#x3D;&#x3D;中级调度：内存调度&#x3D;&#x3D;</p><ol><li>内存不够时将某些进程的数据调出外存，等内存空闲或者进程需要运行时再重新调入内存。</li><li>暂时调到外存等待的进程状态称为<font color='#BAOC2F'>挂起状态</font>，被挂起的进程PCB会被组织成<font color='#BAOC2F'>挂起队列</font>。</li><li>按照某种策略决定<font color='#BAOC2F'>将哪个处于挂起状态的进程重新调入内存</font>。</li></ol><blockquote><p>注：单个进程可能会被多次调入、调出内存，因此中级调度发生的频率比高级调度更高。</p></blockquote><p>&#x3D;&#x3D;低级调度：进程调度&#x2F;处理机调度&#x3D;&#x3D;</p><ol><li>按照某种策略从<font color='#BAOC2F'>就绪队列</font>中选取一个进程，将处理机分配给该进程。</li><li>进程调度是操作系统中最<font color='#BAOC2F'>基本的一种调度</font>，在一般的操作系统中都必须配置进程调度。</li><li>进程调度的频率很高，一般几十毫秒一次。</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917093017354.png" alt="image-20220917093017354"></p><h5 id="（2）进程七状态模型："><a href="#（2）进程七状态模型：" class="headerlink" title="（2）进程七状态模型："></a>（2）进程七状态模型：</h5><p>暂时调回外存等待的进程状态称为<font color='#BAOC2F'>挂起状态</font>（挂起态，suspend）</p><p>将挂起状态进一步细分可分为<font color='#BAOC2F'>就绪挂起</font>、<font color='#BAOC2F'>阻塞挂起</font>两种状态，则将五模型进一步补充为七模型：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917092854144.png" alt="image-20220917092854144"></p><ol><li>挂起和阻塞的区别：两种状态都是暂时不能获取CPU的服务，但<font color='#BAOC2F'>挂起态</font>是将<font color='#BAOC2F'>进程映射到外存中</font>，而阻塞态下<font color='#BAOC2F'>进程映像还在内存中</font>。</li><li>有的操作系统会把就绪挂起、阻塞挂起分为两个队列，甚至会根据阻塞的原因再<font color='#BAOC2F'>将阻塞挂起进程</font>进一步<font color='#BAOC2F'>细分为多个队列</font>。</li></ol><h4 id="2-进程调度（低级调度）"><a href="#2-进程调度（低级调度）" class="headerlink" title="2.进程调度（低级调度）"></a>2.进程调度（低级调度）</h4><p>进程调度，就是按照某种算法<font color='#BAOC2F'>从就绪队列中选择一个进程为其分配处理机</font>。</p><h5 id="（1）调度时机："><a href="#（1）调度时机：" class="headerlink" title="（1）调度时机："></a>（1）调度时机：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917095141522.png" alt="image-20220917095141522"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917095157457.png" alt="image-20220917095157457"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917100933519.png" alt="image-20220917100933519"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917100141638.png" alt="image-20220917100141638"></p><h5 id="（2）调度方式："><a href="#（2）调度方式：" class="headerlink" title="（2）调度方式："></a>（2）调度方式：</h5><p>&#x3D;&#x3D;抢占式调度方式&#x3D;&#x3D;：</p><p>抢占式调度方式，又称为剥夺调度方式。</p><p>当一个进程正在处理机上执行时，如果有一个更重要 or 更紧迫的进程需要使用处理机，则<font color='#BAOC2F'>立即暂停正在执行的进程</font>，将处理机分配给更重要紧迫的那个进程。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917101147332.png" alt="image-20220917101147332"></p><p>&#x3D;&#x3D;非抢占式调度方式&#x3D;&#x3D;：</p><p>非抢占式调度方式，又称为非剥夺调度方式。</p><p>只允许进程主动放弃处理机，在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止 or 主动要求进入阻塞状态。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917101122437.png" alt="image-20220917101122437"></p><h5 id="（3）进程切换的过程"><a href="#（3）进程切换的过程" class="headerlink" title="（3）进程切换的过程"></a>（3）进程切换的过程</h5><p>进程切换的过程完成的任务：</p><ol><li>对原来运行的<font color='#BAOC2F'>进程各种数据的保存</font>。</li><li>对新的进程<font color='#BAOC2F'>各种数据的恢复</font>。</li></ol><blockquote><p>注：进程切换是有代价的，因此如果过于频繁的进行进程调度&amp;切换，必然会使整个系统的效率降低。</p></blockquote><h4 id="3-调度算法评价指标"><a href="#3-调度算法评价指标" class="headerlink" title="3.调度算法评价指标"></a>3.调度算法评价指标</h4><ol><li><p>CPU利用率：指的是CPU忙碌的时间占总时间的比例（通常考查<font color='#BAOC2F'>多道程序并发执行</font>的情况）</p></li><li><p>系统吞吐量：单位时间内<font color='#BAOC2F'>完成作业的数量</font>，</p></li><li><p>周转时间：指从作业被<font color='#BAOC2F'>提交给系统开始</font>到<font color='#BAOC2F'>作业完成</font>为止，这段时间的间隔</p><p> 包括作业在外存后备队列上等待作业调度（高级调度）的时间、</p><p> 进程在就绪队列上等待进程调度（低级调度）的时间、</p><p> 进程在CPU上执行的时间、</p><p> 进程等待IO操作完成的时间</p><p> <img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917104940800.png" alt="image-20220917104940800"></p></li><li><p>等待时间：指进程 or 作业处于等待处理机状态的时间之和，等待时间越长用户满意度越低。</p></li><li><p>响应时间：指从用户提交请求到首次产生响应所用的时间。</p></li></ol><h4 id="4-批处理系统调度"><a href="#4-批处理系统调度" class="headerlink" title="4.批处理系统调度"></a>4.批处理系统调度</h4><h5 id="（1）FCFS"><a href="#（1）FCFS" class="headerlink" title="（1）FCFS"></a>（1）FCFS</h5><p>FCFS,First Come First Serve先来先服务算法</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917110626849.png" alt="image-20220917110626849"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917110350472.png" alt="image-20220917110350472"></p><h5 id="（2）SJF-amp-SRTN"><a href="#（2）SJF-amp-SRTN" class="headerlink" title="（2）SJF&amp;SRTN"></a>（2）SJF&amp;SRTN</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917112546272.png" alt="image-20220917112546272"></p><p>SJF,Shortest Job First短作业优先算法（非抢占式）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917111222813.png" alt="image-20220917111222813"></p><p>SRTN,Shortest Remaining Time Next最短剩余时间优先算法（抢占式）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917112357332.png" alt="image-20220917112357332"></p><h5 id="（3）HRRN"><a href="#（3）HRRN" class="headerlink" title="（3）HRRN"></a>（3）HRRN</h5><p>HRRN,Hightest Response Ratio Next高响应比优先算法</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917113217986.png" alt="image-20220917113217986"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917113045081.png" alt="image-20220917113045081"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220917113237735.png" alt="image-20220917113237735"></p><p>批处理系统的调度算法主要关心对用户的公平性、平均周转时间、平均等待时间等<font color='#BAOC2F'>评价系统整体性能</font>的指标，</p><p>不关心响应时间、不区分任务的紧急程度，因此对于用户来说交互性十分的糟糕（早期的批处理系统）。</p><h4 id="5-交互式系统调度"><a href="#5-交互式系统调度" class="headerlink" title="5.交互式系统调度"></a>5.交互式系统调度</h4><h5 id="（1）RR"><a href="#（1）RR" class="headerlink" title="（1）RR"></a>（1）RR</h5><p>RR,Round-Robin时间片轮转</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918082635909.png" alt="image-20220918082635909"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918082600767.png" alt="image-20220918082600767"></p><h5 id="（2）优先级"><a href="#（2）优先级" class="headerlink" title="（2）优先级"></a>（2）优先级</h5><p>优先级调度算法：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918113953333.png" alt="image-20220918113953333"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918113740885.png" alt="image-20220918113740885"></p><h5 id="（3）多级反馈队列"><a href="#（3）多级反馈队列" class="headerlink" title="（3）多级反馈队列"></a>（3）多级反馈队列</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918130010192.png" alt="image-20220918130010192"></p><ol><li><p>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</p></li><li><p>新进程到达时先进入第1级队列，按照FCFS原则排队等待被分配时间片。</p><p> 若用完时间片进程还未结束，则进程进入下一级队列队尾。</p><p> 如果此时已经在最下级的队列，则重新放回最下级队列队尾。</p></li><li><p>只有第k级队列为空时，才会为k+1级队头的进程分配时间片。</p></li><li><p>被抢占处理机的进程重新放回原队列的队尾，<a href="https://www.bilibili.com/video/BV1Ne4y1k7gD">详细讲解</a>。</p></li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918130049086.png" alt="image-20220918130049086"></p><h3 id="三、进程同步与互斥"><a href="#三、进程同步与互斥" class="headerlink" title="三、进程同步与互斥"></a>三、进程同步与互斥</h3><h4 id="1-进程同步与互斥："><a href="#1-进程同步与互斥：" class="headerlink" title="1.进程同步与互斥："></a>1.进程同步与互斥：</h4><h5 id="（1）进程同步："><a href="#（1）进程同步：" class="headerlink" title="（1）进程同步："></a>（1）进程同步：</h5><ul><li>进程异步：指的是各并发执行的进程以各自独立的、不可预知的速度向前推进。</li><li>进程同步：亦称直接制约关系，为完成某种任务而建立的两个或多个进程，在某些位置上<font color='#BAOC2F'>协调它们的工作次序</font>而产生的制约关系。</li></ul><h5 id="（2）进程互斥："><a href="#（2）进程互斥：" class="headerlink" title="（2）进程互斥："></a>（2）进程互斥：</h5><p>时间段内<font color='#BAOC2F'>只允许一个进程使用</font>的资源称为<font color='#BAOC2F'>临界资源</font>，进程互斥是指当一个进程访问临界资源时，另一个进程必须等待其结束。</p><p>&#x3D;&#x3D;临界资源的访问逻辑&#x3D;&#x3D;：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918171406334.png" alt="image-20220918171406334"></p><ul><li><p>临界区是进程中访问临界资源的代码段</p></li><li><p>进入区和退出区是负责实现互斥的代码段</p></li></ul><p>&#x3D;&#x3D;进程互斥遵循的4个原则&#x3D;&#x3D;：</p><ol><li>空闲让进：临界区空闲时，可以<font color='#BAOC2F'>允许一个请求进入临界区的进程立即进入临界区</font>。</li><li>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li><li>有限等待：对请求访问的进程，应保证能在有限的时间内进入临界区（保证不会饥饿）。</li><li>让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li></ol><h4 id="2-进程互斥软件实现"><a href="#2-进程互斥软件实现" class="headerlink" title="2.进程互斥软件实现"></a>2.进程互斥软件实现</h4><h5 id="（1）单标志法："><a href="#（1）单标志法：" class="headerlink" title="（1）单标志法："></a>（1）单标志法：</h5><p>算法思想：两个进程在<font color='#BAOC2F'>访问完邻接资源后</font>会把使用临界区的权限转交给另一个进程，每个进程进入临界区的权限只能被另一个进程赋予。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918194540815.png" alt="image-20220918194540815"></p><p>单标志法缺点：违反了<font color='#BAOC2F'>空闲让进</font>的原则。</p><h5 id="（2）双表示先检查"><a href="#（2）双表示先检查" class="headerlink" title="（2）双表示先检查"></a>（2）双表示先检查</h5><p>算法思想：</p><ol><li>设置一个布尔型数组<code>flag[]</code>，数组中的各个元素用来标记<font color='#BAOC2F'>各进程进入临界区的意愿</font>。flag[0]&#x3D;true;</li><li>每个进程在进入临界区之前，先检查当前是否有其他进程也想进入临界区</li><li>如果没有则把自身对应的标志<code>flag[i]</code>设置为true，之后开始访问临界区。</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918201619013.png" alt="image-20220918201619013"></p><p>双标志先检查法的缺点：在进程并发时有可能导致临界资源的多进程访问，违反了<font color='#BAOC2F'>忙则等待原则</font>。</p><h5 id="（3）双标志后检查"><a href="#（3）双标志后检查" class="headerlink" title="（3）双标志后检查"></a>（3）双标志后检查</h5><p>算法思想：</p><ol><li>设置一个布尔型数组<code>flag[]</code>，数组中的各个元素用来标记<font color='#BAOC2F'>各进程进入临界区的意愿</font>。flag[0]&#x3D;true;</li><li>每个进程在进入临界区之前，先把自身对应的标志<code>flag[i]</code>设置为true</li><li>在检查当前是没有其他进程也想进入临界区，之后开始访问临界区。</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918202256455.png" alt="image-20220918202256455"></p><p>双标志后检查法的缺点：在进程并发时有可能导致各进程都长期无法访问临界资源的饥饿现象，违反了<font color='#BAOC2F'>空闲让进</font>与<font color='#BAOC2F'>有限等待</font>原则。</p><h5 id="（4）Peterson算法"><a href="#（4）Peterson算法" class="headerlink" title="（4）Peterson算法"></a>（4）Peterson算法</h5><p>Peterson算法结合了双标志与单标志的思想，如果双方都想进入临界区，则可以让某个进程进行谦让。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918202859670.png" alt="image-20220918202859670"></p><p>Peterson算法利用软件方法解决了进程互斥问题，遵循了空闲让进、忙着等待、有限等待原则，但是仍然未遵循<font color='#BAOC2F'>让权等待原则</font>。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918203955219.png" alt="image-20220918203955219"></p><h4 id="3-进程互斥硬件实现"><a href="#3-进程互斥硬件实现" class="headerlink" title="3.进程互斥硬件实现"></a>3.进程互斥硬件实现</h4><h5 id="（1）中断屏蔽算法"><a href="#（1）中断屏蔽算法" class="headerlink" title="（1）中断屏蔽算法"></a>（1）中断屏蔽算法</h5><p>中断屏蔽算法是利用开&#x2F;关中断指令实现，与原语的实现思想相同，在某进程开始开始访问临界资源到结束都不允许被中断。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918214512298.png" alt="image-20220918214512298"></p><ul><li>优点：简单、高效</li><li>缺点：不适用于多处理机，且只适用于操作系统的内核进程，不适用于用户进程（随意使用危险）。</li></ul><h5 id="（2）TestAndSet（TS-x2F-TSL）"><a href="#（2）TestAndSet（TS-x2F-TSL）" class="headerlink" title="（2）TestAndSet（TS&#x2F;TSL）"></a>（2）TestAndSet（TS&#x2F;TSL）</h5><p>TSL指令是利用硬件实现的，执行过程不允许被中断。</p><p>TSL指令将上锁与检查操作，用硬件的方式变成了一气呵成的原子操作。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918214830783.png" alt="image-20220918214830783"></p><ul><li>优点：实现简单，无序像软件实现方式一样检查是否会有逻辑漏洞，且适用于多处理机环境。</li><li>缺点：不满足让权等待原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致忙等。</li></ul><h5 id="（3）Swap指令（XCHG）"><a href="#（3）Swap指令（XCHG）" class="headerlink" title="（3）Swap指令（XCHG）"></a>（3）Swap指令（XCHG）</h5><p>Swap&#x2F;XCHG指令利用硬件实现执行的过程不允许被中断，只能一气呵成。</p><p>逻辑上看Swap与TSL并无太大区别，</p><ol><li>都是先记录下此时临界区是否已经被上锁，再将上锁标记lock设置为true，最后检查old</li><li>如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环、进入临界区</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918215512576.png" alt="image-20220918215512576"></p><ul><li>优点：实现简单，无序像软件实现方式一样检查是否会有逻辑漏洞，且适用于多处理机环境。</li><li>缺点：不满足让权等待原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致忙等。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918215932988.png" alt="image-20220918215932988"></p><h4 id="4-Semaphore信号量机制"><a href="#4-Semaphore信号量机制" class="headerlink" title="4.Semaphore信号量机制"></a>4.Semaphore信号量机制</h4><p>用户进程可以通过使用操作系统<font color='#BAOC2F'>提供的一对原语</font>来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918224232308.png" alt="image-20220918224232308"></p><h5 id="（1）整型信号量"><a href="#（1）整型信号量" class="headerlink" title="（1）整型信号量"></a>（1）整型信号量</h5><p>用一个整数型变量作为信号量，用来表示系统中某种资源的数量。对信号量的操作只有三种：初始化、P操作、V操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> S = <span class="number">1</span>; <span class="comment">//初始化整型信号量S，表示当前系统中可用资源（打印机）的数量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> S)</span> </span>&#123; <span class="comment">//wait原语相当于进入区</span></span><br><span class="line">    <span class="keyword">while</span> (S &lt;= <span class="number">0</span>);<span class="comment">//如果资源不够则一直循环等待</span></span><br><span class="line">    S = S - <span class="number">1</span>;<span class="comment">//如果资源足够就占用一个资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">(<span class="type">int</span> S)</span> </span>&#123; <span class="comment">//signal原语相当于退出区</span></span><br><span class="line">    S = S + <span class="number">1</span>;<span class="comment">//使用完资源后，在退出区释放资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220918225144271.png" alt="image-20220918225144271"></p><ul><li>缺点：不满足让权等待原则，会发生忙等的情况。</li></ul><h5 id="（2）记录型信号量"><a href="#（2）记录型信号量" class="headerlink" title="（2）记录型信号量"></a>（2）记录型信号量</h5><p>整型信号量有一个很大的缺陷：</p><p>如果一个进程暂时无法进入临界区（资源不够），该进程会一直占用处理机循环检查导致忙等，可以采用记录型信号量解决。</p><p>记录型信号量即用<font color='#BAOC2F'>记录型数据结构</font>表示信号量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*记录型信号量定义*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;<span class="comment">//剩余资源数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">process</span> *L;<span class="comment">//等待队列</span></span><br><span class="line">&#125; semaphore;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(semaphore S)</span> </span>&#123;</span><br><span class="line">    S.value--;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">block</span>(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">signal</span><span class="params">(semaphore S)</span> </span>&#123;</span><br><span class="line">    s.value++;</span><br><span class="line">    <span class="keyword">if</span> (S.value &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">wakeup</span>(S.L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220920102159901.png" alt="image-20220920102159901"></p><h5 id="（3）Semaphore实现进程互斥-amp-同步★"><a href="#（3）Semaphore实现进程互斥-amp-同步★" class="headerlink" title="（3）Semaphore实现进程互斥&amp;同步★"></a>（3）Semaphore实现进程互斥&amp;同步★</h5><p>进程互斥的软件与硬件实现都没有解决让权等待的问题，用信号量机制中的阻塞与唤醒机制可以解决：</p><p>&#x3D;&#x3D;信号量机制实现进程互斥&#x3D;&#x3D;：</p><ol><li>分析并发进程的关键活动，划定临界区（如对临界资源打印机的访问）</li><li>设置互斥信号量mutex，并初始化为1</li><li>在进入区P(mutex)申请资源</li><li>在退出去V(mutex)释放资源</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*信号量机制实现互斥*/</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">P1</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">P</span>(mutex);<span class="comment">//使用临界资源前需要加锁</span></span><br><span class="line">    临界区代码段...</span><br><span class="line">    <span class="built_in">V</span>(mutex);<span class="comment">//使用临界资源后需要解锁</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P2</span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    临界区代码段...</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;信号量机制实现进程同步（难点）&#x3D;&#x3D;：</p><p>进程同步：是指要让各个并发的进程按照要求有序的推进。</p><ol><li>分析何处需要实现进程的同步关系（保证前后顺序）</li><li>设置同步信号量S，并初始化为0</li><li>在前操作之后执行<code>V(S)</code></li><li>在后操作之前执行<code>P(S)</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*信号量机制实现同步*/</span></span><br><span class="line">semaphore S = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">P1</span>() &#123;</span><br><span class="line">    代码<span class="number">1</span>;</span><br><span class="line">    代码<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">V</span>(S);<span class="comment">//释放资源</span></span><br><span class="line">    代码<span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">P2</span>() &#123;</span><br><span class="line">    <span class="built_in">P</span>(S);</span><br><span class="line">    代码<span class="number">4</span>;</span><br><span class="line">    代码<span class="number">5</span>;</span><br><span class="line">    代码<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）Semaphore实现前驱关系："><a href="#（4）Semaphore实现前驱关系：" class="headerlink" title="（4）Semaphore实现前驱关系："></a>（4）Semaphore实现前驱关系：</h5><p>要求代码按照如下前驱图所示的顺序来执行，每1对前驱关系都是1个进程同步问题（多级同步问题）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220920111520211.png" alt="image-20220920111520211"></p><h4 id="5-进程同步互斥经典问题★"><a href="#5-进程同步互斥经典问题★" class="headerlink" title="5.进程同步互斥经典问题★"></a>5.进程同步互斥经典问题★</h4><p>PV操作问题分析步骤：</p><ol><li>关系分析：找出问题中描述的各个进程，分析它们之间的同步or互斥关系。</li><li>整理思路：根据各个进程的操作流程确定PV操作的大致顺序。</li><li>设置信号量：根据题目条件确定信号量的初始值。（互斥信号量一般为1，同步信号量初始值根据对应资源的初值确定）</li></ol><h5 id="（1）生产者消费者（同步）"><a href="#（1）生产者消费者（同步）" class="headerlink" title="（1）生产者消费者（同步）"></a>（1）生产者消费者（同步）</h5><p>系统中有一组生产者进程和一组消费者进程，</p><p>生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。共享一个初始为空、大小为n的缓冲区。</p><ol><li>只有<font color='#BAOC2F'>缓冲区未满</font>时生产者才能将产品放入缓冲区中，否则必须等待。</li><li>只有<font color='#BAOC2F'>缓冲区不空</font>时消费者才能从缓冲区中取出产品，否则必须等待。</li><li>缓冲区是临界资源，各个进程必须互斥的访问。</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220920120440438.png" alt="image-20220920120440438"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*生产者消费者问题核心代码*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        produce a good;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">P</span>(empty);<span class="comment">//消耗一个空闲缓冲区</span></span><br><span class="line">        pull <span class="keyword">this</span> good into buffer;</span><br><span class="line">        <span class="built_in">V</span>(full);<span class="comment">//增加一个产品数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(full);<span class="comment">//申请消耗一个产品</span></span><br><span class="line">        take <span class="keyword">this</span> good out from buffer;</span><br><span class="line">        <span class="built_in">V</span>(empty);<span class="comment">//增加一个空闲缓冲区</span></span><br><span class="line">        </span><br><span class="line">        consume a good;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//互斥信号量</span></span><br><span class="line">semaphore empty = n;<span class="comment">//同步信号量</span></span><br><span class="line">semaphore full = <span class="number">0</span>;<span class="comment">//同步信号量</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        produce a good;</span><br><span class="line">        <span class="built_in">P</span>(empty);</span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        pull <span class="keyword">this</span> good into buffer;</span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="built_in">V</span>(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(full);</span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        take <span class="keyword">this</span> good out from buffer;</span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="built_in">V</span>(empty);</span><br><span class="line">        consume a good;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有的时候是生产者进程需要等待消费者进程，有的时候是消费者进程需要等待生产者进程，需要设置两对不同的信号量。</p><blockquote><p>注：实现互斥的P操作一定要在实现同步的P操作之后，否则会出现死锁的情况。</p></blockquote><h5 id="（2）多生成者多消费者nvn："><a href="#（2）多生成者多消费者nvn：" class="headerlink" title="（2）多生成者多消费者nvn："></a>（2）多生成者多消费者nvn：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220921074442934.png" alt="image-20220921074442934"></p><ol><li>父亲将苹果放入盘子后，女儿才能取出苹果</li><li>母亲将橘子放入盘子后，儿子才能取出橘子</li><li>只有盘子为空时，父亲与母亲才能放入水果</li><li>对缓冲区（盘子）的访问要互斥的进行</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220921075342777.png" alt="image-20220921075342777"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*多生产者多消费者问题核心代码*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare a apple;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">P</span>(plate);</span><br><span class="line">    put <span class="keyword">this</span> apple into the plate;</span><br><span class="line">    <span class="built_in">V</span>(apple);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mother</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare a orange;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">P</span>(plate);</span><br><span class="line">    put <span class="keyword">this</span> orange into the plate;</span><br><span class="line">    <span class="built_in">V</span>(orange);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">daughter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">P</span>(apple);</span><br><span class="line">    take <span class="keyword">this</span> orange from the plate;</span><br><span class="line">    <span class="built_in">V</span>(plate);</span><br><span class="line">    </span><br><span class="line">    eat <span class="keyword">this</span> apple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">P</span>(orange);</span><br><span class="line">    take <span class="keyword">this</span> apple from the plate;</span><br><span class="line">    <span class="built_in">V</span>(plate);</span><br><span class="line">    </span><br><span class="line">    eat <span class="keyword">this</span> orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//缓冲区互斥</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;<span class="comment">//盘子中苹果的数量</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;<span class="comment">//盘子中橘子的数量</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;<span class="comment">//盘子中还可以方多少个水果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare a apple;</span><br><span class="line">    <span class="built_in">P</span>(plate);</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    put <span class="keyword">this</span> apple into the plate;</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    <span class="built_in">V</span>(apple);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mother</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare a orange;</span><br><span class="line">    <span class="built_in">P</span>(plate);</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    put <span class="keyword">this</span> orange into the plate;</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    <span class="built_in">V</span>(orange);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">daughter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">P</span>(apple);</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    take <span class="keyword">this</span> orange from the plate;</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    <span class="built_in">V</span>(plate);</span><br><span class="line">    eat <span class="keyword">this</span> apple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">P</span>(orange);</span><br><span class="line">    <span class="built_in">P</span>(mutex);</span><br><span class="line">    take <span class="keyword">this</span> apple from the plate;</span><br><span class="line">    <span class="built_in">V</span>(mutex);</span><br><span class="line">    <span class="built_in">V</span>(plate);</span><br><span class="line">    eat <span class="keyword">this</span> orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可省去互斥mutex信号量的PV操作，</p><p>原因是缓冲区的大小为1，在任意时刻apple、orange、plate同步信号量中最多只有1个为1，在任意时刻最多只有一个进程的P操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//缓冲区互斥</span></span><br><span class="line">semaphore apple = <span class="number">0</span>;<span class="comment">//盘子中苹果的数量</span></span><br><span class="line">semaphore orange = <span class="number">0</span>;<span class="comment">//盘子中橘子的数量</span></span><br><span class="line">semaphore plate = <span class="number">1</span>;<span class="comment">//盘子中还可以方多少个水果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare a apple;</span><br><span class="line">    <span class="built_in">P</span>(plate);</span><br><span class="line">    put <span class="keyword">this</span> apple into the plate;</span><br><span class="line">    <span class="built_in">V</span>(apple);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mother</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare a orange;</span><br><span class="line">    <span class="built_in">P</span>(plate);</span><br><span class="line">    put <span class="keyword">this</span> orange into the plate;</span><br><span class="line">    <span class="built_in">V</span>(orange);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">daughter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">P</span>(apple);</span><br><span class="line">    take <span class="keyword">this</span> orange from the plate;</span><br><span class="line">    <span class="built_in">V</span>(plate);</span><br><span class="line">    eat <span class="keyword">this</span> apple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">P</span>(orange);</span><br><span class="line">    take <span class="keyword">this</span> apple from the plate;</span><br><span class="line">    <span class="built_in">V</span>(plate);</span><br><span class="line">    eat <span class="keyword">this</span> orange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）吸烟者问题1vn："><a href="#（3）吸烟者问题1vn：" class="headerlink" title="（3）吸烟者问题1vn："></a>（3）吸烟者问题1vn：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220921084050967.png" alt="image-20220921084050967"></p><ol><li>桌子上有组合1纸与胶水时，则第一个抽烟者取走材料</li><li>桌子上有组合2烟草与胶水时，则第二个抽烟者取走材料</li><li>桌子上有组合3烟草与纸时，则第三个抽烟者取走材料</li><li>当抽烟者发出完成抽烟信号，供应者将下一个组合放到桌子上</li><li>对缓冲区（桌子）的访问要互斥的进行</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220921084659571.png" alt="image-20220921084659571"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">semaphore offer1 = <span class="number">0</span>;</span><br><span class="line">semaphore offer2 = <span class="number">0</span>;</span><br><span class="line">semaphore offer3 = <span class="number">0</span>;</span><br><span class="line">semaphore finish = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;<span class="comment">//用于实现抽烟者轮流抽烟</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            Put combination <span class="number">1</span> into the buffer;</span><br><span class="line">            <span class="built_in">V</span>(offer1);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">            Put combination <span class="number">2</span> into the buffer;</span><br><span class="line">            <span class="built_in">V</span>(offer2);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">            Put combination <span class="number">3</span> into the buffer;</span><br><span class="line">            <span class="built_in">V</span>(offer3);</span><br><span class="line">        &#125;</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">P</span>(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">smoker1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(offer1);</span><br><span class="line">        take combination1 from the buffer;</span><br><span class="line">        <span class="built_in">V</span>(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">smoker2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(offer1);</span><br><span class="line">        take combination1 from the buffer;</span><br><span class="line">        <span class="built_in">V</span>(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">smoker3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(offer1);</span><br><span class="line">        take combination1 from the buffer;</span><br><span class="line">        <span class="built_in">V</span>(finish);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）读者写者问题（互斥）"><a href="#（4）读者写者问题（互斥）" class="headerlink" title="（4）读者写者问题（互斥）"></a>（4）读者写者问题（互斥）</h5><p>有读者写者两组并发进程共享一个文件，</p><p>当两个或两个以上的读进程同时访问共享数据时，不会产生副作用。</p><p>但若某个写进程和其他进程（读进程or写进程）同时访问共享数据时，则可能导致数据不一致的错误。因此要求：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>允许多个读者可以同时对文件执行读操作</span><br><span class="line"><span class="number">2.</span>只允许一个写者往文件中写信息</span><br><span class="line"><span class="number">3.</span>任一写者在完成写操作之前不允许其他读者或写者工作</span><br><span class="line"><span class="number">4.</span>写者执行写操作之前，应该让已有的读者和写者全部都退出</span><br></pre></td></tr></table></figure><ul><li><p>两类进程：写进程、读进程</p></li><li><p>互斥关系：写进程-写进程、写进程-读进程、读进程与读进程之前不存在互斥关系</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.读者写者互斥访问文件*/</span></span><br><span class="line">semaphore rw = <span class="number">1</span>;<span class="comment">//用于实现对共享文件的互斥访问</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(rw);<span class="comment">//写文件前加锁</span></span><br><span class="line">        write data to the file;</span><br><span class="line">        <span class="built_in">V</span>(rw);<span class="comment">//写文件后解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(rw);</span><br><span class="line">        read data from the file;</span><br><span class="line">        <span class="built_in">V</span>(rw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*读写与读写之间不可同时访问文件*/</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.读者写者互斥访问文件*/</span></span><br><span class="line"><span class="comment">/*2.修改读者与读者之间可同时访问文件*/</span></span><br><span class="line">semaphore rw = <span class="number">1</span>;</span><br><span class="line">count = <span class="number">0</span>;<span class="comment">//用于记录当前有几个读进程在访问文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(rw);<span class="comment">//写文件前加锁</span></span><br><span class="line">        write data to the file;</span><br><span class="line">        <span class="built_in">V</span>(rw);<span class="comment">//写文件后解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="built_in">P</span>(rw);</span><br><span class="line">        count++;</span><br><span class="line">        read data from the file;</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="built_in">V</span>(rw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果两个读进程并发执行，则count==0时两个进程也许能同时通过if语句，从而都会执行P(rw)导致第二个读进程阻塞*/</span></span><br><span class="line"><span class="comment">/*问题源头：count变量的检查与赋值无法一气呵成，中间有可能有并发进程插入*/</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.读者写者互斥访问文件*/</span></span><br><span class="line"><span class="comment">/*2.修改读者与读者之间可同时访问文件*/</span></span><br><span class="line"><span class="comment">/*3.设置互斥信号量mutext用于保证对count的互斥访问*/</span></span><br><span class="line">semaphore rw = <span class="number">1</span>;<span class="comment">//用于实现对共享文件的互斥访问</span></span><br><span class="line">count = <span class="number">0</span>;<span class="comment">//用于记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//新增mutex互斥信号量，用于保证对count的互斥访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(rw);<span class="comment">//写文件前加锁</span></span><br><span class="line">        write data to the file;</span><br><span class="line">        <span class="built_in">V</span>(rw);<span class="comment">//写文件后解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="built_in">P</span>(rw);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        read data from the file;</span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="built_in">V</span>(rw);</span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*只要有读进程还在继续，写进程就需要一直阻塞可能饿死*/</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.读者写者互斥访问文件*/</span></span><br><span class="line"><span class="comment">/*2.修改读者与读者之间可同时访问文件*/</span></span><br><span class="line"><span class="comment">/*3.设置互斥信号量mutext用于保证对count的互斥访问,解决第二个读进程阻塞的问题*/</span></span><br><span class="line"><span class="comment">/*4.设置互斥信号量w用于实现写进程优先,解决写进程饥饿的问题*/</span></span><br><span class="line">semaphore rw = <span class="number">1</span>;<span class="comment">//用于实现对共享文件的互斥访问</span></span><br><span class="line">count = <span class="number">0</span>;<span class="comment">//用于记录当前有几个读进程在访问文件</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//用于保证对count的互斥访问</span></span><br><span class="line">semaphore w = <span class="number">1</span>;<span class="comment">//用于实现写优先</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(w);</span><br><span class="line">        <span class="built_in">P</span>(rw);<span class="comment">//写文件前加锁</span></span><br><span class="line">        write data to the file;</span><br><span class="line">        <span class="built_in">V</span>(rw);<span class="comment">//写文件后解锁</span></span><br><span class="line">        <span class="built_in">V</span>(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">P</span>(w);</span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="built_in">P</span>(rw);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">        <span class="built_in">V</span>(w);</span><br><span class="line">        read data from the file;</span><br><span class="line">        <span class="built_in">P</span>(mutex);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="built_in">V</span>(rw);</span><br><span class="line">        <span class="built_in">V</span>(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;读者与写者问题的核心思想在于&#x3D;&#x3D;：</p><ol><li>设置一个计数器count用来记录当前正在访问共享文件的读进程数量，</li><li>用count的值来判断当前进入的进程是否是最后一个读进程，从而做出不同的处理方式。</li><li>另外对于count变量的检查与赋值一气呵成的实现方法，自然也应该想到使用互斥信号量。</li></ol><h5 id="（5）哲学家进餐问题："><a href="#（5）哲学家进餐问题：" class="headerlink" title="（5）哲学家进餐问题："></a>（5）哲学家进餐问题：</h5><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆着一根筷子，桌子的中间是一碗米饭。</p><p>哲学家在思考时并不影响其他人，只有当哲学家饥饿时才会试图拿起左右两侧的筷子，如果筷子已在其他人的手上则需要等待。</p><p>饥饿的哲学家只有同时拿起两根筷子时才能开始进餐，进餐完毕后继续思考。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220921120321666.png" alt="image-20220921120321666"></p><p>哲学家进餐问题中<font color='#BAOC2F'>只有互斥关系</font>，但与之前遇到的问题不同的是，每个则学家需要同时持有两个临界资源，因此有死锁的隐患。</p><p>如何避免<font color='#BAOC2F'>临界资源分配不当造成死锁</font>的问题，是哲学家进餐问题的精髓。</p><p>信号量设置：</p><ol><li>互斥信号量数组<code>chopstick[5]=&#123;1,1,1,1,1&#125;</code>用于实现对5根筷子的互斥访问。</li><li>对哲学家按照0~4进行编号，哲学家<code>i</code>左边的筷子编号为<code>i</code>，右边的筷子编号为<code>(i+1)%5</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">pi</span>() &#123;<span class="comment">//i号哲学家的进程</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">       <span class="built_in">P</span>(chopstick[i]);</span><br><span class="line">       <span class="built_in">P</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">       Have a meal;</span><br><span class="line">       <span class="built_in">V</span>(chopstick[i]);</span><br><span class="line">       <span class="built_in">V</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">       </span><br><span class="line">       Ponder questions;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*存在问题当如果5个哲学家并发的拿起了自己左手边的筷子，则所有哲学家都会循环等待右边的人放下筷子（阻塞）造成死锁*/</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.添加限制条件最多只允许4个哲学家进餐，以解决死锁问题*/</span></span><br><span class="line"><span class="comment">/*2.添加限制条件：</span></span><br><span class="line"><span class="comment">要求奇数号哲学家先拿起左边的筷子，然后再拿起右边的筷子</span></span><br><span class="line"><span class="comment">要求偶数号哲学家先拿起右边的筷子，然后再拿起左边的筷子</span></span><br><span class="line"><span class="comment">这种方式可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起筷子，另一个会直接堵塞</span></span><br><span class="line"><span class="comment">从而以解决死锁的问题*/</span></span><br><span class="line"><span class="comment">/*3.添加限制条件：仅当一个哲学家左右两根筷子都可使用时，才允许他抓起筷子*/</span></span><br><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//i号哲学家互斥的取筷子</span></span><br><span class="line"><span class="built_in">pi</span>() &#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">       <span class="built_in">P</span>(mutex);</span><br><span class="line">       <span class="built_in">P</span>(chopstick[i]);</span><br><span class="line">       <span class="built_in">P</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">       <span class="built_in">V</span>(mutex);</span><br><span class="line">       Have a meal;</span><br><span class="line">       <span class="built_in">V</span>(chopstick[i]);</span><br><span class="line">       <span class="built_in">V</span>(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">       </span><br><span class="line">       Ponder questions;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-Monitors管程同步机制"><a href="#6-Monitors管程同步机制" class="headerlink" title="6.Monitors管程同步机制"></a>6.Monitors管程同步机制</h4><h5 id="（1）管程定义与特征："><a href="#（1）管程定义与特征：" class="headerlink" title="（1）管程定义与特征："></a>（1）管程定义与特征：</h5><p>信号量机制存在的问题导致编程程序困难、易出错，管程属于一种高级的进程同步机制（不需要再关注PV操作）</p><p>&#x3D;&#x3D;管程的组成&#x3D;&#x3D;：</p><ol><li>局部于管程的<font color='#BAOC2F'>共享数据结构</font>说明</li><li>对该数据结构进行操作or访问的<font color='#BAOC2F'>一组过程（函数）</font></li><li>对局部于管程的共享数据设置初始值的语句</li><li>管程有一个名字</li></ol><p>&#x3D;&#x3D;管程的基本特征&#x3D;&#x3D;：</p><ol><li>局部于管程的数据只能被局部于管程的过程所访问</li><li>一个进程只有<font color='#BAOC2F'>通过调用管程的过程</font>才能进入管程访问共享数据（常考）</li><li>每次<font color='#BAOC2F'>仅允许一个进程</font>在管程内执行某个内部程序（常考）</li></ol><h5 id="（2）管程解决生产者消费者问题："><a href="#（2）管程解决生产者消费者问题：" class="headerlink" title="（2）管程解决生产者消费者问题："></a>（2）管程解决生产者消费者问题：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer &#123;</span><br><span class="line">    condition full, empty;<span class="comment">//条件变量用于实现同步（排队）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span> &#123;<span class="comment">//将item放入缓冲区中</span></span><br><span class="line">        <span class="keyword">if</span> (count == N) wait(full);</span><br><span class="line">        count++;</span><br><span class="line">        insert_item(item);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>) signal(empty);</span><br><span class="line">    &#125;</span><br><span class="line">    Item <span class="title function_">remove</span><span class="params">()</span> &#123;<span class="comment">//从缓冲区中取出一个产品</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) wait(empty);</span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">if</span> (count == N - <span class="number">1</span>) signal(full);</span><br><span class="line">        <span class="keyword">return</span> remove_item();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产者进程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        item = produce a item;</span><br><span class="line">        ProdecerConsumer.<span class="built_in">insert</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者进程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        item = ProdecerConsumer.<span class="built_in">remove</span>();</span><br><span class="line">        consume a item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）Java中的管程机制："><a href="#（3）Java中的管程机制：" class="headerlink" title="（3）Java中的管程机制："></a>（3）Java中的管程机制：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">monitor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Item buffer[] = <span class="keyword">new</span> <span class="title class_">Item</span>[N];</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次只有一个线程进行insert函数</span></span><br><span class="line"><span class="comment">     * 如果多个线程同时调用insert函数，则后来者需要排队进行等待</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Item item)</span> &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、进程死锁"><a href="#四、进程死锁" class="headerlink" title="四、进程死锁"></a>四、进程死锁</h3><h4 id="1-死锁概述："><a href="#1-死锁概述：" class="headerlink" title="1.死锁概述："></a>1.死锁概述：</h4><ul><li>死锁：在并发环境下各进程竞争资源，造成相互等待对方手里的资源，导致各进程都阻塞无法向前推进的现象。</li><li>饥饿：某进程由于长期得不到想要的资源，无法向前推进的现象。</li><li>死循环：某进程执行过程中一直跳不出某个循环的现象。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220922110631551.png" alt="image-20220922110631551"></p><p>&#x3D;&#x3D;死锁的必要条件&#x3D;&#x3D;：</p><p>产生死锁必须同时满足以下4个条件：</p><ol><li><p>互斥条件：只有对必须互斥使用资源的争抢，才会导致死锁现象。</p></li><li><p>不可剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走只能主动释放。</p></li><li><p>请求与保持条件：</p><p> 进程已经保持了至少一个资源，但又提出了新的资源请求。</p><p> 而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不释放。</p></li><li><p>循环等待条件：存在一种进程资源的<font color='#BAOC2F'>循环等待链</font>，链中的每个进程已获得的资源同时被下一个进程所请求。</p></li></ol><blockquote><p>注：发生循环等待未必会导致死锁现象，如果同类资源大于1则即使发生循环等待也不会死锁，否则一定会发生死锁（考点）。</p></blockquote><p>&#x3D;&#x3D;常见的死锁场景&#x3D;&#x3D;：</p><ol><li>对系统资源的竞争：各进程对不可剥夺的资源进行竞争可能会引起死锁，对可剥夺的资源（CPU）竞争不会引起死锁。</li><li>进程推进顺序非法：请求和释放资源的顺序不当，同样也会导致死锁。</li><li>信号量使用不当：如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能会导致死锁。</li></ol><blockquote><p>注：可以死锁发生的场景可以总结为，当不可剥夺资源的分配出现问题时，就会导致死锁现象。</p></blockquote><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220922114359517.png" alt="image-20220922114359517"></p><h4 id="2-死锁的预防："><a href="#2-死锁的预防：" class="headerlink" title="2.死锁的预防："></a>2.死锁的预防：</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220922121057059.png" alt="image-20220922121057059"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220922121105843.png" alt="image-20220922121105843"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220922121141516.png" alt="image-20220922121141516"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220922121154653.png" alt="image-20220922121154653"></p><h4 id="3-死锁的避免（银行家算法）★"><a href="#3-死锁的避免（银行家算法）★" class="headerlink" title="3.死锁的避免（银行家算法）★"></a>3.死锁的避免（银行家算法）★</h4><ul><li>安全序列：系统按照该序列分配资源，则每个进程都能顺利完成（只要能找到1个安全序列，系统就是安全的）。</li><li>不安全序列：如果系统按照该序列分配了资源后，找不出任何一个安全的序列，则系统就进入了不安全状态。</li></ul><blockquote><p>注：如果系统处于安全状态就一定不会发生死锁，如果处于不安全状态就有可能会发生死锁（考点）。</p></blockquote><p>&#x3D;&#x3D;银行家算法&#x3D;&#x3D;：可以在资源分配之前预先判断，这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。</p><h4 id="4-死锁的检查与解除："><a href="#4-死锁的检查与解除：" class="headerlink" title="4.死锁的检查与解除："></a>4.死锁的检查与解除：</h4><h5 id="（1）死锁检测（常考）"><a href="#（1）死锁检测（常考）" class="headerlink" title="（1）死锁检测（常考）"></a>（1）死锁检测（常考）</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220922123845531.png" alt="image-20220922123845531"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220922124121958.png" alt="image-20220922124121958"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220922124305394.png" alt="image-20220922124305394"></p><h5 id="（2）死锁解除（选择题）"><a href="#（2）死锁解除（选择题）" class="headerlink" title="（2）死锁解除（选择题）"></a>（2）死锁解除（选择题）</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220922124529330.png" alt="image-20220922124529330"></p>]]></content>
      
      
      <categories>
          
          <category> operating system </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：操作系统概述</title>
      <link href="/2023/03/01/operatingSystem/1.%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/03/01/operatingSystem/1.%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：操作系统概述"><a href="#第一章：操作系统概述" class="headerlink" title="第一章：操作系统概述"></a>第一章：操作系统概述</h1><hr><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><h4 id="1-OS的概念："><a href="#1-OS的概念：" class="headerlink" title="1.OS的概念："></a>1.OS的概念：</h4><p>操作系统是指满足以下特征的<font color='#BAOC2F'>程序的集合</font>。</p><ul><li><font color='#BAOC2F'>控制和管理</font>整个计算机系统的<font color='#BAOC2F'>硬件和软件资源</font>（OS是系统资源的管理者）</li><li>并合理地<font color='#BAOC2F'>组织调度</font>计算机的<font color='#BAOC2F'>工作和资源的分配</font>，以提供给用户和其他软件方便的接口和环境（向上层提供方便易用的服务）</li></ul><h4 id="2-OS的特征"><a href="#2-OS的特征" class="headerlink" title="2.OS的特征"></a>2.OS的特征</h4><h5 id="（1）并发Concurrence："><a href="#（1）并发Concurrence：" class="headerlink" title="（1）并发Concurrence："></a>（1）并发Concurrence：</h5><p>并发：指两个&#x2F;多个事件在<font color='#BAOC2F'>同一时间间隔内</font>发生（宏观上是同时发生、微观上是交替发生）</p><p>OS并发性：计算机系统中同时运行着多个程序，这些程序宏观上同时运行的微观上看是交替运行的。</p><blockquote><ol><li>操作系统的并发与共享是<font color='#BAOC2F'>两个最基本的特征</font>，二者<font color='#BAOC2F'>互为存在条件</font>。</li><li>操作系统就是伴随着多道程序技术而出现的，因此<font color='#BAOC2F'>操作系统和程序并发是一起诞生</font>的。</li></ol></blockquote><h5 id="（2）共享Sharing："><a href="#（2）共享Sharing：" class="headerlink" title="（2）共享Sharing："></a>（2）共享Sharing：</h5><p>共享：即资源共享，是指<font color='#BAOC2F'>系统中的资源</font>可供<font color='#BAOC2F'>内存中的多个并发执行的进程</font>共同使用。</p><p><mark>两种资源共享的方式</mark>：</p><ul><li>互斥共享：系统中的某些资源，虽然可以提供给多个进程使用，但<font color='#BAOC2F'>1个时间段只能允许1个进程</font>访问。</li><li>同时共享：系统中的某些资源，允许<font color='#BAOC2F'>1个时间段内由多个进程</font>同时访问</li></ul><h5 id="（3）虚拟Virtual："><a href="#（3）虚拟Virtual：" class="headerlink" title="（3）虚拟Virtual："></a>（3）虚拟Virtual：</h5><p>虚拟：将物理上的实体变为若干个逻辑上的对应实体（物理实体是实际存在的，而逻辑上对应的实体则是用户感受到的）。</p><p><mark>操作系统中的虚拟技术</mark>包括：虚拟处理器、虚拟内存、虚拟外部设备等</p><ol><li>虚拟处理器：通过多道程序设计技术、采用多道程序并发执行的方式，来分时使用一个处理器（时分复用技术）</li><li>虚拟存储器：采用虚拟存储技术、将物理存储器变为虚拟存储器，实现逻辑上扩充存储器的容量（空分复用技术）</li><li>虚拟外部设备：</li></ol><blockquote><p>注：如果失去了并发性1个时间段内只需运行1到程序，则失去了实现虚拟性的意义（没有并发性就谈不上虚拟性）。</p></blockquote><h5 id="（4）异步Asynchronism："><a href="#（4）异步Asynchronism：" class="headerlink" title="（4）异步Asynchronism："></a>（4）异步Asynchronism：</h5><p>异步：在多道程序环境下允许多个程序并发执行，但由于资源有限进程的执行不是一贯到底的。</p><blockquote><p>注：如果失去了并发性系统只能串行地运行各个程序，每个程序的执行就会一贯到底（拥有并发性才有可能导致异步性）。</p></blockquote><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220824231808418.png" alt="image-20220824231808418"></p><h4 id="3-OS的功能："><a href="#3-OS的功能：" class="headerlink" title="3.OS的功能："></a>3.OS的功能：</h4><h5 id="（1）作为系统资源管理者："><a href="#（1）作为系统资源管理者：" class="headerlink" title="（1）作为系统资源管理者："></a>（1）作为系统资源管理者：</h5><p>操作系统作为系统资源的管理者，应具有以下几方面的功能：处理机管理、存储器管理、文件管理和设备管理。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220824234321892.png" alt="image-20220824234321892"></p><h5 id="（2）作为用户与硬件系统之间的接口："><a href="#（2）作为用户与硬件系统之间的接口：" class="headerlink" title="（2）作为用户与硬件系统之间的接口："></a>（2）作为用户与硬件系统之间的接口：</h5><p>为了方便用户使用操作系统，操作系统还必须向用户提供接口。</p><p>封装思想：将<font color='#BAOC2F'>底层的硬件功能</font>封装成易用的服务，用户能更方便地使用计算机，而无需关心底层硬件原理。</p><ul><li>联机命令接口：交互式命令接口（cmd命令行）</li><li>脱机命令接口：批处理命令接口（bat批处理文件）</li><li>程序接口：可以在程序中<font color='#BAOC2F'>进行系统调用</font>来使用程序接口，普通用户不能直接使用程序接口，只能通过<font color='#BAOC2F'>程序代码间接使用</font>。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220824233656220.png" alt="image-20220824233656220"></p><h5 id="（3）实现对计算机资源的扩展："><a href="#（3）实现对计算机资源的扩展：" class="headerlink" title="（3）实现对计算机资源的扩展："></a>（3）实现对计算机资源的扩展：</h5><p>操作系统可用来扩充机器，以提供更方便的服务、更高的资源利用率。</p><p>没有任何软件支持的计算机成为裸机。在裸机上安装的操作系统可以提供资源管理功能和方便用户的服务功能。通常把覆盖了软件的机器成为扩充机器，又称之为虚拟机。</p><h3 id="二、发展与分类"><a href="#二、发展与分类" class="headerlink" title="二、发展与分类"></a>二、发展与分类</h3><h4 id="1-手工操作阶段"><a href="#1-手工操作阶段" class="headerlink" title="1.手工操作阶段"></a>1.手工操作阶段</h4><p>用户独占全机、人机速度矛盾导致资源的利用率极低</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220824233102819.png" alt="image-20220824233102819"></p><h4 id="2-批处理阶段"><a href="#2-批处理阶段" class="headerlink" title="2.批处理阶段"></a>2.批处理阶段</h4><h5 id="（1）单道批处理系统："><a href="#（1）单道批处理系统：" class="headerlink" title="（1）单道批处理系统："></a>（1）单道批处理系统：</h5><p>引入脱机输入&#x2F;输出技术（外围机+磁带实现），并由<font color='#BAOC2F'>监督程序</font>负责控制作业的输入、输出。</p><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">单道批处理系统缓解了一定程度的人机速度矛盾，资源利用率有所提升。</td><td align="center">资源利用率依然很低</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220824233254854.png" alt="image-20220824233254854"></p><h5 id="（2）多道批处理系统（OS-debut）："><a href="#（2）多道批处理系统（OS-debut）：" class="headerlink" title="（2）多道批处理系统（OS debut）："></a>（2）多道批处理系统（OS debut）：</h5><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>多道程序并发执行，</td><td>用户响应时间长没有人机交互功能</td></tr><tr><td>共享计算机资源（资源利用率提升）CPU和其他资源更能<font color='#BAOC2F'>保持忙碌状态</font>，<font color='#BAOC2F'>系统吞吐量增大</font>。</td><td>用户提交自己的作业后就只能等待，中间不能控制自己作业的执行</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220704153403136.png" alt="image-20220704153403136"></p><h4 id="3-分时操作系统"><a href="#3-分时操作系统" class="headerlink" title="3.分时操作系统"></a>3.分时操作系统</h4><p>分时操作系统：计算机以<font color='#BAOC2F'>时间片</font>为单位<font color='#BAOC2F'>轮流为各个用户&#x2F;作业服务</font>，各个用户可通过终端与计算机进行交互。</p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>用户的请求<font color='#BAOC2F'>可以被即使响应</font>，解决了人机交互问题。</td><td><font color='#BAOC2F'>不能优先处理一些紧急的任务</font></td></tr><tr><td>允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到其他人的存在。</td><td>操作系统对各个用户&#x2F;作业都是完全公平的，循环地为每个用户&#x2F;作业服务一个时间片。</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220704154053071.png" alt="image-20220704154053071"></p><h4 id="4-实时操作系统"><a href="#4-实时操作系统" class="headerlink" title="4.实时操作系统"></a>4.实时操作系统</h4><p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要求在严格的时限内处理完事件。</p><ul><li>优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队（及时性、可靠性）</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220704155007551.png" alt="image-20220704155007551"></p><h3 id="三、运行环境"><a href="#三、运行环境" class="headerlink" title="三、运行环境"></a>三、运行环境</h3><h4 id="1-处理器运行机制"><a href="#1-处理器运行机制" class="headerlink" title="1.处理器运行机制"></a>1.处理器运行机制</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220705154600363.png" alt="image-20220705154600363"></p><p><mark>内核态与用户态</mark>：</p><ul><li>特权指令：指不允许用户直接使用的指令，如IO指令、置中断指令、存取用于内存保护的寄存器的等的指令</li><li>非特权指令：指允许用户直接使用的指令，指令不能访问系统中的软硬件资源、仅限于访问用户的地址空间</li><li>内核态（管态）：说明正在运行的是内核程序，此时可以执行特权指令</li><li>用户态（目态）：说明正在运行的是应用程序，此时只能执行非特权指令</li></ul><blockquote><p>注：CPU中有一个程序状态字寄存器PSW，其中有1个二进制位用于记录表示CPU目前处于的状态（内核态1、用户态0）</p></blockquote><p><mark>内核态用户态间的切换</mark>：</p><ul><li>内核态切换为用户态：执行一条特权指令修改PSW标志位为用户态，该动作意味着<font color='#BAOC2F'>操作系统将主动让出CPU使用权</font>。</li><li>用户态切换为内核态：由<font color='#BAOC2F'>中断引发</font>硬件自动完成变态过程，触发中断信号意味着<font color='#BAOC2F'>操作系统将强行夺回CPU使用权</font>。</li></ul><blockquote><p>注：除了非法使用特权指令之外还有很多事件会触发中断信号，但凡<font color='#BAOC2F'>需要操作系统介入</font>之处都会触发中断信号。</p></blockquote><h4 id="2-中断和异常"><a href="#2-中断和异常" class="headerlink" title="2.中断和异常"></a>2.中断和异常</h4><h5 id="（1）中断和异常概念："><a href="#（1）中断和异常概念：" class="headerlink" title="（1）中断和异常概念："></a>（1）中断和异常概念：</h5><blockquote><p>注：中断是让操作系统内核夺回CPU使用权的唯一途径</p></blockquote><ul><li>中断&#x2F;外中断：与当前执行的指令无关（中断信号来自CPU外部），常用于信息IO。如设备发出的IO结束中断、时钟中断。</li><li>异常&#x2F;内中断：与当前执行的指令有关（中断信号来自CPU内部），如程序的非法操作码、地址越界、运算溢出、虚拟系统缺页。</li></ul><p><mark>中断的分类</mark>：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220705160537503.png" alt="image-20220705160537503"></p><ol><li>可屏蔽中断INTR，通过改变屏蔽字可以实现多重中断，从而使中断处理更加灵活。</li><li>不可屏蔽中断NMI，通过是紧急的硬件故障，如电源掉电（异常不能被屏蔽）。</li><li>故障Fault：由指令执行引起的异常，如非法操作码、缺页故障、除数为0、运算溢出等。</li><li>自陷Trap：是一种实现安排的异常事件，用于在用户态下<font color='#BAOC2F'>调用操作系统内核程序</font>（主动将CPU控制权还给内核），如条件陷阱指令</li><li>终止Abort：是指出现了使得CPU无法继续执行的<font color='#BAOC2F'>硬件故障</font>，如控制器出错、存储器校验错误等</li></ol><h5 id="（2）中断处理的过程："><a href="#（2）中断处理的过程：" class="headerlink" title="（2）中断处理的过程："></a>（2）中断处理的过程：</h5><p>不同的中断信号，需要用不同的中断处理程序来处理。</p><p>当CPU检测到中断信号后，会根据中断信号的类型去查询中断向量表，以此来找到<font color='#BAOC2F'>相应的中断处理程序</font>在内存中的位置。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220705163021349.png" alt="image-20220705163021349"></p><h4 id="3-系统调用"><a href="#3-系统调用" class="headerlink" title="3.系统调用"></a>3.系统调用</h4><h5 id="（1）系统调用："><a href="#（1）系统调用：" class="headerlink" title="（1）系统调用："></a>（1）系统调用：</h5><p>OS作为用户和硬件间的接口，需要向上层提供服务主要包括命令接口和程序接口。其中程序接口由一组系统调用组成。</p><p>系统调用可以通过操作系统，提供给应用程序使用的接口（可理解为可供应用程序调用的特殊函数）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220705181815304.png" alt="image-20220705181815304"></p><h5 id="（2）系统调用过程："><a href="#（2）系统调用过程：" class="headerlink" title="（2）系统调用过程："></a>（2）系统调用过程：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220705231804043.png" alt="image-20220705231804043"></p><ol><li>陷入指令是<font color='#BAOC2F'>在用户态执行</font>的，执行陷入指令之后会立即引发一个内中断，使CPU进入核心态。</li><li>发出系统调用<font color='#BAOC2F'>请求是在用户态</font>，而对系统调用的相应处理在核心态下进行。</li></ol><h3 id="四、体系结构"><a href="#四、体系结构" class="headerlink" title="四、体系结构"></a>四、体系结构</h3><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20221119163117839.png" alt="image-20221119163117839"></p><h4 id="1-大内核-x2F-微内核"><a href="#1-大内核-x2F-微内核" class="headerlink" title="1.大内核&#x2F;微内核"></a>1.大内核&#x2F;微内核</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220705232540293.png" alt="image-20220705232540293"></p><table><thead><tr><th>大内核</th><th></th></tr></thead><tbody><tr><td>概念</td><td>将操作系统的主要功能模块都作为系统内核，运行在核心态</td></tr><tr><td>优点</td><td>高性能</td></tr><tr><td>缺点</td><td>内核代码庞大、结构混乱难以维护</td></tr></tbody></table><table><thead><tr><th>微内核</th><th></th></tr></thead><tbody><tr><td>概念</td><td>只把最基本的功能保留在内核中</td></tr><tr><td>优点</td><td>内核功能少、结构清晰便于维护</td></tr><tr><td>缺点</td><td>需要频繁的在核心态与用户态之间切换，性能较低</td></tr></tbody></table><ol><li>操作系统的内核需要运行在内核态，非内核功能运行在用户态</li><li>典型的大内核OS：Linux、UNXI、</li><li>典型的微内核OS：Window NT</li></ol><h4 id="2-分层结构-x2F-模块化-x2F-外核"><a href="#2-分层结构-x2F-模块化-x2F-外核" class="headerlink" title="2.分层结构&#x2F;模块化&#x2F;外核"></a>2.分层结构&#x2F;模块化&#x2F;外核</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220705233443859.png" alt="image-20220705233443859"></p><h3 id="五、操作系统引导"><a href="#五、操作系统引导" class="headerlink" title="五、操作系统引导"></a>五、操作系统引导</h3><p>操作系统引导是指计算机利用CPU运行特定程序，通过识别硬盘分区、分区上的操作系统、最后通过程序启动操作系统的过程。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220706002301850.png" alt="image-20220706002301850"></p><ul><li>Step1：CPU从一个特定主存地址开始取指令，执行<font color='#BAOC2F'>ROM中的引导程序</font>（先进行硬件自检、再开机）</li><li>Step2：将磁盘的第一块（主引导记录）读入内存，执行磁盘引导程序扫描分区表</li><li>Step3：从活动分区（主分区OS安装分区）读入分区引导记录，执行其中的程序</li><li>Step4：从根目录下找<font color='#BAOC2F'>完整的操作系统初始化程序</font>并执行，完成开机一系列动作</li></ul><h3 id="六、虚拟机"><a href="#六、虚拟机" class="headerlink" title="六、虚拟机"></a>六、虚拟机</h3><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220706002733308.png" alt="image-20220706002733308"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/operatingSystem/image-20220706002838243.png" alt="image-20220706002838243"></p>]]></content>
      
      
      <categories>
          
          <category> operating system </category>
          
      </categories>
      
      
        <tags>
            
            <tag> operating system </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章：绪论</title>
      <link href="/2023/02/28/dataStructure/1.%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%BB%AA%E8%AE%BA/"/>
      <url>/2023/02/28/dataStructure/1.%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章：绪论"><a href="#第一章：绪论" class="headerlink" title="第一章：绪论"></a>第一章：绪论</h1><hr><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><h4 id="1-Data数据"><a href="#1-Data数据" class="headerlink" title="1.Data数据"></a>1.Data数据</h4><p>Data数据：是能够输入计算机且能被计算机处理的<font color='#BAOC2F'>各种符号的集合</font>。</p><p>Data数据包括：</p><ol><li>数值型数据：整数、实数</li><li>非数值型数据：文字、图像、图形、声音等</li></ol><h4 id="2-DataElement数据元素"><a href="#2-DataElement数据元素" class="headerlink" title="2.DataElement数据元素"></a>2.DataElement数据元素</h4><p>DataElement数据元素（元素&#x2F;记录&#x2F;结点&#x2F;顶点）：是Data数据的基本单位，在计算机程序中通常被作为一个整体进行考虑和处理</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220608120754640.png" alt="image-20220608120754640"></p><h4 id="3-DataItem数据项"><a href="#3-DataItem数据项" class="headerlink" title="3.DataItem数据项"></a>3.DataItem数据项</h4><p>DataItem数据项：是构成数据元素的<font color='#BAOC2F'>不可分割的最小单位</font>。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220608121010016.png" alt="image-20220608121010016"></p><blockquote><p>数据三者之间的关系：数据 &gt; 数据元素  &gt; 数据项</p></blockquote><h4 id="4-DataObject数据对象"><a href="#4-DataObject数据对象" class="headerlink" title="4.DataObject数据对象"></a>4.DataObject数据对象</h4><p>DataObject数据对象：是性质相同的数据元素的集合，是数据的一个子集。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220608121427003.png" alt="image-20220608121427003"></p><p>&#x3D;&#x3D;数据元素与数据对象之间的不同&#x3D;&#x3D;：</p><ol><li>数据元素是组成数据的基本单位，是数据集合的个体</li><li>数据对象是性质相同的数据元素的集合，是数据集合的子集</li></ol><h4 id="5-DataStructure数据结构"><a href="#5-DataStructure数据结构" class="headerlink" title="5.DataStructure数据结构"></a>5.DataStructure数据结构</h4><h5 id="（1）逻辑结构："><a href="#（1）逻辑结构：" class="headerlink" title="（1）逻辑结构："></a>（1）逻辑结构：</h5><table><thead><tr><th>划分方式1</th><th>说明</th></tr></thead><tbody><tr><td>线性结构</td><td>有且仅有一个开始和一个终端结点，并且所有结点都最多只有一个直接前驱和直接后继。</td></tr><tr><td>非线性结构</td><td>一个结点可能有多个直接前驱和直接后继。</td></tr></tbody></table><table><thead><tr><th>划分方式2</th><th>说明</th></tr></thead><tbody><tr><td>集合结构</td><td>结构中的数据元素之间属于同一集合，无任何其他关系</td></tr><tr><td>线性结构</td><td>结构中的数据元素存在一对一关系</td></tr><tr><td>树形结构</td><td>结构中的数据元素存在一对多关系</td></tr><tr><td>图&#x2F;网状结构</td><td>结构中的数据元素存在多对多关系</td></tr></tbody></table><h5 id="（2）存储结构："><a href="#（2）存储结构：" class="headerlink" title="（2）存储结构："></a>（2）存储结构：</h5><p>物理&#x2F;存储结构：数据元素及其关系在计算机内存中的表示&#x2F;映像</p><ol><li>顺序存储结构：用一组<font color='#BAOC2F'>连续的存储单元</font>依次存储数据元素，数据元素之间的逻辑关系由<font color='#BAOC2F'>元素的存储位置</font>来表示。</li><li>链式存储结构：用一组<font color='#BAOC2F'>任意的存储单元</font>存储数据元素，数据之间的逻辑关系用<font color='#BAOC2F'>指针</font>来表示。</li><li>索引存储结构：在存储结点信息的同时，还建立附加的<font color='#BAOC2F'>索引表</font>。</li><li>散列存储结构：根据<font color='#BAOC2F'>结点的关键字</font>直接计算出该结点的存储地址。</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220803221247599.png" alt="image-20220803221247599"></p><h5 id="（3）数据的运算："><a href="#（3）数据的运算：" class="headerlink" title="（3）数据的运算："></a>（3）数据的运算：</h5><p>数据的运算：包括运算的定义和实现</p><ul><li>定义针对逻辑结构，指出<font color='#BAOC2F'>运算的功能</font>。</li><li>实现针对存储结构，指出<font color='#BAOC2F'>运算的具体操作步骤</font>。</li></ul><h3 id="二、算法分析"><a href="#二、算法分析" class="headerlink" title="二、算法分析"></a>二、算法分析</h3><p>算法是对特定问题求解步骤的一种描述，是指令的有限序列（其中每个指令表示一个或多个操作）。</p><h4 id="1-算法特性"><a href="#1-算法特性" class="headerlink" title="1.算法特性"></a>1.算法特性</h4><ol><li>有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷的时间内完成</li><li>确定性：对于相同的输入只能得到相同的输出</li><li>可行性：算法可执行</li><li>输入：一个算法有零个或多个输入</li><li>输出：一个算法有一个或多个输出</li></ol><h4 id="2-时间复杂度"><a href="#2-时间复杂度" class="headerlink" title="2.时间复杂度"></a>2.时间复杂度</h4><h5 id="（1）语句执行次数："><a href="#（1）语句执行次数：" class="headerlink" title="（1）语句执行次数："></a>（1）语句执行次数：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220804110723704.png" alt="image-20220804110723704"></p><p>可假设执行每条语句所需要的时间均为<font color='#BAOC2F'>单位时间</font>，则对算法运行时间的讨论可转化为讨论算法中<font color='#BAOC2F'>所有语句的执行次数</font>，即频度之和。</p><p>算法运行时间效率比较 &#x3D; 算法语句执行次数比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个n*n矩阵相乘的算法时间效率分析</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;<span class="comment">//执行n+1次（条件不成立退出循环）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)&#123;<span class="comment">//执行n(n+1)次（外循环n次内循环n+1次）</span></span><br><span class="line">        c[i][j] = <span class="number">0</span>;<span class="comment">//执行n*n次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; ++k)<span class="comment">//执行n*n*(n+1)次</span></span><br><span class="line">            c[i][j] = c[i][j] + a[i][k]*b[k][j]<span class="comment">//执行n*n*n次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//T(n) = 算法运行时间效率 = 算法语句执行次数</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220804111251641.png" alt="image-20220804111251641"></p><h5 id="（2）时间复杂度的定义："><a href="#（2）时间复杂度的定义：" class="headerlink" title="（2）时间复杂度的定义："></a>（2）时间复杂度的定义：</h5><p>为了便于比较不同算法的时间效率，我们仅比较他们的&#x3D;&#x3D;数量级&#x3D;&#x3D;来粗略的替代执行次数</p><p>若有某个辅助函数f(n)，使得当n趋近于无穷大时T(n)&#x2F;f(n)的极限为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作<code>T(n)=O(f(n))</code></p><p>称<code>O(f(n))</code>为算法的<font color='#BAOC2F'>渐进时间复杂度</font>，简称时间复杂度。</p><h5 id="（3）时间复杂度的计算："><a href="#（3）时间复杂度的计算：" class="headerlink" title="（3）时间复杂度的计算："></a>（3）时间复杂度的计算：</h5><p>算法中基本语句重复执行的次数是问题规模n的某个函数<code>f(n)</code>，算法的时间度量记作<code>T(n)=O(f(n))</code></p><p>&#x3D;&#x3D;时间复杂度计算步骤&#x3D;&#x3D;：</p><ol><li>找出语句频度最大的那条语句作为基本语句</li><li>计算基本语句的频度，得到问题规模n的某个函数<code>f(n)</code></li><li>取其数量级用符号O表示</li><li>对于复杂的算法，可以将其分成几个容易估算的部分，然后利用加法规则和乘法规则计算时间复杂度</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220804120326648.png" alt="image-20220804120326648"></p><p>&#x3D;&#x3D;时间复杂度分类&#x3D;&#x3D;：</p><ol><li>最坏时间复杂度</li><li>最好时间复杂度</li><li>平均时间复杂度：所有可能输入实例在等概论出现情况下，算法的期望运行时间</li></ol><p>&#x3D;&#x3D;时间复杂度T(n)按数量级递增顺序为&#x3D;&#x3D;：</p><table><thead><tr><th>常数阶</th><th>对数阶</th><th>线性阶</th><th>线性对数阶</th><th>平方阶</th><th>立方阶</th><th>…</th><th>指数阶</th><th>阶乘</th><th></th></tr></thead><tbody><tr><td>O(1)</td><td>O(log<sub>2</sub>n)</td><td>O(n)</td><td>O(nlog<sub>2</sub>n)</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>3</sup>)</td><td>…</td><td>O(2<sup>n</sup>)</td><td>O(n!)</td><td>O(n<sup>n</sup>)</td></tr></tbody></table><h5 id="（4）实例分析："><a href="#（4）实例分析：" class="headerlink" title="（4）实例分析："></a>（4）实例分析：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exam</span><span class="params">(<span class="type">float</span> x[][], <span class="type">int</span> m, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> sum[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">        sum[i] = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">            sum[i] += x[i][j]; <span class="comment">//f(n)=m*n, T(n) = O(m*n)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; : &quot;</span> &lt;&lt; sum[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= j; ++k)</span><br><span class="line">            x = x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220803213753319.png" alt="image-20220803213753319"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例3</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n)&#123;</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220803215402296.png" alt="image-20220803215402296"></p><h4 id="3-空间复杂度"><a href="#3-空间复杂度" class="headerlink" title="3.空间复杂度"></a>3.空间复杂度</h4><h5 id="（1）空间复杂度定义："><a href="#（1）空间复杂度定义：" class="headerlink" title="（1）空间复杂度定义："></a>（1）空间复杂度定义：</h5><p>算法所需存储空间的度量，记作<code>S(n)=O(f(n))</code>,其中n为问题的规模大小</p><blockquote><p>注：算法本身要占用的空间：输入&#x2F;输出、指令、常数、变量、辅助空间</p></blockquote><h5 id="（2）空间复杂度计算："><a href="#（2）空间复杂度计算：" class="headerlink" title="（2）空间复杂度计算："></a>（2）空间复杂度计算：</h5><ul><li>普通程序<ul><li>找到所占用空间大小与问题规模相关的变量</li><li>分析<font color='#BAOC2F'>所占空间x</font>与<font color='#BAOC2F'>问题规模n</font>的关系<code>x = f(n)</code></li><li>x的数量级O(x)即为空间复杂度S(n)</li></ul></li><li>递归程序<ul><li>找到<font color='#BAOC2F'>递归调用的深度x</font>与<font color='#BAOC2F'>问题规模n</font>的关系<code>x = f(n)</code></li><li>x的数量级O(x)即为空间复杂度S(n)</li></ul></li></ul><h5 id="（3）实例分析："><a href="#（3）实例分析：" class="headerlink" title="（3）实例分析："></a>（3）实例分析：</h5><p>实现将一维数组a中的n个数逆序存放到原数组中（数组逆置）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1:S(n) = O(1)辅助空间为变量temp</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; ++i)&#123;</span><br><span class="line">    temp = a[i];</span><br><span class="line">    a[i] = a[n - i - <span class="number">1</span>];</span><br><span class="line">    a[n - i - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法2:S(n) = O(n)辅助空间为数组b[]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    b[i] = a[n - i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    a[i] = b[i];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> datestructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> datestructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章：线性表</title>
      <link href="/2023/02/28/dataStructure/2.%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
      <url>/2023/02/28/dataStructure/2.%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章：线性表"><a href="#第二章：线性表" class="headerlink" title="第二章：线性表"></a>第二章：线性表</h1><hr><h3 id="一、线性表"><a href="#一、线性表" class="headerlink" title="一、线性表"></a>一、线性表</h3><p>线性表：具有<font color='#BAOC2F'>相同特性的数据元素</font>的一个<font color='#BAOC2F'>有限序列</font>，数据元素的个数定义为表的长度。</p><p>线性表ADT的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ADT List &#123;</span><br><span class="line">    数据对象:</span><br><span class="line">    D = &#123;ai | ai属于Element, (i = <span class="number">1</span>, <span class="number">2</span>, ..., n)&#125;</span><br><span class="line">    数据关系:</span><br><span class="line">    R = &#123;&lt;ai<span class="number">-1</span>, ai&gt; | ai<span class="number">-1</span>, ai属于D, (i = <span class="number">1</span>, <span class="number">2</span>, ..., n)&#125;</span><br><span class="line">    基本操作:</span><br><span class="line">    <span class="built_in">InitList</span>(&amp;L);</span><br><span class="line">    <span class="built_in">DestroyList</span>(&amp;L);</span><br><span class="line">    <span class="built_in">ListInsert</span>(&amp;L, i, e);</span><br><span class="line">    <span class="built_in">ListDelete</span>(&amp;L, i, &amp;e);</span><br><span class="line">&#125; ADT List</span><br></pre></td></tr></table></figure><h3 id="二、线性表的顺序表示"><a href="#二、线性表的顺序表示" class="headerlink" title="二、线性表的顺序表示"></a>二、线性表的顺序表示</h3><h4 id="1-顺序表定义："><a href="#1-顺序表定义：" class="headerlink" title="1.顺序表定义："></a>1.顺序表定义：</h4><p>顺序存储结构：将<font color='#BAOC2F'>逻辑上相邻的数据元素</font>存储在<font color='#BAOC2F'>物理上相邻的存储单元中</font>的存储结构（逻辑上相邻，物理上也相邻）</p><p>&#x3D;&#x3D;顺序表的特点&#x3D;&#x3D;：</p><ol><li>线性表顺序存储结构必须<font color='#BAOC2F'>占用一片连续的存储空间</font>，</li><li>知道某个元素的存储位置就<font color='#BAOC2F'>可以计算其他元素的存储位置</font>，</li><li>顺序表：随机存取</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220826110610003.png" alt="image-20220826110610003"></p><h4 id="2-顺序表存储表示："><a href="#2-顺序表存储表示：" class="headerlink" title="2.顺序表存储表示："></a>2.顺序表存储表示：</h4><p>根据顺序表的地址连续、依次存放、随机存储、类型相同等特点，可以用高级语言中的数组来表示顺序表这种数据结构。</p><p>关于数组的内存分配有两种方式（顺序表初始化）：</p><ol><li><p>数组静态分配：数组的大小和空间初始固定，一旦空间占满再加入新的数据就会发生溢出，进而导致程序崩溃。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType elem[MaxSize];<span class="comment">//顺序表最大长度(容量)</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//顺序表目前长度</span></span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure></li><li><p>数组动态分配：数组的存储空间是动态分配的，一旦空间占满就会另外开辟一块更大的存储空间，替换原来的存储空间（扩容）。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType *elem;<span class="comment">//顺序表最大长度(容量)</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//顺序表目前长度</span></span><br><span class="line">&#125; SqList;</span><br><span class="line"></span><br><span class="line">SqList L;</span><br><span class="line">L.data = (ElemType*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(ElemType)*MaxSize)</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>补充：C与Cpp对于内存动态分配语句中的函数说明</p><ol><li><p>c动态内存分配：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>malloc(n)</td><td>开辟n字节长度的地址空间，并返回这段空间的首地址</td></tr><tr><td>sizeof(x)</td><td>计算变量x的长度</td></tr><tr><td>free(p)</td><td>释放指针p所指变量的存储空间（彻底删除一个变量）</td></tr></tbody></table></li><li><p>cpp动态存储分配：</p><table><thead><tr><th>函数</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>new T()</td><td>申请用于存储T类型对象的内存空间，并按照初值列表进行赋值<br />如果执行成功则返回T类型的指针（指向新分配的内存），<br />否则返回0（NULL）</td><td>int *p &#x3D; new int(10);<br />int *p &#x3D; new int;</td></tr><tr><td>delete</td><td>释放指针p所指向的内存，指针p必须是new操作的返回值</td><td>delete p;</td></tr></tbody></table></li></ol></blockquote><h4 id="3-顺序表基本操作："><a href="#3-顺序表基本操作：" class="headerlink" title="3.顺序表基本操作："></a>3.顺序表基本操作：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数返回结果状态码</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFEASIBLE -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVERFLOW -2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Status是函数的类型，其值是函数结果状态码</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br></pre></td></tr></table></figure><h5 id="（1）简单操作："><a href="#（1）简单操作：" class="headerlink" title="（1）简单操作："></a>（1）简单操作：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作1：初始化一个空的顺序表</span></span><br><span class="line"><span class="function">Status <span class="title">InitSqList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.为顺序表分配内存空间</span></span><br><span class="line">    L.elem = <span class="keyword">new</span> ElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span> (!L.elem) &#123;</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//内存分配失败，则直接返回</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        L.length = <span class="number">0</span>;<span class="comment">//内存分配成功，则设定目前顺序表的长度为0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作2：顺序表取值(按下标查找)</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(SqList L, <span class="type">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> ERROR;<span class="comment">//非法取值</span></span><br><span class="line">    e = L.elem[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作3：顺序表清空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作4：顺序表销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DestroyList</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.elem) <span class="keyword">delete</span> L.elem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）顺序表查找操作："><a href="#（2）顺序表查找操作：" class="headerlink" title="（2）顺序表查找操作："></a>（2）顺序表查找操作：</h5><p>从表的一端考试逐个进行记录的<font color='#BAOC2F'>关键字和给定值</font>的比较（逐个遍历），如果找到则返回该元素的位置序号，否则返回0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SqList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.elemp[i] == e) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：查找的元素就在表头，需要比较1次时间复杂度为O(1)</li><li>最坏情况：查找的元素在表位 or 不存在，需要比较n次时间复杂度为O(n)</li><li>平均情况：需要比较(n + 1) &#x2F; 2次时间复杂度为O(n)，因此线性表按值查找的平均时间复杂度为<font color='#BAOC2F'>O(n)</font></li></ul><h5 id="（3）顺序表插入操作："><a href="#（3）顺序表插入操作：" class="headerlink" title="（3）顺序表插入操作："></a>（3）顺序表插入操作：</h5><p>算法思想：</p><ol><li>判断插入位置i是否合法，否则返回ERROR</li><li>判断顺序表的存储空间是否已满，否则返回ERROR</li><li>将第<code>n~i</code>位元素依次向后移动一个位置，空出第i位置▲</li><li>将插入元素e放入到插入位置▲</li><li>修改顺序表目前长度+1，插入成功返回OK▲</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SqListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length + <span class="number">1</span>) <span class="keyword">return</span> ERROR;<span class="comment">//非法插入</span></span><br><span class="line">    <span class="keyword">if</span> (L.length == MAXSIZE) <span class="keyword">return</span> ERROR;<span class="comment">//顺序表已满</span></span><br><span class="line">    <span class="comment">//1.将插入元素及其之后的元素后移</span></span><br><span class="line">    <span class="keyword">for</span> (j = L.length - <span class="number">1</span>; j &gt;= i - <span class="number">1</span>; --j) &#123;</span><br><span class="line">        L.elem[j + <span class="number">1</span>] = L.elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.将插入元素e放入到插入位置</span></span><br><span class="line">    L.elem[i - <span class="number">1</span>] = e;</span><br><span class="line">    <span class="comment">//3.修改顺序表目前长度</span></span><br><span class="line">    L.length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：在顺序表尾插入(i &#x3D; n + 1)，元素后移执行语句不执行，时间复杂度为O(1)</li><li>最坏情况：在顺序表头插入(i &#x3D; n)，元素后移语句将执行n次，时间复杂度为O(n)</li><li>平均情况：元素后移语句平均需要执行n &#x2F; 2次，顺序表插入算法的平均时间复杂度为<font color='#BAOC2F'>O(n)</font></li></ul><h5 id="（4）顺序表删除操作："><a href="#（4）顺序表删除操作：" class="headerlink" title="（4）顺序表删除操作："></a>（4）顺序表删除操作：</h5><p>算法思想：</p><ol><li>判断删除位置i是否合法，否则返回ERROR</li><li>将将要删除的元素保存到e中▲</li><li>将第<code>i+1~n</code>位的元素依次向前移动一个位置▲</li><li>修改顺序表目前长度-1，删除成功返回OK▲</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SqListDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, Elemtype &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span> || i &gt; L.length) <span class="keyword">return</span> ERROR;<span class="comment">//非法删除</span></span><br><span class="line">    <span class="comment">//1.将将要删除的元素保存到e中</span></span><br><span class="line">    e = L.elem[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//2.将删除元素之后的元素向前移动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= L.length - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">        L.elem[j - <span class="number">1</span>] = L.elem[j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.修改顺序表目前长度</span></span><br><span class="line">    L.length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最好情况：删除表尾元素(i &#x3D; n)，元素前移执行语句不执行，时间复杂度为O(1)</li><li>最坏情况：删除表头元素(i &#x3D; n)，元素前移语句将执行n - 1次，时间复杂度为O(n)</li><li>平均情况：元素前移语句平均需要执行(n - 1)&#x2F;2次，顺序表删除算法的平均时间复杂度为<font color='#BAOC2F'>O(n)</font></li></ul><h5 id="（5）总结："><a href="#（5）总结：" class="headerlink" title="（5）总结："></a>（5）总结：</h5><p>顺序表优点：</p><ol><li>存储密度大</li><li>可以随机存取表中任意元素</li><li>算法效率：查找&#x2F;插入&#x2F;删除算法的平均时间复杂度都为O(n)，空间复杂度为O(1)</li></ol><p>顺序表缺点：</p><ol><li>浪费存储空间</li><li>在插入&#x2F;删除某一元素时，需要移动大量元素</li><li>属于静态存储形式，数据元素的个数不能自由扩充</li></ol><h4 id="4-Cpp中的参数传递："><a href="#4-Cpp中的参数传递：" class="headerlink" title="4.Cpp中的参数传递："></a>4.Cpp中的参数传递：</h4><p>参数传递的方式有两种：值传递与地址传递（参数为指针变量&#x2F;数组名、引用类型）</p><h5 id="（1）值传递："><a href="#（1）值传递：" class="headerlink" title="（1）值传递："></a>（1）值传递：</h5><p>值传递：将实参的值传送给函数局部工作区相应的副本中，函数使用该副本执行必要的功能（函数修改的是副本的值，实参不改变）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">float</span> m, <span class="type">float</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> temp = n;</span><br><span class="line">    m = n;</span><br><span class="line">    n = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）地址传递（指针变量）"><a href="#（2）地址传递（指针变量）" class="headerlink" title="（2）地址传递（指针变量）"></a>（2）地址传递（指针变量）</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.形参变化不影响实参（实际交换了指针变量）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">float</span> *m, <span class="type">float</span> *n)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> *temp = m;</span><br><span class="line">    m = n;</span><br><span class="line">    n = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.形参变化影响实参（实际交换了指针所指向的ab值）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">float</span> *m, <span class="type">float</span> *n)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> temp = *m;</span><br><span class="line">    *m = *n;</span><br><span class="line">    *n = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> a, b;</span><br><span class="line">    <span class="type">float</span> *p1, *p2;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    p1 = &amp;a; p2 = &amp;b;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap1</span>(p1, p2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用swap1方法：形参变化不影响实参（实际交换了指针变量）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap2</span>(p1, p2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;调用swap2方法：形参变化影响实参（实际交换了指针所指向的ab值）&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220828203035778.png" alt="image-20220828203035778"></p><h5 id="（3）地址传递（数组名）"><a href="#（3）地址传递（数组名）" class="headerlink" title="（3）地址传递（数组名）"></a>（3）地址传递（数组名）</h5><p>如果传递的参数是数组的首地址，对<font color='#BAOC2F'>形参数组</font>所做的任何操作<font color='#BAOC2F'>都将反应到实参数组中</font>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.传递数组地址,且数组地址使用char b[]接收</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">char</span> temp[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(temp, <span class="string">&quot;Rewrite by func1, address access by char temp[].&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.传递数组地址,且数组地址使用char *b接收</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">char</span> *temp)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(temp, <span class="string">&quot;Rewrite by func2, address access by char *temp.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：数组地址即为数组首个元素的地址,故char b[]与char *b作用相同</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">50</span>] = <span class="string">&quot;this is a test!&quot;</span>;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func1</span>(a);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func2</span>(a);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220828210418913.png" alt="image-20220828210418913"></p><h5 id="（4）地址传递（引用类型-amp-）"><a href="#（4）地址传递（引用类型-amp-）" class="headerlink" title="（4）地址传递（引用类型&amp;）"></a>（4）地址传递（引用类型&amp;）</h5><p>引用：为实际对象提供了一个<font color='#BAOC2F'>替代的名字</font>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">float</span> &amp;m, <span class="type">float</span> &amp;n)</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> temp = m;</span><br><span class="line">    m = n;</span><br><span class="line">    n = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">float</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、线性表的链式表示"><a href="#三、线性表的链式表示" class="headerlink" title="三、线性表的链式表示"></a>三、线性表的链式表示</h3><h4 id="1-链表定义："><a href="#1-链表定义：" class="headerlink" title="1.链表定义："></a>1.链表定义：</h4><p>链式存储结构：结点在存储器中的位置是任意的（逻辑上相邻的数据元素在物理上不一定相邻）</p><p>链表特点：</p><ol><li>链表中<font color='#BAOC2F'>结点在存储器中的位置是任意的</font>，</li><li>访问链表时<font color='#BAOC2F'>只能通过头指针进入</font>并通过每个结点的指针域依次向后顺序扫描。</li><li>链表：顺序存取</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220828222621031.png" alt="image-20220828222621031"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220828212417045.png" alt="image-20220828212417045"></p><table><thead><tr><th>名词</th><th>解释</th></tr></thead><tbody><tr><td>头指针</td><td>是<font color='#BAOC2F'>指向链表中第一个结点</font>的指针</td></tr><tr><td>头结点</td><td>链表首元结点之前<font color='#BAOC2F'>附设</font>的一个结点</td></tr><tr><td>首元结点</td><td>链表中存储<font color='#BAOC2F'>第一个数据元素</font>a1的结点</td></tr></tbody></table><blockquote><p>注：链表中头结点中并不存储元素，<font color='#BAOC2F'>首元结点才是第一个存储元素</font>的结点！</p></blockquote><p>&#x3D;&#x3D;问题1：头结点设置的好处？&#x3D;&#x3D;</p><ol><li><p>便于首元结点的统一处理</p><p> 首元结点的地址保存在<font color='#BAOC2F'>头结点的指针中</font>，所以在链表的第一个位置上的操作与其他位置上的结点操作相同（<font color='#BAOC2F'>省去首结点特判处理</font>）</p></li><li><p>便于空表和非空表的统一处理</p><p> 无论链表是否为空，头指针都是指向头结点的非空指针（空表和非空表的处理相同）</p></li></ol><blockquote><p>注：这些优点只有在实际编程实现顺序表中才能真正体会，需要自己实现一遍顺序表的结构！</p></blockquote><p>&#x3D;&#x3D;问题2：头结点数据域中存放的是什么？&#x3D;&#x3D;</p><p>头结点的数据域可以为空，也可以存放线性表的长度、或者其他附加信息（但是该结点不能计入链表的长度length）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220828213417820.png" alt="image-20220828213417820"></p><h4 id="2-链表存储表示："><a href="#2-链表存储表示：" class="headerlink" title="2.链表存储表示："></a>2.链表存储表示：</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220828213630629.png" alt="image-20220828213630629"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> *next;<span class="comment">//指针域（指向结点的指针）</span></span><br><span class="line">&#125;Node, *LinkList;<span class="comment">//LinkList为指向结构体Node的指针类型（为头指针使用）</span></span><br><span class="line"></span><br><span class="line">LinkList L;<span class="comment">//1.定义链表L（开辟链表头指针）</span></span><br><span class="line">Node *p;<span class="comment">//2.定义指向结点的指针p</span></span><br></pre></td></tr></table></figure><h4 id="3-链表简单操作："><a href="#3-链表简单操作：" class="headerlink" title="3.链表简单操作："></a>3.链表简单操作：</h4><h5 id="（1）链表初始化："><a href="#（1）链表初始化：" class="headerlink" title="（1）链表初始化："></a>（1）链表初始化：</h5><p>单链表初始化即为<font color='#BAOC2F'>构造一个空表</font>：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220828221628897.png" alt="image-20220828221628897"></p><ol><li>生成一个新结点作为头结点，用头指针L指向头结点</li><li>将头结点的指针域置为NULL</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitLinkList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));<span class="comment">//L = new Node;</span></span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）链表置空："><a href="#（2）链表置空：" class="headerlink" title="（2）链表置空："></a>（2）链表置空：</h5><p>空链表：链表仍然存在，但链表中<font color='#BAOC2F'>没有元素</font>称为空链表（头指针和头结点仍然存在）</p><p>算法思路：依次释放所有结点，并将头结点指针域设置为空</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220828224003111.png" alt="image-20220828224003111"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ClearLinkList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    Node *p, *q;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;<span class="comment">//没有到达表尾则循环删除结点</span></span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;<span class="comment">//头结点指针域为空</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）链表判空："><a href="#（3）链表判空：" class="headerlink" title="（3）链表判空："></a>（3）链表判空：</h5><p>空链表：链表仍然存在，但链表中<font color='#BAOC2F'>没有元素</font>称为空链表（头指针和头结点仍然存在）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListEmpty</span><span class="params">(LinkList L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//L中还有元素非空表，则返回0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//L中没有元素为空表，则返回1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）求链表表长："><a href="#（4）求链表表长：" class="headerlink" title="（4）求链表表长："></a>（4）求链表表长：</h5><p>算法思路：从首结点开始，依次计数所有结点</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220828224804428.png" alt="image-20220828224804428"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LinkListLength</span><span class="params">(LinkList L)</span> </span>&#123;<span class="comment">//返回L中的数据元素个数</span></span><br><span class="line">    Node *p;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（5）链表销毁："><a href="#（5）链表销毁：" class="headerlink" title="（5）链表销毁："></a>（5）链表销毁：</h5><blockquote><p>注：销毁单链表<font color='#BAOC2F'>不可通过直接把头指针置空实现</font>，而是要依次释放所有的结点（<font color='#BAOC2F'>包括头结点</font>）</p></blockquote><p>算法思路：从头指针开始，依次释放掉所有结点</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220828225233345.png" alt="image-20220828225233345"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyLinkList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">while</span>(L) &#123;</span><br><span class="line">        p = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-链表重要操作："><a href="#4-链表重要操作：" class="headerlink" title="4.链表重要操作："></a>4.链表重要操作：</h4><h5 id="（1）头插法建立链表："><a href="#（1）头插法建立链表：" class="headerlink" title="（1）头插法建立链表："></a>（1）头插法建立链表：</h5><p>&#x3D;&#x3D;头插法图示&#x3D;&#x3D;：将新元素<font color='#BAOC2F'>插入到链表的头部</font>（与<font color='#BAOC2F'>结点的插入操作</font>十分相似）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220901174928820.png" alt="image-20220901174928820"></p><p>采用头插法建立单链表时，读入数据的顺序与生成链表的元素顺序是相反的（故这里需要<font color='#BAOC2F'>从e结点开始倒序输入</font>才能建立正序的链表）。</p><p>&#x3D;&#x3D;头插法步骤&#x3D;&#x3D;：</p><ol><li>建立一个空表</li><li>生成新结点，将读入数据存放到新结点的数据域中</li><li>依次将新结点插入到链表数据结点的最前端</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220901175614840.png" alt="image-20220901175614840"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for循环写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateLinkList</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    L = <span class="keyword">new</span> Node; L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">        p = <span class="keyword">new</span> Node;</span><br><span class="line">        cin &gt;&gt; p-&gt;data;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//while循环写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateLinkList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = <span class="keyword">new</span> Node; L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;<span class="comment">//输入9999表示结束插入</span></span><br><span class="line">        p = <span class="keyword">new</span> Node;</span><br><span class="line">        p-&gt;data = x;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">        </span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）尾插法建立链表："><a href="#（2）尾插法建立链表：" class="headerlink" title="（2）尾插法建立链表："></a>（2）尾插法建立链表：</h5><p>&#x3D;&#x3D;尾插法图示&#x3D;&#x3D;：将新元素<font color='#BAOC2F'>插入到链表的尾部</font>。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220901184639962.png" alt="image-20220901184639962"></p><p>采用尾插法建立单链表时，读入数据的顺序与生成链表的元素顺序是相同的（但是需要多增加一个尾指针<code>r</code>，使其始终指向尾结点）。</p><p>&#x3D;&#x3D;尾插法步骤&#x3D;&#x3D;：</p><ol><li>建立一个空表，创建尾指针r指向链表尾结点（开始时r同L均指向头结点）</li><li>生成新结点，将读入数据存放到新结点的数据域中</li><li>依次将新结点插入到链表数据结点的尾部</li><li>尾指针指向新节点</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220901183358245.png" alt="image-20220901183358245"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for循环写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateLinkList</span><span class="params">(LinkList &amp;L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    L = <span class="keyword">new</span> Node; L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Node *r = L;<span class="comment">//创建尾指针初始时指向头结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        Node *p = <span class="keyword">new</span> Node;</span><br><span class="line">        cin &gt;&gt; p-&gt;data;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        r = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//while循环写法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateLinkList</span><span class="params">(LinkList &amp;L)</span> </span>&#123;</span><br><span class="line">    L = <span class="keyword">new</span> Node; L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    Node *r = L;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">9999</span>) &#123;<span class="comment">//输入9999表示结束插入</span></span><br><span class="line">        p = <span class="keyword">new</span> Node;</span><br><span class="line">        p-&gt;data = x;</span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        r = p;</span><br><span class="line">        </span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）按序查找元素："><a href="#（3）按序查找元素：" class="headerlink" title="（3）按序查找元素："></a>（3）按序查找元素：</h5><p>根据单链表中元素的下标<code>i</code>，从指定位置获取数据（返回元素值or结点的地址）。</p><p>&#x3D;&#x3D;算法图示&#x3D;&#x3D;：从链表的头指针出发，顺着链域next逐个结点向下搜索，直至搜索到第<code>i</code>个结点为止（链表不是随机存取的结构）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220903165348952.png" alt="image-20220903165348952"></p><p>&#x3D;&#x3D;算法步骤&#x3D;&#x3D;：</p><ol><li>从第1个结点<code>L-&gt;next</code>顺链扫描，用指针p指向当前扫描到的结点（初始化为<code>p = L-&gt;next</code>）</li><li><code>j</code>做计数器累计当前扫描过的结点数（初始化<code>j=1</code>）</li><li>当p指向扫描到的下一结点，计数器<code>j+1</code></li><li>当<code>j==i</code>时，p所指的结点就是要寻找的第<code>i</code>个结点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法1:返回需要查找结点的值</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    Node *p = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!p || j &gt; i) <span class="keyword">return</span> ERROR;<span class="comment">//非法查找</span></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法2:返回需要查找结点</span></span><br><span class="line"><span class="function">Node *<span class="title">GetElem</span><span class="params">(LinkList L, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    Node *p = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">return</span> L;<span class="comment">//如果i=0则返回头结点</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//非法查找</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; j &lt; i) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）按值查找元素："><a href="#（4）按值查找元素：" class="headerlink" title="（4）按值查找元素："></a>（4）按值查找元素：</h5><p>根据<font color='#BAOC2F'>指定数据获取该数据所在的位置</font>（返回元素下标or结点的地址）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220903173124453.png" alt="image-20220903173124453"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法1:返回需要查找结点的下标</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    p = L-&gt;next;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;<span class="comment">//非法查找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法2:返回需要查找的结点</span></span><br><span class="line"><span class="function">Node *<span class="title">LocateElem</span><span class="params">(LinkList L, ElemType e)</span> </span>&#123;</span><br><span class="line">    Node *p = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != e) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（5）按序插入："><a href="#（5）按序插入：" class="headerlink" title="（5）按序插入："></a>（5）按序插入：</h5><p>&#x3D;&#x3D;算法图示&#x3D;&#x3D;：</p><p>在第<code>i</code>个结点前插入值为e的新结点</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220903174322777.png" alt="image-20220903174322777"></p><p>&#x3D;&#x3D;算法步骤&#x3D;&#x3D;：</p><ol><li>首先找到a<sub>i-1</sub>的存储位置<code>p</code></li><li>生成一个数据域为e的新节点<code>s</code></li><li>插入新的结点：①新结点的指针域指向结点a<sub>i</sub>：<code>s-&gt;next = p-&gt;next;</code>，②结点a<sub>i-1</sub>的指针域指向新结点：<code>p-&gt;next = s;</code></li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220903173744252.png" alt="image-20220903173744252"></p><blockquote><p>注：链表插入操作中的步骤①和步骤②是有先后顺序的，如果<font color='#BAOC2F'>交换顺序</font>将导致a<sub>i</sub>的<font color='#BAOC2F'>地址丢失</font>。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LinkListInsert</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    Node *p = L;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1.寻找第i个结点，将指针p指向其前驱</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || j &gt; i <span class="number">-1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.生成新的结点s并为其数据域赋值</span></span><br><span class="line">    Node *s = <span class="keyword">new</span> Node; s-&gt;data = e;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.进行结点插入操作</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（6）按序删除："><a href="#（6）按序删除：" class="headerlink" title="（6）按序删除："></a>（6）按序删除：</h5><p>&#x3D;&#x3D;算法图示&#x3D;&#x3D;：</p><p>删除第i个结点</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220903175838541.png" alt="image-20220903175838541"></p><p>&#x3D;&#x3D;算法步骤&#x3D;&#x3D;：</p><ol><li>首先找到a<sub>i-1</sub>的存储位置<code>p</code>，并保存要删除的a<sub>i</sub>值</li><li>令<code>p-&gt;next</code>指向a<sub>i+1</sub></li><li>释放结点a<sub>i</sub>的空间</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220903180106219.png" alt="image-20220903180106219"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Delete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> i, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    Node *p = L; <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//1.寻找第i个结点，将指针p指向其前驱</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span> &amp;&amp; j &lt; i - <span class="number">1</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == <span class="literal">NULL</span> || j &gt; i - <span class="number">1</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.保存元素值后进行删除操作</span></span><br><span class="line">    Node *q = p-&gt;next;</span><br><span class="line">    p-&gt;next = q-&gt;next;</span><br><span class="line">    e = q-&gt;data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.释放已经删除结点的内存</span></span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（7）按值删除："><a href="#（7）按值删除：" class="headerlink" title="（7）按值删除："></a>（7）按值删除：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221123174352480.png" alt="image-20221123174352480"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//while循环判定后 删除指定元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(LinkList &amp;L, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    Node *p = L;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;data == x) &#123;</span><br><span class="line">            Node *q = p-&gt;next;</span><br><span class="line">            p-&gt;next = q-&gt;next;</span><br><span class="line">            <span class="keyword">delete</span> q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>) p = p-&gt;next;<span class="comment">//若p指针指向尾元素则不进行自增操作（否则将p指针置空导致访问p-&gt;next非法空间）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-循环链表："><a href="#5-循环链表：" class="headerlink" title="5.循环链表："></a>5.循环链表：</h4><h5 id="（1）循环链表："><a href="#（1）循环链表：" class="headerlink" title="（1）循环链表："></a>（1）循环链表：</h5><p>循环链表是一种头尾相接的链表（表中<font color='#BAOC2F'>最后一个结点的指针域</font>指向<font color='#BAOC2F'>头结点</font>，整个链表形成一个环形）</p><p>循环链表的优点是从表中任一结点出发，均可找到表中的其他结点。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220903181243967.png" alt="image-20220903181243967"></p><p>由于循环链表中没有NULL指针，故涉及遍历操作时终止条件就不再是判断<code>p</code>或<code>p-&gt;next</code>是否为空，而是判断它们<font color='#BAOC2F'>是否等于头指针</font>。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220903181603258.png" alt="image-20220903181603258"></p><h5 id="（2）循环链表合并："><a href="#（2）循环链表合并：" class="headerlink" title="（2）循环链表合并："></a>（2）循环链表合并：</h5><p>&#x3D;&#x3D;算法图示&#x3D;&#x3D;：</p><p>将两<font color='#BAOC2F'>个带尾指针的循环链表</font>进行合并（将Tb合并在Ta）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220903185237547.png" alt="image-20220903185237547"></p><p>&#x3D;&#x3D;算法步骤&#x3D;&#x3D;：</p><blockquote><p>注：对链表的操作常常是在<font color='#BAOC2F'>表的首位位置上</font>进行的。</p></blockquote><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220903185718208.png" alt="image-20220903185718208"></p><ol><li>创建指针p保存表头结点<code>Node *p = La-&gt;next;</code></li><li>将Lb首元结点连接到La的表尾<code>La-&gt;next = Lb-&gt;next-&gt;next;</code></li><li>释放Lb的表头结点<code>delete Lb-&gt;next;</code></li><li>将Lb的尾结点指针指向La的表头<code>Lb-&gt;next = p;</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList <span class="title">LinkListConnect</span><span class="params">(LinkList La, LinkList Lb)</span> </span>&#123;</span><br><span class="line">    Node *p = La-&gt;next;</span><br><span class="line">    La-&gt;next = Lb-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> Lb-&gt;next;</span><br><span class="line">    Lb-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> Lb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：循环链表不设置头指针而<font color='#BAOC2F'>仅设置尾指针</font>，从而使得操作效率更高。循环链表合并的时间复杂度为O(1)</p></blockquote><h4 id="6-双向链表："><a href="#6-双向链表：" class="headerlink" title="6.双向链表："></a>6.双向链表：</h4><h5 id="（1）双向链表："><a href="#（1）双向链表：" class="headerlink" title="（1）双向链表："></a>（1）双向链表：</h5><p>在单链表的每个结点里再增加一个<font color='#BAOC2F'>指向其直接前驱</font>的指针域prior，称为双向链表。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220903190906758.png" alt="image-20220903190906758"></p><ul><li>在双向链表中有些操作如ListLength、GetElem等仅涉及一个方向的指针，故其算法与线性链表相同。</li><li>在双向链表中的插入insert、删除delete，则需要<font color='#BAOC2F'>同时修改两个方向上的指针</font>（两者的操作时间复杂度均为O(n)）</li></ul><h5 id="（2）双向链表插入："><a href="#（2）双向链表插入：" class="headerlink" title="（2）双向链表插入："></a>（2）双向链表插入：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220903191228765.png" alt="image-20220903191228765"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心操作</span></span><br><span class="line">s-&gt;prior = p-&gt;prior;</span><br><span class="line">p-&gt;prior-&gt;next = s;</span><br><span class="line">s-&gt;next = p;</span><br><span class="line">p-&gt;prior = s;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoubleLinkListInsert</span><span class="params">(DuLinkList &amp;L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在带头结点的双向链表L的第i个位置插入元素e</span></span><br><span class="line">    <span class="keyword">if</span> ((Node *p = <span class="built_in">GetElem</span>(L, i)) == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    Node *s = <span class="keyword">new</span> Node;</span><br><span class="line">    s-&gt;data = e;</span><br><span class="line">    </span><br><span class="line">    s-&gt;prior = p-&gt;prior;</span><br><span class="line">p-&gt;prior-&gt;next = s;</span><br><span class="line">s-&gt;next = p;</span><br><span class="line">p-&gt;prior = s;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）双向链表删除："><a href="#（3）双向链表删除：" class="headerlink" title="（3）双向链表删除："></a>（3）双向链表删除：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220903192354470.png" alt="image-20220903192354470"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心操作</span></span><br><span class="line">p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoubleLinkListDelete</span><span class="params">(DuLinkList &amp;L, <span class="type">int</span> i, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//删除带头结点的双向链表L的第i个元素，并用e返回</span></span><br><span class="line">    <span class="keyword">if</span> ((Node *p = <span class="built_in">GetElem</span>(L, i)) == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    </span><br><span class="line">    p-&gt;prior-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;各种链表间时间效率对比：&#x3D;&#x3D;</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220416082256365.png" alt="image-20220416082256365"></p><h3 id="四、顺序表与链表的比较："><a href="#四、顺序表与链表的比较：" class="headerlink" title="四、顺序表与链表的比较："></a>四、顺序表与链表的比较：</h3><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220416082816346.png" alt="image-20220416082816346"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220416082955287.png" alt="image-20220416082955287"></p><h3 id="五、线性表应用"><a href="#五、线性表应用" class="headerlink" title="五、线性表应用"></a>五、线性表应用</h3><h4 id="1-线性表的合并"><a href="#1-线性表的合并" class="headerlink" title="1.线性表的合并"></a>1.线性表的合并</h4><h5 id="（1）无序表的合并："><a href="#（1）无序表的合并：" class="headerlink" title="（1）无序表的合并："></a>（1）无序表的合并：</h5><p>&#x3D;&#x3D;问题描述&#x3D;&#x3D;：利用两个线性表La和Lb分别表示两个集合A与B，现要求一个新的集合A &#x3D; A∪B（无序）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220904171324204.png" alt="image-20220904171324204"></p><p>&#x3D;&#x3D;算法步骤&#x3D;&#x3D;：</p><ol><li>依次取出Lb中的每个元素</li><li>在La中查找取出的该Lb元素</li><li>如果查找不到则将其插入到La中的最后位置</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">union</span><span class="params">(List &amp;La, List Lb)</span> </span>&#123;</span><br><span class="line">    La_len = <span class="built_in">ListLength</span>(La);</span><br><span class="line">    Lb_len = <span class="built_in">ListLength</span>(Lb);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Lb_len; ++i) &#123;</span><br><span class="line">        <span class="built_in">GetElem</span>(Lb, i, e);<span class="comment">//查找元素</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">LocateElem</span>(La, e != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="built_in">ListInsert</span>(&amp;La, ++La_len, e);<span class="comment">//如果没有查找到元素则进行插入操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//算法复杂度为O(ListLength(La))*O(ListLength(Lb))</span></span><br></pre></td></tr></table></figure><h5 id="（2）有序表的合并："><a href="#（2）有序表的合并：" class="headerlink" title="（2）有序表的合并："></a>（2）有序表的合并：</h5><p>&#x3D;&#x3D;问题描述&#x3D;&#x3D;：已知线性表La和Lb中的数据元素按值非递减有序排列，现要求将La和Lb归并为一个新的线性表Lc，且元素仍非递减有序。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220904171407520.png" alt="image-20220904171407520"></p><p>&#x3D;&#x3D;算法步骤&#x3D;&#x3D;：</p><ol><li>创建一个空表Lc</li><li>依次从La或Lb中<font color='#BAOC2F'>摘取</font>元素较小的结点，插入到Lc表的最后直至其中一个表变成空表为止。</li><li>继续将La或Lb其中一个表的剩余结点插入在Lc表的最后</li></ol><p>&#x3D;&#x3D;顺序表实现有序表的合并&#x3D;&#x3D;：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList</span><span class="params">(SqList La, SqList Lb, SqList &amp;Lc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.准备指向有序数组首元素的各个指针</span></span><br><span class="line">    pa = La.elem;</span><br><span class="line">    pb = Lb.elem;</span><br><span class="line">    pc = Lc.elem;</span><br><span class="line">    Lc.length = La.length + Lb.length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.准备指向有序数组尾元素的指针</span></span><br><span class="line">    paLast = La.elem + La.length - <span class="number">1</span>;</span><br><span class="line">    pbLast = Lb.elem + Lb.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.依次摘取两表中较小的结点进行插入操作</span></span><br><span class="line">    <span class="keyword">while</span> (pa &lt;= paLast &amp;&amp; pb &lt;= pbLast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*pa &lt;= *pb) &#123;</span><br><span class="line">            *pc++ = *pa++; <span class="comment">//*pc = *pa; pc++; pa++;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *pc++ = *pb++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.将某一个表中剩余的元素全部添加到Lc中</span></span><br><span class="line">    <span class="keyword">while</span> (pa &lt;= paLast) *pc++ = *pa++;<span class="comment">//Lb到达表尾，将La中的元素全部加入Lc</span></span><br><span class="line">    <span class="keyword">while</span> (pb &lt;= pbLast) *pc++ = *pb++;<span class="comment">//La到达表尾，将Lb中的元素全部加入Lc</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//算法时间复杂度为O(ListLength(La)) + O(ListLength(Lb))</span></span><br><span class="line"><span class="comment">//算法空间复杂度为O(ListLength(La)) + O(ListLength(Lb))</span></span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;链表实现有序表合并&#x3D;&#x3D;：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeList</span><span class="params">(LinkList &amp;La, LinkList &amp;Lb, LinkList &amp;Lc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Stage1</span></span><br><span class="line">    pa = La-&gt;next;</span><br><span class="line">    pb = Lb-&gt;next;</span><br><span class="line">    pc = Lc = La;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Stage2 &amp; Stage3</span></span><br><span class="line">    <span class="keyword">while</span> (pa != <span class="literal">NULL</span> &amp;&amp; pb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pa-&gt;data &lt;= pb-&gt;data) &#123;</span><br><span class="line">            pc-&gt;next = pa;</span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pc-&gt;next = pb;</span><br><span class="line">            pc = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Stage4</span></span><br><span class="line">    pc-&gt;next = pa ? pa : pb;</span><br><span class="line">    <span class="keyword">delete</span> Lb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//算法时间复杂度O(ListLength(La) + ListLength(Lb))</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220904182930068.png" alt="image-20220904182930068"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220904182943760.png" alt="image-20220904182943760"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220904183002395.png" alt="image-20220904183002395"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220904183011135.png" alt="image-20220904183011135"></p><h4 id="2-线性表其他应用："><a href="#2-线性表其他应用：" class="headerlink" title="2.线性表其他应用："></a>2.线性表其他应用：</h4><h5 id="（1）密集多项式："><a href="#（1）密集多项式：" class="headerlink" title="（1）密集多项式："></a>（1）密集多项式：</h5><p>多项式的运算：实现两个多项式加&#x2F;减&#x2F;乘运算</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220905163727135.png" alt="image-20220905163727135"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220905164106557.png" alt="image-20220905164106557"></p><h5 id="（2）稀疏多项式："><a href="#（2）稀疏多项式：" class="headerlink" title="（2）稀疏多项式："></a>（2）稀疏多项式：</h5><p>如果同样按照密集多项式的存储方式来存储稀疏多项式，会导致出现空间严重浪费的情况，故<font color='#BAOC2F'>增加一个指数存储项</font>。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220905170843696.png" alt="image-20220905170843696"></p><p>&#x3D;&#x3D;算法步骤&#x3D;&#x3D;：</p><ol><li><p>创建一个新的数组c（用于存储多项式运算的结果多项式）</p></li><li><p>分别从头遍历比较数组a和数组b中的每一项</p><p> 若指数相同则将对应的系数相加，若其和不为零则在c中增加一个新的项（和为零则丢弃）</p><p> 若指数不同则将较小的项复制到c中</p></li><li><p>当一个多项式遍历完成时，将另一个剩余项依次复制到c中即可</p></li></ol><h5 id="（3）稀疏多项式操作："><a href="#（3）稀疏多项式操作：" class="headerlink" title="（3）稀疏多项式操作："></a>（3）稀疏多项式操作：</h5><p>&#x3D;&#x3D;存储方式的改进&#x3D;&#x3D;：按照密集多项式的存储方式并<font color='#BAOC2F'>增加一个指数存储项</font>来存储稀疏多项式还是有不足，可以改用<font color='#BAOC2F'>链式存储结构</font>来存储。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220905171803172.png" alt="image-20220905171803172"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220905172014060.png" alt="image-20220905172014060"></p><p>&#x3D;&#x3D;稀疏多项式创建&#x3D;&#x3D;：</p><ul><li>创建一个只有头结点的空链表</li><li>根据多项式的项的个数n，循环n次执行以下操作：<ol><li>生成一个新节点<code>*s</code></li><li>输入多项式当前项的系数和指数，赋给新的结点<code>*s</code>的数据域</li><li>设置一个前驱指针<code>pre</code>用于指向<font color='#BAOC2F'>待找到的第1个大于输入项指数</font>的结点的前驱，<code>pre</code>初始值指向头结点</li><li>指针q初始化指向首元结点</li><li>循链向下逐个比较<font color='#BAOC2F'>链表中当前结点</font>与<font color='#BAOC2F'>输入项的指数</font>，找到<font color='#BAOC2F'>第1个大于输入项指数</font>的结点<code>*q</code></li><li>将输入项结点<code>*s</code>插入到结点<code>*q</code>之前</li></ol></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePolyn</span><span class="params">(Polynomial &amp;Po, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    Po = <span class="keyword">new</span> PNode; Po-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        PNode *s = <span class="keyword">new</span> PNode;</span><br><span class="line">        cin &gt;&gt; s-&gt;coef &gt;&gt; s-&gt;expn;<span class="comment">//输入指数与系数</span></span><br><span class="line">        </span><br><span class="line">        PNode *pre = Po;</span><br><span class="line">        q = Po-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">NULL</span> &amp;&amp; q-&gt;expn &lt; s-&gt;expn) &#123;</span><br><span class="line">            pre = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;next = q;</span><br><span class="line">        pre-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;稀疏多项式相加操作&#x3D;&#x3D;：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220416124501790.png" alt="image-20220416124501790"></p><h5 id="（3）图书信息管理："><a href="#（3）图书信息管理：" class="headerlink" title="（3）图书信息管理："></a>（3）图书信息管理：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220905175035603.png" alt="image-20220905175035603"></p><ol><li>线性表中数据元素的类型可以为简单类型，也可以为复杂类型</li><li>许多实际应用问题所涉及的基本操作有很大的相似性，不应为每个具体应用单独编写程序。</li><li>从<font color='#BAOC2F'>具体应用</font>中抽象出<font color='#BAOC2F'>共性的逻辑结构和基本操作</font>（抽象数据类型），然后实现其存储结构和基本操作。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">char</span> id[<span class="number">20</span>];<span class="comment">//ISBN</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];<span class="comment">//书名</span></span><br><span class="line">    <span class="type">int</span> price;<span class="comment">//定价</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    Book *data;</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; BookSqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">    Book data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LNode</span> *next;</span><br><span class="line">&#125; LNode, *BookLinkList;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> datestructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> datestructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章：栈与队列</title>
      <link href="/2023/02/28/dataStructure/3.%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2023/02/28/dataStructure/3.%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章：栈与队列"><a href="#第三章：栈与队列" class="headerlink" title="第三章：栈与队列"></a>第三章：栈与队列</h1><hr><p>栈Stack和队列是线性表的子集，是限定<font color='#BAOC2F'>插入和删除只能在表的端点进行</font>的线性表。</p><h3 id="一、顺序栈"><a href="#一、顺序栈" class="headerlink" title="一、顺序栈"></a>一、顺序栈</h3><p>栈Stack是一个特殊的线性表，限定仅在一端（通常是表尾&#x2F;栈顶）进行插入和删除操作的线性表。</p><p>栈的特点：</p><ol><li>逻辑结构：与线性表相同</li><li>存储结构：用顺序栈或链栈均可，<font color='#BAOC2F'>顺序栈</font>更为常见</li><li>运算规则：只能在栈顶进行运算，访问结点时按照后进先出的LIFO原则</li><li>实现方式：关键在于入栈与出栈函数，具体实现顺序栈与链栈不同。</li></ol><p>栈的相关问题：</p><ol><li>数制转换</li><li>表达式求值</li><li>括号匹配的检验</li><li>八皇后问题</li><li>迷宫求解</li><li>函数调用</li><li>递归调用的实现</li><li>行编辑程序</li></ol><h4 id="1-顺序栈"><a href="#1-顺序栈" class="headerlink" title="1.顺序栈"></a>1.顺序栈</h4><h5 id="（1）顺序栈表示："><a href="#（1）顺序栈表示：" class="headerlink" title="（1）顺序栈表示："></a>（1）顺序栈表示：</h5><p>利用一组<font color='#BAOC2F'>地址连续的存储单元</font>依次存放自栈底到栈顶的数据元素，栈底一般在低地址端。</p><p><img src="https://s2.loli.net/2022/10/09/E2rUsXvLlPw5J6q.png" alt="image-20220912213118924"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="type">int</span> stackSize;</span><br><span class="line">&#125; SqStack;</span><br></pre></td></tr></table></figure><p>注意：使用数组作为顺序栈存储方式的简单方便，但是容易产生溢出现象（数组大小固定）</p><ul><li>上溢overflow：栈已满时同时又要push压入元素（上溢是一种错误，使得问题的处理无法进行）</li><li>下溢underflow：栈已空时同时又要pop弹出元素（下溢是一种结束条件，即问题处理的结束）</li></ul><p><img src="https://s2.loli.net/2022/10/09/uSrG7fHoK45JIqk.png" alt="image-20220912213242811"></p><h5 id="（2）顺序栈简单操作："><a href="#（2）顺序栈简单操作：" class="headerlink" title="（2）顺序栈简单操作："></a>（2）顺序栈简单操作：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作1：顺序栈判空</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作2：顺序栈清空</span></span><br><span class="line"><span class="function">Status <span class="title">ClearStack</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base != <span class="literal">NULL</span>) S.top = S.base;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作3：求顺序栈长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">StackLength</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S.top - S.base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作4：顺序栈销毁</span></span><br><span class="line"><span class="function">Status <span class="title">DestroyStack</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.base != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> S.base;</span><br><span class="line">        S.stacksize = <span class="number">0</span>;</span><br><span class="line">        S.base = S.top = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）顺序栈重要操作："><a href="#（3）顺序栈重要操作：" class="headerlink" title="（3）顺序栈重要操作："></a>（3）顺序栈重要操作：</h5><h6 id="lt-1-gt-顺序栈初始化："><a href="#lt-1-gt-顺序栈初始化：" class="headerlink" title="&lt;1&gt;顺序栈初始化："></a>&lt;1&gt;顺序栈初始化：</h6><ol><li>开辟连续的内存空间</li><li>将栈顶指针指向栈底指针</li><li>初始化栈的容量大小</li></ol><p><img src="https://s2.loli.net/2022/10/09/j6h2S3BFUckg1rV.png" alt="image-20220912221110647"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span> </span>&#123;</span><br><span class="line">    S.base = <span class="keyword">new</span> SElemType[MAXSIZE];</span><br><span class="line">    S.base = (SElemType*)<span class="built_in">malloc</span>(MAXSIZE*<span class="built_in">sizeof</span>(SElemType));</span><br><span class="line">    <span class="keyword">if</span> (!S.base) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//内存开辟失败则直接返回OVERFLOW</span></span><br><span class="line">    </span><br><span class="line">    S.top = S.base;</span><br><span class="line">    S.stackSize = MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="lt-2-gt-顺序栈入栈："><a href="#lt-2-gt-顺序栈入栈：" class="headerlink" title="&lt;2&gt;顺序栈入栈："></a>&lt;2&gt;顺序栈入栈：</h6><ol><li>判断栈是否已满（栈已满则为上溢出）</li><li>元素e压入栈顶</li><li>栈顶指针加1</li></ol><p><img src="https://s2.loli.net/2022/10/09/qtYrJwpCGHyB4PU.png" alt="image-20220912222315370"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack &amp;S, SElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top - S.base == S.stackSize) <span class="keyword">return</span> ERROR;<span class="comment">//栈已满上溢出</span></span><br><span class="line">    *S.top = e;</span><br><span class="line">    S.top++;</span><br><span class="line">    <span class="comment">//*S.top++ = e;</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="lt-3-gt-顺序栈出栈："><a href="#lt-3-gt-顺序栈出栈：" class="headerlink" title="&lt;3&gt;顺序栈出栈："></a>&lt;3&gt;顺序栈出栈：</h6><ol><li>判定栈是否为空（栈已空则为下溢出）</li><li>获取栈顶元素e</li><li>栈顶元素减1</li></ol><p><img src="https://s2.loli.net/2022/10/09/E6uRg2D5UhxMLp4.png" alt="image-20220912222236813"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack &amp;S, SElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == S.base) <span class="keyword">return</span> ERROR;<span class="comment">//栈下溢出</span></span><br><span class="line">    S.top--;</span><br><span class="line">    e = *S.top;</span><br><span class="line">    <span class="comment">//e = *--S.top;</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-链栈"><a href="#2-链栈" class="headerlink" title="2.链栈"></a>2.链栈</h4><h5 id="（1）链栈表示："><a href="#（1）链栈表示：" class="headerlink" title="（1）链栈表示："></a>（1）链栈表示：</h5><ol><li>链栈的头指针就是栈顶，且其<font color='#BAOC2F'>不需要头结点</font>。</li><li>链栈上不存在栈满的情况、空栈相当于头指针指向空。</li></ol><p><img src="https://s2.loli.net/2022/10/09/mOJgrGQqYzlAfs7.png" alt="image-20220912223249224"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StackNode</span> &#123;</span><br><span class="line">    SElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">StackNode</span> *next;</span><br><span class="line">&#125; StackNode, *LinkStack;</span><br><span class="line">LinkStack S;</span><br></pre></td></tr></table></figure><h5 id="（2）链栈简单操作："><a href="#（2）链栈简单操作：" class="headerlink" title="（2）链栈简单操作："></a>（2）链栈简单操作：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作1：链栈初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(LinkStack &amp;S)</span> </span>&#123;</span><br><span class="line">    S = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作2：链栈判空</span></span><br><span class="line"><span class="function">Status <span class="title">StackEmpty</span><span class="params">(LinkStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ture;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作3：取栈顶元素</span></span><br><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(LinkStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）链栈重要操作："><a href="#（3）链栈重要操作：" class="headerlink" title="（3）链栈重要操作："></a>（3）链栈重要操作：</h5><h6 id="lt-1-gt-链栈入栈："><a href="#lt-1-gt-链栈入栈：" class="headerlink" title="&lt;1&gt;链栈入栈："></a>&lt;1&gt;链栈入栈：</h6><p><img src="https://s2.loli.net/2022/10/09/WXxjyc921Pi4I8O.png" alt="image-20220912224139622"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(LinkStack &amp;S, SElemType e)</span> </span>&#123;</span><br><span class="line">    StackNode *p = <span class="keyword">new</span> StackNode;</span><br><span class="line">    p-&gt;data = e;</span><br><span class="line">    p-&gt;next = S;</span><br><span class="line">    S = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="lt-2-gt-链栈出栈："><a href="#lt-2-gt-链栈出栈：" class="headerlink" title="&lt;2&gt;链栈出栈："></a>&lt;2&gt;链栈出栈：</h6><p><img src="https://s2.loli.net/2022/10/09/ey5Np7nTUsZfrQX.png" alt="image-20220912224528244"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(LinkStack &amp;S, SElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S == <span class="literal">NULL</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    e = S-&gt;data;</span><br><span class="line">    StackNode *p = S;</span><br><span class="line">    S = S-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、顺序队列"><a href="#二、顺序队列" class="headerlink" title="二、顺序队列"></a>二、顺序队列</h3><p>队列是一种先进先出的线性表，在表的尾部插入、表头删除。</p><p>队列特点：</p><ol><li>逻辑结构：与线性表相同</li><li>存储结构：用顺序队列或链队列均可，<font color='#BAOC2F'>循环队列</font>更为常见。</li><li>运算规则：只能在队首和队尾进行运算，访问结点时按照先进先出的FIFO原则</li><li>实现方式：关键在于入队与出队函数，具体实现顺序队列与链队列不同。</li></ol><p>队列的相关问题：</p><ol><li>脱机打印输出：按申请的先后顺序依次输出</li><li>多用户系统中：多个用户排成对，分时地循环使用CPU和主存。</li><li>按照用户的优先级排成多个队，每个优先级一个队列。</li><li>实时控制系统中：信号按接收的先后顺序依次处理</li><li>网络电文传输：按照到达的时间先后顺序依次进行。</li></ol><h4 id="1-顺序队列："><a href="#1-顺序队列：" class="headerlink" title="1.顺序队列："></a>1.顺序队列：</h4><h5 id="（1）顺序队列表示："><a href="#（1）顺序队列表示：" class="headerlink" title="（1）顺序队列表示："></a>（1）顺序队列表示：</h5><p>队列的顺序表示用一维数组base[MAXQSIZE]存储</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIEZ 100</span></span><br><span class="line">Typedef <span class="keyword">struct</span> &#123;</span><br><span class="line">    QElemType *base;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/10/09/a6fmRPbrqzk4OQL.png" alt="image-20220420072340683"></p><h5 id="（2）循环顺序队列表示："><a href="#（2）循环顺序队列表示：" class="headerlink" title="（2）循环顺序队列表示："></a>（2）循环顺序队列表示：</h5><p>顺序队列存在两个问题：</p><ul><li>问题1：若front&#x3D;0，rear&#x3D;MAXQSIZE时再有元素入队，则会出现真溢出现象（进行扩容操作）</li><li>问题2：若front!&#x3D;0，rear&#x3D;MAXQSIZE时再有元素入队，则会出现真溢出现象（将顺序队列改为循环顺序队列）</li></ul><p><img src="https://s2.loli.net/2022/10/09/DuMPLOaAqw6CxHX.png" alt="image-20221008090152582"></p><p>&#x3D;&#x3D;顺序队列中假溢出问题的解决&#x3D;&#x3D;：引入循环队列</p><p>将队空间想象成为一个循环的表，分配给队列的m个存储单元可以循环使用，当rear为maxqsize时若顺序队的开始端还空着（假溢出），又可从头使用空着的空间。即将base[0]接在base[MAXQSIZE-1]之后，若<code>rear+1 == M</code>则令<code>rear=0</code>，利用mod模运算实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环队列插入元素</span></span><br><span class="line">Q.base[Q.rear] = x;</span><br><span class="line">Q.rear = (Q.rear + <span class="number">1</span>) % MAXQSIZE;</span><br><span class="line"><span class="comment">//循环队列删除元素</span></span><br><span class="line">x = Q.base[Q.front];</span><br><span class="line">Q.front = (Q.front + <span class="number">1</span>) % MAXQSIZE;</span><br></pre></td></tr></table></figure><p>循环队列判空or队满的判定：</p><ol><li>另外设置一个标志用于区别队空&amp;队满</li><li>另外设置一个变量count，用于记录元素个数</li><li>少使用一个元素空间</li></ol><p><img src="https://s2.loli.net/2022/10/09/uFr7lNtodm5gSzp.png" alt="image-20221008093732030"></p><p>循环队列的类型定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType *base;<span class="comment">//动态分配存储空间</span></span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125; SqQueue;</span><br></pre></td></tr></table></figure><h5 id="（3）循环顺序队列重要操作："><a href="#（3）循环顺序队列重要操作：" class="headerlink" title="（3）循环顺序队列重要操作："></a>（3）循环顺序队列重要操作：</h5><h6 id="lt-1-gt-顺序队初始化："><a href="#lt-1-gt-顺序队初始化：" class="headerlink" title="&lt;1&gt;顺序队初始化："></a>&lt;1&gt;顺序队初始化：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    Q.base = (ElemType*)<span class="built_in">malloc</span>(MAXQSIZE*<span class="built_in">sizeof</span>(ElemType));<span class="comment">//Q.base = new ElemType[MAXQSIZE];</span></span><br><span class="line">    <span class="keyword">if</span>(!Q.base) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="lt-2-gt-顺序队求长度："><a href="#lt-2-gt-顺序队求长度：" class="headerlink" title="&lt;2&gt;顺序队求长度："></a>&lt;2&gt;顺序队求长度：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((Q.rear - Q.front + MAXQSIZE) % MAXQSIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="lt-3-gt-顺序队入队："><a href="#lt-3-gt-顺序队入队：" class="headerlink" title="&lt;3&gt;顺序队入队："></a>&lt;3&gt;顺序队入队：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>) % MAXQSIZE == Q.front) <span class="keyword">return</span> ERRPR;<span class="comment">//队满</span></span><br><span class="line">    Q.base[Q.rear] = e;<span class="comment">//新元素加入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MAXQSIZE;<span class="comment">//队尾指针+1</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="lt-4-gt-顺序队出队："><a href="#lt-4-gt-顺序队出队：" class="headerlink" title="&lt;4&gt;顺序队出队："></a>&lt;4&gt;顺序队出队：</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;<span class="comment">//队空</span></span><br><span class="line">    e = Q.base[Q.front];<span class="comment">//保存队头元素</span></span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAXQSIZE;<span class="comment">//队头指针+1</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-链队列："><a href="#2-链队列：" class="headerlink" title="2.链队列："></a>2.链队列：</h4><h5 id="（1）链队列表示："><a href="#（1）链队列表示：" class="headerlink" title="（1）链队列表示："></a>（1）链队列表示：</h5><p>若用户无法确定所用队列的长度时，则应该采用链队列：</p><p><img src="https://s2.loli.net/2022/10/09/t5uszLhTfxyEkid.png" alt="image-20221008095622496"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> *next;<span class="comment">//递归定义</span></span><br><span class="line">&#125; Node, QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    QueuePtr front;</span><br><span class="line">    QueuePtr rear;</span><br><span class="line">&#125; LinkQueue;</span><br></pre></td></tr></table></figure><h5 id="（2）链队列重要操作："><a href="#（2）链队列重要操作：" class="headerlink" title="（2）链队列重要操作："></a>（2）链队列重要操作：</h5><h6 id="lt-1-gt-链队初始化："><a href="#lt-1-gt-链队初始化：" class="headerlink" title="&lt;1&gt;链队初始化："></a>&lt;1&gt;链队初始化：</h6><p><img src="https://s2.loli.net/2022/10/09/5ZUFcXnPhuHdpmN.png" alt="image-20221008100342583"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">Q.front = Q.rear = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(!Q.front) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    Q.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="lt-2-gt-链队的销毁："><a href="#lt-2-gt-链队的销毁：" class="headerlink" title="&lt;2&gt;链队的销毁："></a>&lt;2&gt;链队的销毁：</h6><p>从队头结点开始，依次释放所有的结点</p><p><img src="https://s2.loli.net/2022/10/09/cuNp1gqYwFHO5jm.png" alt="image-20221008101033737"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    QueuePtr temp;<span class="comment">//辅助指针</span></span><br><span class="line">    <span class="keyword">while</span>(Q.front) &#123;</span><br><span class="line">        temp = Q.front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(Q.front);</span><br><span class="line">        Q.front = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DestroyQueue</span><span class="params">(LinkQueue &amp;Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(Q.front) &#123;<span class="comment">//直接用队尾指针作为辅助指针</span></span><br><span class="line">        Q.rear = Q.front-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(Q.front);</span><br><span class="line">        Q.front = Q.rear;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="lt-3-gt-链队入队："><a href="#lt-3-gt-链队入队：" class="headerlink" title="&lt;3&gt;链队入队："></a>&lt;3&gt;链队入队：</h6><p>链队列从队尾入队，</p><p><img src="https://s2.loli.net/2022/10/09/WMjkE2rxJF6CeA4.png" alt="image-20221008101550458"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType e)</span> </span>&#123;</span><br><span class="line">    QueuePtr p = (QueuePtr)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="built_in">exit</span>(OVERFLOW);</span><br><span class="line">    p-&gt;data = e; p-&gt;next = <span class="literal">NULL</span>;<span class="comment">//初始化入队结点</span></span><br><span class="line">    Q.rear-&gt;next = p;</span><br><span class="line">    Q.rear = p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="lt-4-gt-链队出队："><a href="#lt-4-gt-链队出队：" class="headerlink" title="&lt;4&gt;链队出队："></a>&lt;4&gt;链队出队：</h6><p>链队列从队头出队，</p><p><img src="https://s2.loli.net/2022/10/09/9bl4soQ8jfqXIZF.png" alt="image-20221008102737451"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> ERROR;<span class="comment">//队空</span></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    QueuePtr p = Q.front-&gt;next;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;<span class="comment">//Q.front-&gt;next = Q.front-&gt;next-&gt;next;</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p) Q.rear = Q.front;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、栈和队列应用"><a href="#三、栈和队列应用" class="headerlink" title="三、栈和队列应用"></a>三、栈和队列应用</h3><h4 id="1-进制转换："><a href="#1-进制转换：" class="headerlink" title="1.进制转换："></a>1.进制转换：</h4><p>十进制整数n向d进制数进行转换，基本的转换法则为<font color='#BAOC2F'>n除以进制数d得到余数序列后翻转</font>：<code>n = (n div d) * d + n mod d;</code></p><p><img src="https://s2.loli.net/2022/10/09/ZaF5sTUvCtGzRXl.png" alt="image-20221008104458886"></p><p>&#x3D;&#x3D;算法步骤&#x3D;&#x3D;：</p><ol><li><p>初始化一个栈S</p></li><li><p>当十进制数N非零时，循环执行以下操作：</p><p> 将N与d求余得到d进制数压入栈S</p><p> N更新为N与d的商</p></li><li><p>当栈S非空时，循环执行以下操作：</p><p> 弹出栈顶元素e</p><p> 输出e</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">conversion</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="keyword">while</span> (num) &#123;</span><br><span class="line">        <span class="built_in">Push</span>(S, num % d);</span><br><span class="line">        num = num / d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">StackEmpty</span>(S)) &#123;</span><br><span class="line">        <span class="built_in">Pop</span>(S, e);</span><br><span class="line">        cout &lt;&lt; e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-括号匹配检测："><a href="#2-括号匹配检测：" class="headerlink" title="2.括号匹配检测："></a>2.括号匹配检测：</h4><p>假设表达式中允许包含两种括号：圆括号和方括号，且括号嵌套的顺序随意：</p><ol><li><code>([]())</code>或<code>[([][])]</code>为正确格式</li><li><code>[(])</code>为错误格式</li><li><code>([())</code>或<code>(()])</code>为错误格式</li></ol><p><img src="https://s2.loli.net/2022/10/09/FLlPiRaIdr4JNO7.png" alt="image-20221008132223028"></p><ul><li>习题：<a href="https://leetcode.cn/problems/valid-parentheses/">LeetCode20:valid-parentheses有效的括号</a></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Matching</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    flag = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;#&#x27;</span>&amp;&amp;flag) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span> || <span class="string">&#x27;(&#x27;</span> :</span><br><span class="line">                <span class="built_in">Push</span>(S, ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span> :</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">StackEmpty</span>(S) &amp;&amp; <span class="built_in">GetTop</span>(S) == <span class="string">&#x27;(&#x27;</span>) <span class="built_in">Pop</span>(S, x);</span><br><span class="line">                <span class="keyword">else</span> flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span> :</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">StackEmpty</span>(S) &amp;&amp; <span class="built_in">GetTop</span>(S) == <span class="string">&#x27;[&#x27;</span>) <span class="built_in">Pop</span>(S, x);</span><br><span class="line">                <span class="keyword">else</span> flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">StackEmpty</span>(S) &amp;&amp; flag) &#123;<span class="comment">//匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//匹配失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="type">char</span> *base;</span><br><span class="line">  <span class="type">int</span> top;</span><br><span class="line">  <span class="type">int</span> stackSize;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(Stack &amp;s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  s.base = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">100000</span>];</span><br><span class="line">  <span class="comment">// s-&gt;base = (int *)malloc(sizeof(int) * n);</span></span><br><span class="line">  <span class="comment">// s-&gt;base = malloc(stackSize);</span></span><br><span class="line">  s.stackSize = n;</span><br><span class="line">  s.top = <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EmptyStack</span><span class="params">(Stack &amp;s)</span> </span>&#123; <span class="keyword">return</span> s.top == <span class="number">-1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PushStack</span><span class="params">(Stack &amp;s, <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">  s.top++;</span><br><span class="line">  s.base[s.top] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PopStack</span><span class="params">(Stack &amp;s)</span> </span>&#123; s.top--; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">GetTop</span><span class="params">(Stack &amp;s)</span> </span>&#123; <span class="keyword">return</span> s.base[s.top]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">  Stack stack;</span><br><span class="line">  <span class="built_in">InitStack</span>(stack, len);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (s[i]) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">        <span class="built_in">PushStack</span>(stack, s[i]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">EmptyStack</span>(stack)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetTop</span>(stack) != <span class="string">&#x27;(&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">PopStack</span>(stack);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">EmptyStack</span>(stack)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetTop</span>(stack) != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">PopStack</span>(stack);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">EmptyStack</span>(stack)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">GetTop</span>(stack) != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">PopStack</span>(stack);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">EmptyStack</span>(stack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">1000</span>];</span><br><span class="line">  cin &gt;&gt; s;</span><br><span class="line">  cout &lt;&lt; s &lt;&lt; <span class="string">&quot;isValid : &quot;</span> &lt;&lt; <span class="built_in">isValid</span>(s) &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-表达式求值："><a href="#3-表达式求值：" class="headerlink" title="3.表达式求值："></a>3.表达式求值：</h4><p>表达式求值是程序设计语言编译中的一个最基本的问题，其实现也需要运用栈。</p><ul><li>思路1：先将表达式转换成为后缀表达式，然后求后缀表达式的值</li><li>思路2：利用表达式中运算符的优先级确定运算顺序，然后对表达式求值（算符优先算法）</li></ul><p><img src="https://s2.loli.net/2022/10/09/Hj9B2hGuzxyr5nC.png" alt="image-20221009104657232"></p><p><img src="https://s2.loli.net/2022/10/09/OhZRLF5GMgXJ9dW.png" alt="image-20221009105025659"></p><ul><li>表达式求值：<a href="https://blog.csdn.net/Linux518/article/details/119063415">https://blog.csdn.net/Linux518/article/details/119063415</a></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> <span class="title">EvaluateExpression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">InitStack</span>(OPND);</span><br><span class="line">    <span class="built_in">InitStack</span>(OPTR);</span><br><span class="line">    <span class="built_in">Push</span>(OPTR, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">    cin &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;#&#x27;</span> || <span class="built_in">GetTop</span>(OPTR) != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">In</span>(ch)) &#123;</span><br><span class="line">            <span class="built_in">Push</span>(OPND, ch);</span><br><span class="line">            cin &gt;&gt; ch;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span>(<span class="built_in">Precede</span>(<span class="built_in">GetTop</span>(OPTR), ch)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">EmptyStack</span>(stack)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">GetTop</span>(stack) != <span class="string">&#x27;&#123;&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">PopStack</span>(stack);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">EmptyStack</span>(stack)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">GetTop</span>(stack) != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">PopStack</span>(stack);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">EmptyStack</span>(stack)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">GetTop</span>(stack) != <span class="string">&#x27;[&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">PopStack</span>(stack);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">GetTop</span>(OPND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-舞伴问题："><a href="#4-舞伴问题：" class="headerlink" title="4.舞伴问题："></a>4.舞伴问题：</h4><p>假设在舞会上男士与女士各自排成一队，舞会开始时依次从男队和女队的队头各出一人配成舞伴，</p><p>如果两队初始人数不相同，则较长的那一队中未匹配者等待下一轮舞曲，要求写一算法模拟上述舞伴配对问题：</p><p>&#x3D;&#x3D;问题分析&#x3D;&#x3D;：显然先入队的男士or女士先出队配成舞伴，因此该问题具有典型的FIFO先进先出特性，可以用队列作为算法的数据结构。</p><ol><li>首先构造出两个队列</li><li>依次将队头元素出队配成舞伴</li><li>某队为空，则另外一队等待者则是下一轮舞曲第一个可获得舞伴的人。</li></ol><p><img src="https://s2.loli.net/2022/10/09/lTfdtK5sWguNwb8.png" alt="image-20221008133719424"></p><ul><li>舞伴问题：<a href="https://blog.csdn.net/Linux518/article/details/119116020">https://blog.csdn.net/Linux518/article/details/119116020</a></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">char</span> sex;</span><br><span class="line">&#125; Person;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXQSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    Person *base;</span><br><span class="line">    <span class="type">int</span> front;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">&#125; SqQueue;</span><br><span class="line"></span><br><span class="line">SqQueue Mdancers, Fdancers;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DancePartner</span><span class="params">(Person dancer[], <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">InitQueue</span>(Mdancers);</span><br><span class="line">    <span class="built_in">InitQueue</span>(Fdancers);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">        p = dancer[i];</span><br><span class="line">        <span class="keyword">if</span> (p.sex == <span class="string">&#x27;F&#x27;</span>) <span class="built_in">EnQueue</span>(Fdancers, p);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">EnQueue</span>(Mdancers, p);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The dancing partner ars : \n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">QueueEmpty</span>(Fdancers) &amp;&amp; !<span class="built_in">QueueEmpty</span>(Mdancers)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Fdancers, p);</span><br><span class="line">        cout &lt;&lt; p.name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Mdancers, p);</span><br><span class="line">        cout &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">QueueEmpty</span>(Fdancers)) &#123;</span><br><span class="line">        p = <span class="built_in">GetHead</span>(Fdancers);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The first woman to get a partner is : &quot;</span> &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">QueueEmpty</span>(Mdancers)) &#123;</span><br><span class="line">        p = <span class="built_in">GetHead</span>(Mdancers);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The first man to get a partner is : &quot;</span> &lt;&lt; p.name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、栈与递归"><a href="#四、栈与递归" class="headerlink" title="四、栈与递归"></a>四、栈与递归</h3><ul><li>递归对象：若一个<font color='#BAOC2F'>对象部分地包含它自己</font>，或<font color='#BAOC2F'>用它自己给自己定义</font>，则称这个对象是递归的。</li><li>递归过程：若一个<font color='#BAOC2F'>过程直接地或间接地调用自己</font>，则称这个过程是递归的过程。（例如递归求n的阶乘）</li></ul><h4 id="1-数学函数："><a href="#1-数学函数：" class="headerlink" title="1.数学函数："></a>1.数学函数：</h4><p><img src="https://s2.loli.net/2022/10/09/Eg1ovX3fYWVh9UL.png" alt="image-20221009082527347"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阶乘函数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">Fact</span><span class="params">(<span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="built_in">Fact</span>(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Fibonaci数列</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">Fibonaci</span><span class="params">(<span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Fib</span>(n - <span class="number">1</span>) + <span class="built_in">Fib</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-递归问题集："><a href="#2-递归问题集：" class="headerlink" title="2.递归问题集："></a>2.递归问题集：</h4><p>这类问题虽然本身没有明显的递归结构，但用递归求解比迭代求解更简单，如Hanoi塔问题、八皇后问题、迷宫问题等。</p><p><img src="https://s2.loli.net/2022/10/09/lEWLjTuFvpdM6Vs.png" alt="image-20221009082956162"></p><ul><li><p>迷宫问题：<a href="https://blog.csdn.net/Ahaooooooo/article/details/124859383">https://blog.csdn.net/Ahaooooooo/article/details/124859383</a></p></li><li><p>Hanoi塔问题：<a href="https://blog.csdn.net/weixin_64171647/article/details/122141933">https://blog.csdn.net/weixin_64171647&#x2F;article&#x2F;details&#x2F;122141933</a></p></li><li><p>八皇后问题：<a href="https://blog.csdn.net/codes_first/article/details/78474226">https://blog.csdn.net/codes_first&#x2F;article&#x2F;details&#x2F;78474226</a></p></li></ul><h4 id="3-递归算法分析："><a href="#3-递归算法分析：" class="headerlink" title="3.递归算法分析："></a>3.递归算法分析：</h4><blockquote><p>分治法：对于一个较为复杂的问题，能够分解成一个<font color='#BAOC2F'>相对简单的且解法相同或类似的子问题</font>来求解。</p></blockquote><p>&#x3D;&#x3D;递归的3个特点&#x3D;&#x3D;：</p><ol><li>能将一个问题转变成为一个新问题，而新问题与原问题的解法相同or类同（不同的仅是处理的对象，且这些对象都是规律变化的）</li><li>可以通过上述转化而使问题简化</li><li>必须有一个明确的递归出口（递归的边界）</li></ol><h5 id="（1）递归程序："><a href="#（1）递归程序：" class="headerlink" title="（1）递归程序："></a>（1）递归程序：</h5><p>归纳分治法求解递归问题的<font color='#BAOC2F'>普遍形式</font>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Recur</span><span class="params">(Parameter table1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (End of recursion condition) &#123;</span><br><span class="line">        Steps that solve the problem directly;<span class="comment">//The Basic items</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Recur</span>(Parameter table2);<span class="comment">//The Inductive item</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（2）递归与栈："><a href="#（2）递归与栈：" class="headerlink" title="（2）递归与栈："></a>（2）递归与栈：</h5><p><img src="https://s2.loli.net/2022/10/09/nEl1H8A64CXwtBN.png" alt="image-20220420224801084"></p><ol><li>递归工作栈：递归程序运行期间使用的<font color='#BAOC2F'>数据存储区</font>。</li><li>工作记录：实际参数、局部变量、返回地址</li></ol><h5 id="（3）递归优化："><a href="#（3）递归优化：" class="headerlink" title="（3）递归优化："></a>（3）递归优化：</h5><table>    <tr>        <td>递归的优点</td>        <td>结构清晰，程序易读</td>    </tr>    <tr>        <td>递归的缺点</td>        <td>每次调用要生成工作记录、保存状态信息，入栈；返回时要出栈，恢复状态信息，<font color='#BAOC2F'>时间开销较大</font>。</td>    </tr></table><p>&#x3D;&#x3D;递归的优化方式1&#x3D;&#x3D;：尾递归&#x2F;单向递归，改为循环结构实现递归优化</p><ul><li>尾递归改为循环结构：以求阶乘为例</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾递归</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">Fact</span><span class="params">(<span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="built_in">Fact</span>(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环结构</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">Fact</span><span class="params">(<span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        temp = temp * i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>单向递归改为循环结构：以求fabonaci数列为例</li></ul><p>虽然有多处的递归调用语句，但<font color='#BAOC2F'>各次递归调用语句</font>的参数<font color='#BAOC2F'>只和主调函数有关</font>，相互参数无关，并且这些递归调用语句处于算法的最后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单向递归</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">Fibonaci</span><span class="params">(<span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Fib</span>(n - <span class="number">1</span>) + <span class="built_in">Fib</span>(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环结构</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">Fibonaci</span><span class="params">(<span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> c;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;递归的优化方式2&#x3D;&#x3D;：<font color='#BAOC2F'>自用栈</font>模拟系统的<font color='#BAOC2F'>运行时栈</font>（借助栈改写递归）</p><p>递归程序在执行时需要<font color='#BAOC2F'>系统提供栈</font>来实现，仿照<font color='#BAOC2F'>递归算法执行过程</font>中<font color='#BAOC2F'>递归工作栈的状态变化</font>可写出相应的非递归程序，</p><p>改写后的非递归算法与原来的递归算法相比，结构不够清晰、可读性较差、有的还需要经过一系列优化。</p><ol><li>设置一个工作栈存放递归工作记录（包括实参、返回地址以及局部变量等）</li><li>进入非递归调用入口（即被调用程序开始处）：将调用<font color='#BAOC2F'>程序传来的实参</font>和<font color='#BAOC2F'>返回地址</font>入栈（递归程序不可以作为主程序，因而可认为初始时被某个调用程序调用）</li><li>进入递归调用入口：当不满足递归结束条件时逐层递归，将实参、返回地址以及局部变量入栈（这一过程可用循环语句来实现，模拟递归分解的过程）</li><li>递归结束条件满足：将到达递归出口的给定常数作为当前的函数值</li><li>返回处理：在栈不空的情况下<font color='#BAOC2F'>反复退出栈顶记录</font>，根据<font color='#BAOC2F'>记录中的返回地址</font>进行题意规定的操作。（即逐层计算当前函数值，直至栈空为止，模拟递归求值过程）</li></ol>]]></content>
      
      
      <categories>
          
          <category> datestructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> datestructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章：串与数组</title>
      <link href="/2023/02/28/dataStructure/4.%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%B8%B2%E4%B8%8E%E6%95%B0%E7%BB%84/"/>
      <url>/2023/02/28/dataStructure/4.%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%B8%B2%E4%B8%8E%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="第四章：串与数组"><a href="#第四章：串与数组" class="headerlink" title="第四章：串与数组"></a>第四章：串与数组</h1><hr><h3 id="一、串"><a href="#一、串" class="headerlink" title="一、串"></a>一、串</h3><p>String串是指零个or多个任意字符串组成的有限序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ADT String &#123;</span><br><span class="line">    数据对象：</span><br><span class="line">    数据关系：</span><br><span class="line">    基本操作：</span><br><span class="line">        <span class="built_in">StrAssign</span>(&amp;T, chars);</span><br><span class="line">        <span class="built_in">StrCompare</span>(S, T);</span><br><span class="line">    <span class="built_in">StrLength</span>(s);</span><br><span class="line">    <span class="built_in">Concat</span>(&amp;T, S1, S2);</span><br><span class="line">    <span class="built_in">SubString</span>(&amp;Sub, S, pos, len);</span><br><span class="line">    <span class="built_in">StrCopy</span>(&amp;T, S);</span><br><span class="line">        <span class="built_in">StrEmpty</span>(S);</span><br><span class="line">    <span class="built_in">ClearString</span>(&amp;S);</span><br><span class="line">    <span class="built_in">Index</span>(S, T, pos);<span class="comment">//字符串匹配算法</span></span><br><span class="line">        <span class="built_in">Replace</span>(&amp;S, T, V);</span><br><span class="line">    <span class="built_in">StrInsert</span>(&amp;S, pos, T);</span><br><span class="line">    <span class="built_in">StrDelete</span>(&amp;S, pos, len);</span><br><span class="line">    <span class="built_in">DestroyString</span>(&amp;S);</span><br><span class="line">&#125; ADT String</span><br></pre></td></tr></table></figure><h4 id="1-存储结构："><a href="#1-存储结构：" class="headerlink" title="1.存储结构："></a>1.存储结构：</h4><p>串中元素逻辑关系与线性表相同，串可以采用与线性表相同的存储结构：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220423074636654.png" alt="image-20220423074636654"></p><h5 id="（1）顺序串："><a href="#（1）顺序串：" class="headerlink" title="（1）顺序串："></a>（1）顺序串：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEN 255</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch[MAXLEN + <span class="number">1</span>];<span class="comment">//存储串的一维数组</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//串当前的长度</span></span><br><span class="line">&#125;SString;</span><br></pre></td></tr></table></figure><h5 id="（2）链串："><a href="#（2）链串：" class="headerlink" title="（2）链串："></a>（2）链串：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220913083259566.png" alt="image-20220913083259566"></p><p>&#x3D;&#x3D;块链结构&#x3D;&#x3D;对普通的链串进行优化，提高存储密度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE 80 <span class="comment">//块的大小</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Chunk</span> &#123;</span><br><span class="line">    <span class="type">char</span> ch[CHUNKSIZE];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Chunk</span> *next;</span><br><span class="line">&#125;Chunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    Chunk *head, *tail;<span class="comment">//串的头指针和尾指针</span></span><br><span class="line">    <span class="type">int</span> curlen;<span class="comment">//串的当前长度</span></span><br><span class="line">&#125;LString;<span class="comment">//字符串的块链结构</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：在实际中相较于链串，<font color='#BAOC2F'>顺序串</font>使用更多（对字符串的插入、删除运算较少，顺序结构更利于匹配、查找操作）</p></blockquote><h4 id="2-模式匹配算法："><a href="#2-模式匹配算法：" class="headerlink" title="2.模式匹配算法："></a>2.模式匹配算法：</h4><ul><li>算法目的：确定主串中所含子串（模式串）第一次出现的位置（字符串定位算法）</li><li>算法应用：搜索引擎7拼写检查、语言翻译、数据压缩</li><li>算法种类：Brute-Force算法（经典朴素穷举算法）、KMP算法（速度快）</li></ul><h5 id="（1）BF算法："><a href="#（1）BF算法：" class="headerlink" title="（1）BF算法："></a>（1）BF算法：</h5><p>Btute-Force算法（模式匹配算法）采用了穷举法的思路：从主串的<font color='#BAOC2F'>每一个字符开始</font>依次进行匹配。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220913075255943.png" alt="image-20220913075255943"></p><ol><li>将主串的第pos个字符和模式串的第一个字符进行比较</li><li>若相等则继续逐个比较后续的字符</li><li>若不相等则从主串的下一个字符开始，重新与模式串的第一个字符进行比较（回溯<code>j=1</code>、<code>i=i-j+2</code>）</li><li>直到与主串的1个<font color='#BAOC2F'>连续子串字符序列</font>与模式串相等，返回S中与T匹配的子序列第一个字符的序号（匹配成功）</li><li>否则匹配失败返回0</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法1：从主串的第一个位置开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_BF</span><span class="params">(SString S, SString T)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] == T.ch[j]) &#123;<span class="comment">//主串和子串匹配则加1继续下一个字符</span></span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//主串和子串不匹配则将指针回溯重新开始下一次匹配</span></span><br><span class="line">            i = i - j + <span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= T.length) &#123;<span class="comment">//返回匹配的第一个字符的下标</span></span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法2：从主串的pos位置开始查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_BF</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S.ch[i] == T.ch[j]) &#123;<span class="comment">//主串和子串匹配则加1继续下一个字符</span></span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//主串和子串不匹配则将指针回溯重新开始下一次匹配</span></span><br><span class="line">            i = i - j + <span class="number">2</span>;</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= T.length) &#123;<span class="comment">//返回匹配的第一个字符的下标</span></span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度最好情况为<code>O(m)</code>，</li><li>时间复杂度最差为<code>O(n-m)*m + m</code>，</li><li>时间复杂度平均情况为O<code>(n*m)</code></li></ul><h5 id="（2）KMP算法："><a href="#（2）KMP算法：" class="headerlink" title="（2）KMP算法："></a>（2）KMP算法：</h5><p>KMP算法相较于BF算法中<code>i</code>指针可不必回溯、<code>j</code>指针尽量减少回溯步数，算法时间复杂度可提速到<code>O(n+m)</code></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220913094356218.png" alt="image-20220913094356218"></p><p>定义<code>next[j]</code>函数，用于确定当模式中第<code>j</code>个字符与主串中相应字符<font color='#BAOC2F'>失配</font>时需要回溯的位置，回溯规则如下：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220913095521263.png" alt="image-20220913095521263"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220913101650769.png" alt="image-20220913101650769"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; S.length &amp;&amp; j &lt; T.legngth) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];<span class="comment">//根据j的值在next表中查找，获取j指针的回溯位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//next表的计算方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(SString T, <span class="type">int</span> &amp;next[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）KMP算法改进："><a href="#（3）KMP算法改进：" class="headerlink" title="（3）KMP算法改进："></a>（3）KMP算法改进：</h5><p>&#x3D;&#x3D;针对KMP算法中的next函数进行改进&#x3D;&#x3D;：根据next值求出nextval的值</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220423104107769.png" alt="image-20220423104107769"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220423104125226.png" alt="image-20220423104125226"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Index_KMP</span><span class="params">(SString S, SString T, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = pos, j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; S.length &amp;&amp; j &lt; T.legngth) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || S.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = next[j];<span class="comment">//根据j的值在next表中查找，获取j指针的回溯位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt; T.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> i - T.length;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//next表的计算方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(SString T, <span class="type">int</span> &amp;next[])</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; T.length) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || T.ch[i] == T.ch[j]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            <span class="keyword">if</span> (T.ch[i] != T.ch[j]) nextval[i] = j;</span><br><span class="line">            <span class="keyword">else</span> nextval[i] = nextval[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = nextval[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-应用病毒感染检测："><a href="#3-应用病毒感染检测：" class="headerlink" title="3.应用病毒感染检测："></a>3.应用病毒感染检测：</h4><p>研究者将人的DNA和病毒DNA均表示成由一些字幕组成的字符串序列，</p><p>然后检测某种病毒DNA序列是否在患者的DNA序列中出现过（如果出现过则此人感染了病毒，否则没有感染病毒）</p><blockquote><p>注意：人的DNA序列式线性的，而病毒的DNA序列是环状的</p></blockquote><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220913104409322.png" alt="image-20220913104409322"></p><ul><li>病毒感染检测：<a href="https://blog.csdn.net/Linux518/article/details/119120547">https://blog.csdn.net/Linux518/article/details/119120547</a></li></ul><ol><li>对于每一个待检测的任务假设病毒DNA序列的长度为m，因为病毒DNA序列是环状的，为了取到每个可行的长度为m的模式串可将存储病毒DNA序列的字符串长度扩大为2m（将病毒DNA序列连续存储两次）</li><li>然后循环m次，依次取得每个长度为m的环状字符串，将该字符串作为模式串、人的DNA序列作为主串，调用BF算法进行模式匹配</li><li>只要匹配成功既可终止循环，表明该人感染了对应的病毒，否则循环m次结束循环。</li></ol><h3 id="二、数组"><a href="#二、数组" class="headerlink" title="二、数组"></a>二、数组</h3><h4 id="1-数组定义："><a href="#1-数组定义：" class="headerlink" title="1.数组定义："></a>1.数组定义：</h4><p>数组：按照一定格式排列起来的，<font color='#BAOC2F'>具有相同类型</font>的数据元素的集合。</p><ul><li>一维数组：若线性表中的数据元素为<font color='#BAOC2F'>非结构的简单元素</font>，则称为一维数组（定长的线性表）。</li><li>二维数组：若一维数组中的元素又是一个一维数组结构，则称为二维数组。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220914162819207.png" alt="image-20220914162819207"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> array[m][n];</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> array1[n];</span><br><span class="line"><span class="keyword">typedef</span> array1 array2[m];<span class="comment">//m行n列的二维数组</span></span><br></pre></td></tr></table></figure><ul><li>三维数组：若二维数组中的元素又是一个一维数组，则称作三维数组。</li></ul><h4 id="2-数组存储结构："><a href="#2-数组存储结构：" class="headerlink" title="2.数组存储结构："></a>2.数组存储结构：</h4><p>由于数组结构固定维数与界数基本不变且一般不作插入删除操作，所以很少采用链式存储结构（常采用顺序存储结构表示数组）。</p><p>因此在存储数组结构之前，需要解决将<font color='#BAOC2F'>多维关系映射到一维关系</font>的问题。</p><h5 id="（1）一维数组："><a href="#（1）一维数组：" class="headerlink" title="（1）一维数组："></a>（1）一维数组：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220915082825923.png" alt="image-20220915082825923"></p><h5 id="（2）二维数组："><a href="#（2）二维数组：" class="headerlink" title="（2）二维数组："></a>（2）二维数组：</h5><p>二维数组有两种顺序存储方式：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220915082210543.png" alt="image-20220915082210543"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220915082624667.png" alt="image-20220915082624667"></p><p>&#x3D;&#x3D;以行序为主序的顺序存储&#x3D;&#x3D;：</p><p>设数组存储位置<code>LOC(0,0)</code>每个元素需要L个存储单元，则<code>a[i][j]</code>的存储位置为<code>LOC(i,j)=LOC(0,0)+(n*i+j)*L</code></p><h5 id="（3）三维数组："><a href="#（3）三维数组：" class="headerlink" title="（3）三维数组："></a>（3）三维数组：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220423113215415.png" alt="image-20220423113215415"></p><p>&#x3D;&#x3D;页优先的顺序存储&#x3D;&#x3D;：</p><p>设数组存储位置<code>LOC(0,0,0)</code>每个元素需要L个存储单元，且各维元素的个数为m1,m2,m3</p><p>则<code>a[i][j][k]</code>的存储位置为<code>LOC(i,j,k)=a + i*m2*m3 + j*m3 + k;</code></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220915083627613.png" alt="image-20220915083627613"></p><h4 id="3-特殊矩阵的压缩存储"><a href="#3-特殊矩阵的压缩存储" class="headerlink" title="3.特殊矩阵的压缩存储"></a>3.特殊矩阵的压缩存储</h4><h5 id="（1）对称矩阵："><a href="#（1）对称矩阵：" class="headerlink" title="（1）对称矩阵："></a>（1）对称矩阵：</h5><p>存储方式：只存储上or下三角（包括主对角线）的数据元素，以<font color='#BAOC2F'>行序为主序</font>将元素存放在一维数组<code>arr[n(n+1)/2]</code>中</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220915085704481.png" alt="image-20220915085704481"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220915090002956.png" alt="image-20220915090002956"></p><h5 id="（2）三角矩阵："><a href="#（2）三角矩阵：" class="headerlink" title="（2）三角矩阵："></a>（2）三角矩阵：</h5><p>存储方法：重复的元素常数c可以共享一个元素存储空间，占用<code>n(n+1)/2+1</code>个空间</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220915090255224.png" alt="image-20220915090255224"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220915090419196.png" alt="image-20220915090419196"></p><h5 id="（3）对角矩阵："><a href="#（3）对角矩阵：" class="headerlink" title="（3）对角矩阵："></a>（3）对角矩阵：</h5><p>存储方式：以对角线的顺序存储</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220915090744329.png" alt="image-20220915090744329"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220915090818814.png" alt="image-20220915090818814"></p><h5 id="（4）稀疏矩阵："><a href="#（4）稀疏矩阵：" class="headerlink" title="（4）稀疏矩阵："></a>（4）稀疏矩阵：</h5><p>定义：在n行m列的矩阵中有t个非零元素，当<code>t/m*n) ≤ 0.05</code>时称为该矩阵为稀疏矩阵。</p><p>存储方式：只存储各个<font color='#BAOC2F'>非零元素的值</font>、<font color='#BAOC2F'>行列位置</font>和矩阵的行列数，三元组的<font color='#BAOC2F'>不同表示方法</font>可决定稀疏矩阵<font color='#BAOC2F'>不同的压缩存储方法</font>。</p><p>&#x3D;&#x3D;顺序存储结构&#x3D;&#x3D;：三元组存储</p><ul><li>三元组顺序表的优点：非零元素在表中<font color='#BAOC2F'>按行序有序存储</font>，因此便于进行按行顺序处理的<font color='#BAOC2F'>矩阵运算</font>。</li><li>三元组顺序表的缺点：<font color='#BAOC2F'>不能随机存储</font>。若按行号存取某一行中的非零元素，则需要从头开始进行查找。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220423122249443.png" alt="image-20220423122249443"></p><p>&#x3D;&#x3D;链式存储结构&#x3D;&#x3D;：十字链表存储</p><p>在十字链表中矩阵的每1个非零元素用1个结点表示，结点除了<code>(row, col, value)</code>以外，还需要两个域：</p><ul><li>right：用于链接同一行中的下一个非零元素</li><li>down：用于链接同一列中的下一个非零元素</li><li>链式存储结构的优点：能够<font color='#BAOC2F'>灵活的插入</font>因运算而产生的新的非零元素，<font color='#BAOC2F'>删除</font>因运算而产生的新的零元素，实现矩阵的各种运算。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220915091830639.png" alt="image-20220915091830639"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220423152025118.png" alt="image-20220423152025118"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220423152137937.png" alt="image-20220423152137937"></p>]]></content>
      
      
      <categories>
          
          <category> datestructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> datestructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章：二叉树（上）</title>
      <link href="/2023/02/28/dataStructure/5.%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2023/02/28/dataStructure/5.%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章：BT（上）"><a href="#第五章：BT（上）" class="headerlink" title="第五章：BT（上）"></a>第五章：BT（上）</h1><hr><h3 id="一、BT概述"><a href="#一、BT概述" class="headerlink" title="一、BT概述"></a>一、BT概述</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><ol><li>根结点：非空树中<font color='#BAOC2F'>无前驱结点</font>的结点</li><li>分支结点：度<code>!=0</code> <font color='#BAOC2F'>非终端结点</font>则称为分支结点</li><li>内部结点：除开根节点以外的<font color='#BAOC2F'>分支结点</font>称为内部结点</li><li>叶子结点：度<code>==</code> 0则称为叶子结点</li><li>结点的度：结点有几个孩子（分支）</li><li>树的度Degree：树内<font color='#BAOC2F'>各节点度的最大值</font></li><li>树的深度&#x2F;高度Depth：树中<font color='#BAOC2F'>结点的最大层次</font></li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221009163147698.png" alt="image-20221009163147698"></p><h4 id="2-T性质："><a href="#2-T性质：" class="headerlink" title="2.T性质："></a>2.T性质：</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011192212343.png" alt="image-20221011192212343"></p><h4 id="3-BT性质："><a href="#3-BT性质：" class="headerlink" title="3.BT性质："></a>3.BT性质：</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011192201291.png" alt="image-20221011192201291"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221009191516421.png" alt="image-20221009191516421"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011192548260.png" alt="image-20221011192548260"></p><h4 id="4-特殊二叉树："><a href="#4-特殊二叉树：" class="headerlink" title="4.特殊二叉树："></a>4.特殊二叉树：</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011193346894.png" alt="image-20221011193346894"></p><h3 id="二、BT存储结构"><a href="#二、BT存储结构" class="headerlink" title="二、BT存储结构"></a>二、BT存储结构</h3><h4 id="1-顺序二叉树"><a href="#1-顺序二叉树" class="headerlink" title="1.顺序二叉树"></a>1.顺序二叉树</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220505084023879.png" alt="image-20220505084023879"></p><ul><li>实现：按照<font color='#BAOC2F'>满二叉树的结点层次</font>编号，用<font color='#BAOC2F'>数组依次存放</font>二叉树中的数据元素，结点关系蕴含在元素的存储位置中。</li><li>缺点：深度为k的二叉树<font color='#BAOC2F'>只有k个结点</font>的单支树需要长度为2<sup>k</sup>-1的一维数组（存储空间浪费），适于存储满二叉树和完全二叉树。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序存储</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTSIZE 100</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    ElemType value;</span><br><span class="line">    <span class="type">bool</span> isEmpty;</span><br><span class="line">&#125;;</span><br><span class="line">TreeNode SqBiTree[MAXTSIZE];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAXTSIZE; ++i) SqBiTree[i].isEmpty = <span class="literal">true</span>;<span class="comment">//顺序二叉树初始化</span></span><br></pre></td></tr></table></figure><h4 id="2-链式二叉树"><a href="#2-链式二叉树" class="headerlink" title="2.链式二叉树"></a>2.链式二叉树</h4><h5 id="（1）二叉链表："><a href="#（1）二叉链表：" class="headerlink" title="（1）二叉链表："></a>（1）二叉链表：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiNode</span> *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><blockquote><p>注：在n个结点的二叉链表中，必有<code>n+1</code>个空指针域。分析：二叉链表中必有2n个链域，除根结点外每个结点仅有一个双亲，所有只会有<code>n-1</code>个结点的链域存放指针，指向非空子女结点。</p></blockquote><h5 id="（2）三叉链表："><a href="#（2）三叉链表：" class="headerlink" title="（2）三叉链表："></a>（2）三叉链表：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TriTNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">TriTNode</span> *lchild, *parent, *rchild;</span><br><span class="line">&#125; TriTNode, *TriTree;</span><br></pre></td></tr></table></figure><h3 id="三、BT遍历"><a href="#三、BT遍历" class="headerlink" title="三、BT遍历"></a>三、BT遍历</h3><h4 id="1-先根遍历"><a href="#1-先根遍历" class="headerlink" title="1.先根遍历"></a>1.先根遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉链表实现先序遍历二叉树</span></span><br><span class="line"><span class="function">Status <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);<span class="comment">//访问根结点</span></span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">PreOrderTraverse</span>(T-&gt;rchild);<span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-中根遍历"><a href="#2-中根遍历" class="headerlink" title="2.中根遍历"></a>2.中根遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉链表实现中序遍历二叉树</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);<span class="comment">//访问根结点</span></span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;rchild);<span class="comment">//递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-后根遍历"><a href="#3-后根遍历" class="headerlink" title="3.后根遍历"></a>3.后根遍历</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉链表实现后序遍历二叉树</span></span><br><span class="line"><span class="function">Status <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line">        <span class="built_in">InOrderTraverse</span>(T-&gt;rchild);<span class="comment">//递归遍历右子树</span></span><br><span class="line">        <span class="built_in">visit</span>(T);<span class="comment">//访问根结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：三种遍历算法的<font color='#BAOC2F'>访问路径是相同的</font>，只是访问结点的时机不相同。</p></blockquote><h4 id="4-遍历序列确定BT"><a href="#4-遍历序列确定BT" class="headerlink" title="4.遍历序列确定BT"></a>4.遍历序列确定BT</h4><ol><li>若二叉树中各节点的值均不相同，则二叉树结点的先序遍历、中序遍历和后序遍历都是唯一的。</li><li>由二叉树的<font color='#BAOC2F'>先序序列、中序遍历序列</font>，or 由二叉树的<font color='#BAOC2F'>中序遍历、后序遍历序列</font>可以确定唯一的二叉树。</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221009211335093.png" alt="image-20221009211335093"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221009211500375.png" alt="image-20221009211500375"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221009211515795.png" alt="image-20221009211515795"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011195350074.png" alt="image-20221011195350074"></p><blockquote><p>注：前序、后序、层序序列遍历的两两组合是<font color='#BAOC2F'>无法唯一确定</font>一棵二叉树的。</p></blockquote><h4 id="5-BTの非递归遍历（借助栈）"><a href="#5-BTの非递归遍历（借助栈）" class="headerlink" title="5.BTの非递归遍历（借助栈）"></a>5.BTの非递归遍历（借助栈）</h4><p>非递归算法的关键：在中序遍历过某个结点的整个左子树之后，如何找到该结点的根以及其右子树？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*算法思路：</span></span><br><span class="line"><span class="comment">1.建立一个栈</span></span><br><span class="line"><span class="comment">2.根结点进栈，遍历左子树</span></span><br><span class="line"><span class="comment">3.根结点出栈输出根结点，遍历右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    BiTree p; <span class="built_in">InitStack</span>(S); p = T;</span><br><span class="line">    <span class="keyword">while</span> (p || !<span class="built_in">StackEmpty</span>(S)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            <span class="built_in">Push</span>(S, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">Pop</span>(S, q);</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;%s&quot;</span>, q-&gt;data);</span><br><span class="line">            p = q-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-BTの层序遍历（借助队列）"><a href="#6-BTの层序遍历（借助队列）" class="headerlink" title="6.BTの层序遍历（借助队列）"></a>6.BTの层序遍历（借助队列）</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011194115125.png" alt="image-20221011194115125"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">借助链队列实现二叉树的层序遍历</span></span><br><span class="line"><span class="comment">算法思路：</span></span><br><span class="line"><span class="comment">1.初始化一个辅助队列，并将根节点入队</span></span><br><span class="line"><span class="comment">2.队列不为空时：则队头结点出队并访问该结点</span></span><br><span class="line"><span class="comment">  如果它有左孩子结点，将左孩子结点入队</span></span><br><span class="line"><span class="comment">  如果它有右孩子结点，将右孩子结点入队</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链队列结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">    BiTNode *data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    LinkNode *front, *rear;</span><br><span class="line">&#125; LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LeverOrder</span><span class="params">(BiTree p)</span> </span>&#123;</span><br><span class="line">    LinkQueue Q; <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, p);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsEmpty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, p);</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>) <span class="built_in">EnQueue</span>(Q, p-&gt;lchild);<span class="comment">//有左孩纸入队</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>) <span class="built_in">EnQueue</span>(Q, p-&gt;rchild);<span class="comment">//有左孩纸入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">借助顺序队列实现二叉树的层序遍历</span></span><br><span class="line"><span class="comment">算法思路：</span></span><br><span class="line"><span class="comment">1.将根节点入队</span></span><br><span class="line"><span class="comment">2.队列不为空时：从队列中出队一个结点并访问它</span></span><br><span class="line"><span class="comment">  如果它有左孩子结点，将左孩子结点入队</span></span><br><span class="line"><span class="comment">  如果它有右孩子结点，将右孩子结点入队</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//二叉树结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTNode</span> &#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTNode</span> *lchild, *rchild;</span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    BiTNode data[MAXSIZE];<span class="comment">//存放队中元素</span></span><br><span class="line">    <span class="type">int</span> front, rear;<span class="comment">//队头、队尾指针</span></span><br><span class="line">&#125; SqQueue;<span class="comment">//顺序循环队列类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTNode *p)</span> </span>&#123;</span><br><span class="line">    SqQueue *sq; <span class="built_in">InitQueue</span>(sq);</span><br><span class="line">    <span class="built_in">EnQueue</span>(sq, p);<span class="comment">//树的根结点指针进入队列</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">QueueEmpty</span>(sq)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(sq, p);<span class="comment">//出队结点p</span></span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>) <span class="built_in">EnQueue</span>(sq, p-&gt;lchild);<span class="comment">//有左孩子时将其入队</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>) <span class="built_in">EnQueue</span>(sq, p-&gt;rchild);<span class="comment">//有右孩子时将其入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ol><li>二叉树的<font color='#BAOC2F'>层次遍历</font>其实也<font color='#BAOC2F'>可以使用栈</font>实现（比队列实现稍复杂）</li><li>队列中并没有必要保存<font color='#BAOC2F'>整个结点的真实数据</font>，只需要保存指向结点的指针即可。</li><li>二叉树的层序遍历和图的广度优先遍历类似（树是一种特殊的图）</li></ol></blockquote><h3 id="四、BT遍历算法应用"><a href="#四、BT遍历算法应用" class="headerlink" title="四、BT遍历算法应用"></a>四、BT遍历算法应用</h3><h4 id="1-BT的建立"><a href="#1-BT的建立" class="headerlink" title="1.BT的建立"></a>1.BT的建立</h4><p>按照<font color='#BAOC2F'>先序遍历序列</font>建立二叉树的<font color='#BAOC2F'>二叉链表</font>：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221009213151682.png" alt="image-20221009213151682"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照先序遍历的方式建立二叉树</span></span><br><span class="line"><span class="function">Status <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(T = (BiTNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(BiTNode)))) <span class="built_in">exit</span>(OVERFLOW);<span class="comment">//T = new BiTNode;</span></span><br><span class="line">        T-&gt;data = ch;<span class="comment">//生成根结点</span></span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;lchild);<span class="comment">//构造左子树</span></span><br><span class="line">        <span class="built_in">CreateBiTree</span>(T-&gt;rchild);<span class="comment">//构造右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-BT的复制"><a href="#2-BT的复制" class="headerlink" title="2.BT的复制"></a>2.BT的复制</h4><p>按照<font color='#BAOC2F'>先序遍历的思想</font>，复制二叉树：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*算法思想：按照先序遍历的思想复制二叉树</span></span><br><span class="line"><span class="comment">1.如果是空树，递归结束</span></span><br><span class="line"><span class="comment">2.否则申请新节点空间，复制根结点</span></span><br><span class="line"><span class="comment">  递归复制左子树</span></span><br><span class="line"><span class="comment">  递归复制右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">Copy</span><span class="params">(BiTree T, BiTree &amp;NewT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        NewT = <span class="literal">NULL</span>; <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        NewT = <span class="keyword">new</span> BiTNode;</span><br><span class="line">        NewT-&gt;data = T-&gt;data;<span class="comment">//复制根结点</span></span><br><span class="line">        <span class="built_in">Copy</span>(T-&gt;lchild, NewT-&gt;lchild);<span class="comment">//递归复制左子树</span></span><br><span class="line">        <span class="built_in">Copy</span>(T-&gt;rchild, NewT-&gt;rchild);<span class="comment">//递归复制右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-BT深度计算"><a href="#3-BT深度计算" class="headerlink" title="3.BT深度计算"></a>3.BT深度计算</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*算法思想：</span></span><br><span class="line"><span class="comment">1.如果是空树，则深度为0</span></span><br><span class="line"><span class="comment">2.否则递归计算左子树的深度记为m，递归计算右子树的深度记为n</span></span><br><span class="line"><span class="comment">3.二叉树的深度则为m与n的较大者+1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span> </span>&#123;<span class="comment">//后序遍历算法的变种</span></span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m = <span class="built_in">Depth</span>(T-&gt;lChild);</span><br><span class="line">        n = <span class="built_in">Depth</span>(T-&gt;rChild);</span><br><span class="line">        <span class="keyword">return</span> m &gt; n ? m+<span class="number">1</span> : r+<span class="number">1</span>;<span class="comment">//树的深度 = Max(左子树深度, 右子树深度) + 1;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-BT结点个数计算"><a href="#4-BT结点个数计算" class="headerlink" title="4.BT结点个数计算"></a>4.BT结点个数计算</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*算法思想：</span></span><br><span class="line"><span class="comment">1.如果是空树，则结点个数为0</span></span><br><span class="line"><span class="comment">2.否则，结点个数为左子树的结点个数 + 右子树的结点个数 + 1 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NodeCount</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">NodeCount</span>(T-&gt;lchild) + <span class="built_in">NodeCount</span>(T-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-BT叶子结点个数计算"><a href="#5-BT叶子结点个数计算" class="headerlink" title="5.BT叶子结点个数计算"></a>5.BT叶子结点个数计算</h4><ol><li>如果是空树，则叶子结点的个数为0</li><li>否则，叶子结点的个数为：左子树叶子结点个数 + 右子树叶子结点个数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LeadCount</span><span class="params">(BiTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (T-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">LeafCount</span>(T-&gt;lchild) + <span class="built_in">LeafCount</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、线索二叉树"><a href="#五、线索二叉树" class="headerlink" title="五、线索二叉树"></a>五、线索二叉树</h3><h4 id="1-中序线索二叉树"><a href="#1-中序线索二叉树" class="headerlink" title="1.中序线索二叉树"></a>1.中序线索二叉树</h4><p>使用二叉链表存储结构时，可以方便的找到某个结点的左右孩子，但无法直接找到该结点<font color='#BAOC2F'>在某种遍历序列中的前驱和后继结点</font>：</p><ol><li><p>通过遍历寻找（增加时间负担）</p></li><li><p>再增设前驱、后继指针域（增加存储负担）</p></li><li><p>利用<font color='#BAOC2F'>二叉树链表中的空指针域</font></p><p> 如果某个结点的左孩子为空，则将空的左孩子指针域改为<font color='#BAOC2F'>指向其前驱</font>，</p><p> 如果某个结点的右孩子为空，则将空的右孩子指针域改为<font color='#BAOC2F'>指向其后继</font>，</p></li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011202643149.png" alt="image-20221011202643149"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法1：二叉树中序线索化</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;</span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;<span class="comment">//全局变量pre用于指向当前访问结点的前驱</span></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;<span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        <span class="built_in">InThread</span>(T);<span class="comment">//中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;<span class="comment">//特判处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历二叉树，边遍历边线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">visit</span>(T);</span><br><span class="line">        <span class="built_in">InThread</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体的线索化逻辑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;lchild = pre;<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//总结：中序线索化其实就是一个中序遍历的过程，只不过在中序遍历的过程中需要边遍历、边处理这个结点</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法2：二叉树中序线索化</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;</span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序线索化二叉树T</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;<span class="comment">//非空二叉树才能线索化</span></span><br><span class="line">        <span class="built_in">InThread</span>(T, pre);<span class="comment">//中序线索化二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;<span class="comment">//特判处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历二叉树，边遍历边线索化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InThread</span><span class="params">(ThreadTree q, ThreadTree &amp;pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">InThread</span>(q-&gt;lchild, pre);</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q-&gt;lchild = pre;<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">            q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = q;<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = q;</span><br><span class="line">        <span class="built_in">InThread</span>(q-&gt;rchild, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-先序线索二叉树"><a href="#2-先序线索二叉树" class="headerlink" title="2.先序线索二叉树"></a>2.先序线索二叉树</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011203808663.png" alt="image-20221011203808663"></p><p>先序遍历存在lchild为前序的情况，需要特殊处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法1：二叉树先序线索化</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;</span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;<span class="comment">//全局变量pre用于指向当前访问结点的前驱</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePreThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">PreThread</span>(T);</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;<span class="comment">//特判处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(T);</span><br><span class="line">        <span class="keyword">if</span> (T-&gt;ltag == <span class="number">0</span>) <span class="built_in">PreThread</span>(T-&gt;lchild);<span class="comment">//lchild不是前驱线索</span></span><br><span class="line">        <span class="built_in">PreThread</span>(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体的线索化逻辑</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;lchild = pre;<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法2：二叉树先序线索化</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;</span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePreThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">PreThread</span>(T, pre);</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;<span class="comment">//特判处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreThread</span><span class="params">(ThreadTree q, ThreadTree &amp;pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q-&gt;lchild = pre;<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">            q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = q;<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = q;</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;ltag == <span class="number">0</span>) <span class="built_in">PreThread</span>(q-&gt;lchild);<span class="comment">//lchild不是前驱线索</span></span><br><span class="line">        <span class="built_in">PreThread</span>(q-&gt;rchild, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-后序线索二叉树"><a href="#3-后序线索二叉树" class="headerlink" title="3.后序线索二叉树"></a>3.后序线索二叉树</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011204016056.png" alt="image-20221011204016056"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法1：二叉树后序线索化</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;</span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line">ThreadNode *pre = <span class="literal">NULL</span>;<span class="comment">//全局变量pre用于指向当前访问结点的前驱</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatePostThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T);</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;<span class="comment">//特判处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;lchild);</span><br><span class="line">        <span class="built_in">PostThread</span>(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">visit</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">(ThreadNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;lchild = pre;<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">        q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pre-&gt;rchild = q;<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写法2：二叉树后序线索化</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ThreadNode</span> *lchild, *rchild;</span><br><span class="line">    <span class="type">int</span> ltag, rtag;</span><br><span class="line">&#125; ThreadNode, *ThreadTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span> </span>&#123;</span><br><span class="line">    pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (T != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(T, pre);</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;<span class="comment">//特判处理最后一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostThread</span><span class="params">(ThreadTree q, ThreadTree &amp;pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">PostThread</span>(q-&gt;lchild, pre);</span><br><span class="line">        <span class="built_in">PostThread</span>(q-&gt;rchild, pre);</span><br><span class="line">        <span class="keyword">if</span> (q-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            q-&gt;lchild = pre;<span class="comment">//左子树为空，建立前驱线索</span></span><br><span class="line">            q-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            pre-&gt;rchild = q;<span class="comment">//建立前驱结点的后继线索</span></span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011204245192.png" alt="image-20221011204245192"></p><h3 id="六、线索二叉树遍历"><a href="#六、线索二叉树遍历" class="headerlink" title="六、线索二叉树遍历"></a>六、线索二叉树遍历</h3><h4 id="1-中序线索找中序后继"><a href="#1-中序线索找中序后继" class="headerlink" title="1.中序线索找中序后继"></a>1.中序线索找中序后继</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011204815542.png" alt="image-20221011204815542"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到以P为根的子树中，第一个被中序遍历的结点（循环寻找到最左下的结点（不一定是叶子结点））</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">FirstNode</span><span class="params">(ThreadNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;ltag == <span class="number">0</span>) p = p-&gt;lchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在中序线索树中查找结点p的后继结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">NextNode</span><span class="params">(ThreadNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">FirstNode</span>(p-&gt;rchild);<span class="comment">//未被线索化</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;rchild;<span class="comment">////已被线索化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对中序线索二叉树进行中序遍历（利用线索实现非递归算法O(1)）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Inorder</span><span class="params">(ThreadNode *T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ThreadNode *p = <span class="built_in">FirstNode</span>(T); p != <span class="literal">NULL</span>; p = <span class="built_in">NextNode</span>(p)) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-中序线索找中序前驱"><a href="#2-中序线索找中序前驱" class="headerlink" title="2.中序线索找中序前驱"></a>2.中序线索找中序前驱</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011204929288.png" alt="image-20221011204929288"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到以P为根的子树中，最后一个被中序遍历的结点（循环寻找到最右下的结点（不一定是叶子结点））</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">LastNode</span><span class="params">(ThreadNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;rtag == <span class="number">0</span>) p = p-&gt;rchild;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在中序线索树中查找结点p的前驱结点</span></span><br><span class="line"><span class="function">ThreadNode *<span class="title">PreNode</span><span class="params">(ThreadNode *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">LastNode</span>(p-&gt;lchild);<span class="comment">//未被线索化</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> p-&gt;lchild;<span class="comment">////已被线索化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对中序线索二叉树进行逆向的中序遍历（利用线索实现非递归算法O(1)）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RevInorder</span><span class="params">(ThreadNode *T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ThreadNode *p = <span class="built_in">LastNode</span>(T); p != <span class="literal">NULL</span>; p = <span class="built_in">PreNode</span>(p)) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-线索二叉树遍历总结"><a href="#3-线索二叉树遍历总结" class="headerlink" title="3.线索二叉树遍历总结"></a>3.线索二叉树遍历总结</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011205017452.png" alt="image-20221011205017452"></p>]]></content>
      
      
      <categories>
          
          <category> datestructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> datestructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章：二叉树（下）</title>
      <link href="/2023/02/28/dataStructure/6.%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2023/02/28/dataStructure/6.%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章：二叉树（下）"><a href="#第五章：二叉树（下）" class="headerlink" title="第五章：二叉树（下）"></a>第五章：二叉树（下）</h1><hr><h3 id="一、树与森林"><a href="#一、树与森林" class="headerlink" title="一、树与森林"></a>一、树与森林</h3><h4 id="1-树存储结构"><a href="#1-树存储结构" class="headerlink" title="1.树存储结构"></a>1.树存储结构</h4><h5 id="（1）双亲表示法："><a href="#（1）双亲表示法：" class="headerlink" title="（1）双亲表示法："></a>（1）双亲表示法：</h5><p>实现：定义<font color='#BAOC2F'>结构数组</font>存放树的结点，每个结点含两个域（找双亲容易、找孩子难）</p><ul><li>数据域：存放结点本身信息</li><li>双亲域：指示本结点的<font color='#BAOC2F'>双亲结点在数组中的位置</font>。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011210412633.png" alt="image-20221011210412633"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PTNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> parent;<span class="comment">//双亲位置域</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    PTNode nodes[MAXTSIZE];</span><br><span class="line">    <span class="type">int</span> r;<span class="comment">//根结点的位置</span></span><br><span class="line">    <span class="type">int</span> n;<span class="comment">//结点的个数</span></span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure><h5 id="（2）孩子链表表示法："><a href="#（2）孩子链表表示法：" class="headerlink" title="（2）孩子链表表示法："></a>（2）孩子链表表示法：</h5><p>实现：将每个结点的孩子结点排列用单链表存储，而n个头指针又组成一个线性表用顺序表存储（找孩子容易、找双亲难）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011210604058.png" alt="image-20221011210604058"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//孩子结点结构：child + next</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CTNode</span> *next;</span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"><span class="comment">//双亲结点结构：data + firstchild</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTBox</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    ChildPtr firstchild;<span class="comment">//孩子链表头指针</span></span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    CTBox nodes[MAXTSIZE];</span><br><span class="line">    <span class="type">int</span> n;<span class="comment">//结点个数</span></span><br><span class="line">    <span class="type">int</span> r;<span class="comment">//根节点的位置</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure><h5 id="（3）孩子兄弟表示法："><a href="#（3）孩子兄弟表示法：" class="headerlink" title="（3）孩子兄弟表示法："></a>（3）孩子兄弟表示法：</h5><p>二叉链表表示法&#x2F;二叉树表示法&#x2F;孩子兄弟表示法，</p><p>实现：用<font color='#BAOC2F'>二叉链表</font>表示数的存储结构，链表中每个结点的<font color='#BAOC2F'>两个指针域</font>分别指向其<font color='#BAOC2F'>第一个孩子结点</font>和<font color='#BAOC2F'>下一个兄弟结点</font>。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011210814446.png" alt="image-20221011210814446"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CSNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CSNode</span> *firstchild, *nextsibling;</span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure><h4 id="2-树与二叉树互转"><a href="#2-树与二叉树互转" class="headerlink" title="2.树与二叉树互转"></a>2.树与二叉树互转</h4><p>将树转化为二叉树进行处理，<font color='#BAOC2F'>利用二叉树的算法</font>来实现对树的操作，由于树和二叉树都可以<font color='#BAOC2F'>用二叉树链表</font>作存储结构，则以二叉链表做媒介可以<font color='#BAOC2F'>导出树与二叉树之间的对应关系</font>。给定一棵树，可以找到唯一的二叉树与之对应</p><h5 id="（1）树转换为二叉树："><a href="#（1）树转换为二叉树：" class="headerlink" title="（1）树转换为二叉树："></a>（1）树转换为二叉树：</h5><ul><li>理解：<a href="https://www.bilibili.com/video/BV1nJ411V7bd?p=98&t=100">树转换为二叉树</a></li></ul><p>二叉树转换步骤（兄弟相连留长子）：</p><ol><li>加线：在兄弟之间加一根连线</li><li>抹线：对每个结点除了其左孩子外，去除其与其他孩子之间的关系</li><li>旋转：以树的根结点为轴心，将整树顺时针旋转45度</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220520121828484.png" alt="image-20220520121828484"></p><h5 id="（2）二叉树转换为树："><a href="#（2）二叉树转换为树：" class="headerlink" title="（2）二叉树转换为树："></a>（2）二叉树转换为树：</h5><ul><li>理解：<a href="https://www.bilibili.com/video/BV1nJ411V7bd?p=98&t=765">二叉树转换为树</a></li></ul><p>树转换步骤（左孩右右连双亲，去掉原来右孩线）：</p><ol><li>加线：若p为双亲结点的左孩子，则将p的右孩子、右孩子的右孩子…沿分支找到所有的右孩子与双亲连接</li><li>抹线：抹掉原二叉树中双亲与右孩子之间的连线</li><li>调整：将结点按层次排列，形成树结构</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220520122552480.png" alt="image-20220520122552480"></p><h4 id="3-森林与二叉树互转"><a href="#3-森林与二叉树互转" class="headerlink" title="3.森林与二叉树互转"></a>3.森林与二叉树互转</h4><h5 id="（1）森林转为二叉树："><a href="#（1）森林转为二叉树：" class="headerlink" title="（1）森林转为二叉树："></a>（1）森林转为二叉树：</h5><ul><li>理解：<a href="https://www.bilibili.com/video/BV1nJ411V7bd?p=99&t=33">森林转为二叉树</a></li></ul><p>森林转为二叉树（树变二叉根相连）</p><ol><li>将各棵树分别转换为二叉树</li><li>将每棵树的根结点用线相连</li><li>以第一棵树根结点为二叉树的根，再以根结点为轴心顺时针旋转，构成二叉树形结构</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221010084216865.png" alt="image-20221010084216865"></p><h5 id="（2）二叉树转为森林："><a href="#（2）二叉树转为森林：" class="headerlink" title="（2）二叉树转为森林："></a>（2）二叉树转为森林：</h5><ul><li>理解：<a href="https://www.bilibili.com/video/BV1nJ411V7bd?p=99&t=249">二叉树转为森林</a></li></ul><p>二叉树转为森林（去掉全部右孩线，孤立二叉再还原）。</p><ol><li>抹线：将二叉树中根节点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉（产生许多孤立的二叉树）</li><li>还原：将孤立的二叉树还原为树</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220526090235671.png" alt="image-20220526090235671"></p><h4 id="4-树与森林的遍历"><a href="#4-树与森林的遍历" class="headerlink" title="4.树与森林的遍历"></a>4.树与森林的遍历</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011211235498.png" alt="image-20221011211235498"></p><h5 id="（1）树的遍历："><a href="#（1）树的遍历：" class="headerlink" title="（1）树的遍历："></a>（1）树的遍历：</h5><blockquote><p>注：树的遍历没有中根遍历的情况，因为<font color='#BAOC2F'>无法确定根的中序位置</font>。</p></blockquote><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011211554764.png" alt="image-20221011211554764"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(TreeNode *R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (R != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(R);</span><br><span class="line">        <span class="keyword">while</span> (R-&gt;nextTree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">PreOrder</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011211751651.png" alt="image-20221011211751651"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(TreeNode *R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (R != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (R-&gt;nextTree != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">PostOrder</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">visit</span>(R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011212301859.png" alt="image-20221011212301859"></p><h5 id="（2）森林的遍历："><a href="#（2）森林的遍历：" class="headerlink" title="（2）森林的遍历："></a>（2）森林的遍历：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011212632535.png" alt="image-20221011212632535"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011212858231.png" alt="image-20221011212858231"></p><h3 id="二、哈夫曼树"><a href="#二、哈夫曼树" class="headerlink" title="二、哈夫曼树"></a>二、哈夫曼树</h3><h4 id="1-哈夫曼树构造"><a href="#1-哈夫曼树构造" class="headerlink" title="1.哈夫曼树构造"></a>1.哈夫曼树构造</h4><p>在含有n个带权结点的二叉树中，其中带<font color='#BAOC2F'>权路径长度WPL最小的二叉树</font>称为哈夫曼树，也称为最优二叉树。</p><p>根据哈夫曼树中<font color='#BAOC2F'>权越大的叶子</font>离<font color='#BAOC2F'>根结点越近</font>的规律，利用贪心算法的思想：构造哈夫曼树时<font color='#BAOC2F'>首先选择权值小</font>的叶子结点。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011213639654.png" alt="image-20221011213639654"></p><p>&#x3D;&#x3D;哈夫曼树性质&#x3D;&#x3D;：</p><ol><li>每个初始结点最终都会成为叶结点，且权值越小的结点到根节点的路径长度越大</li><li>包含n个叶子结点的哈夫曼树中共有2n-1个结点</li><li>哈夫曼树结点的度数为0或者2，没有度为1的结点</li><li>哈夫曼树的构造并不唯一，但是路径长度WPL必然相同且为最优</li><li>包含n棵树的森林要经过n-1次合并才能形成哈夫曼树，共产生n-1个新结点</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221010091234228.png" alt="image-20221010091234228"></p><h4 id="2-哈夫曼树构造算法"><a href="#2-哈夫曼树构造算法" class="headerlink" title="2.哈夫曼树构造算法"></a>2.哈夫曼树构造算法</h4><p>采用顺序存储结构，一维数组实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">    <span class="type">int</span> parent, lch rch;</span><br><span class="line">&#125; HTNode, *HuffmanTree;</span><br></pre></td></tr></table></figure><h5 id="（1）数组初始化："><a href="#（1）数组初始化：" class="headerlink" title="（1）数组初始化："></a>（1）数组初始化：</h5><ol><li>初始化<code>HT[1...2n-1]</code>：<code>lch = rch = parent=0</code></li><li>输入初始化<font color='#BAOC2F'>n个叶子结点</font>：设置<code>HT[1...n]</code>的weight值</li></ol><h5 id="（2）结点的n-1次合并："><a href="#（2）结点的n-1次合并：" class="headerlink" title="（2）结点的n-1次合并："></a>（2）结点的n-1次合并：</h5><p>对结点进行n-1次合并，依次产生n-1个结点<code>HT[i]，i=n+1, n+2, …2n-1</code></p><ol><li><p>在HT[1…i-1]中选取两个<font color='#BAOC2F'>未被选过</font>（parent&#x3D;&#x3D;0）<font color='#BAOC2F'>且weight最小</font>的结点<code>HT[s1]</code>和<code>HT[s2]</code></p></li><li><p>修改HT[s1]和HT[s2]的parent值：<code>HT[s1].parent=i;</code>、<code>HT[s2].parent=i;</code></p></li><li><p>修改新产生的HT[i]：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HT[i].weight = HT[s1].weight + HT[s2].weight;</span><br><span class="line">HT[i].lch = s1;</span><br><span class="line">HT[i].rch = s2;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatHuffmanTree</span><span class="params">(HuffmanTree HT, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//1.数组初始化</span></span><br><span class="line">    m = <span class="number">2</span> *n - <span class="number">1</span>;<span class="comment">//数组共2n-1个元素</span></span><br><span class="line">    HT = <span class="keyword">new</span> HTNode[m + <span class="number">1</span>];<span class="comment">//0号单元未用，HT[m]表示根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        HT[i].lch = <span class="number">0</span>;</span><br><span class="line">        HT[i].rch = <span class="number">0</span>;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) cin &gt;&gt; HT[i].weight;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.开始构造哈夫曼树（合并产生n-1个结点）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="built_in">Select</span>(HT, i - <span class="number">1</span>, s1, s2);<span class="comment">//在HT[k]中选择两个其双亲域为0、且权值最小的结点，并返回他们在HT中的序号s1、s2</span></span><br><span class="line">        HT[s1].parent = i; HT[s2].parent = i;<span class="comment">//从F中删除s1, s2</span></span><br><span class="line">        HT[i].lch = s1; HT[i].rch = s2;<span class="comment">//s1，s2分别作为i的左右孩子</span></span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight; <span class="comment">//i的权值为左右孩子权值之和</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-哈夫曼树应用哈夫曼编码"><a href="#3-哈夫曼树应用哈夫曼编码" class="headerlink" title="3.哈夫曼树应用哈夫曼编码"></a>3.哈夫曼树应用哈夫曼编码</h4><h5 id="（1）问题引入："><a href="#（1）问题引入：" class="headerlink" title="（1）问题引入："></a>（1）问题引入：</h5><p>&#x3D;&#x3D;固定长度编码&#x3D;&#x3D;：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011214237395.png" alt="image-20221011214237395"></p><p>&#x3D;&#x3D;可变长度编码&#x3D;&#x3D;：允许对不同字符用不等长的二进制位表示，</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011214340487.png" alt="image-20221011214340487"></p><p>&#x3D;&#x3D;哈夫曼编码&#x3D;&#x3D;：字符集中的每个字符作为一个叶子结点，各个<font color='#BAOC2F'>字符出现的频度</font>作为结点的权值，来构造哈夫曼树：</p><ol><li>统计字符集中每个字符在电文中出现的平均概论（概率越大、要求编码越短）</li><li>将每个字符的平均概论作为权值，利用哈夫曼树的特点（权值越大的叶子离根越近）构造哈夫曼树。（概率越大的结点路径越短）</li><li>在哈夫曼树的<font color='#BAOC2F'>每个结点分支上标记0和1</font>（左分支0，右分支1）</li><li>把<font color='#BAOC2F'>从根到每个叶子的路径上的标号</font>连接起来，作为该叶子代表的字符编码</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221010093337744.png" alt="image-20221010093337744"></p><blockquote><ol><li>哈夫曼编码是<font color='#BAOC2F'>前缀码</font>（没有一片树叶是另一片树叶的祖先）</li><li>哈夫曼编码是<font color='#BAOC2F'>最优前缀码</font>（哈夫曼树的带权路径长度最短，字符编码总长度一定是最短的）</li></ol></blockquote><h5 id="（2）哈夫曼编码："><a href="#（2）哈夫曼编码：" class="headerlink" title="（2）哈夫曼编码："></a>（2）哈夫曼编码：</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220526204908201.png" alt="image-20220526204908201"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从叶子到根逆向求每个字符的哈夫曼编码，存储在编码表HC中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatHuffmanCode</span><span class="params">(HuffmanTree HT, HuffmanCode &amp;HT, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    HC = <span class="keyword">new</span> <span class="type">char</span>*[n + <span class="number">1</span>];<span class="comment">//分配n个字符编码的头指针矢量</span></span><br><span class="line">    cd = <span class="keyword">new</span> <span class="type">char</span>[n];<span class="comment">//分配临时存放编码的动态数组空间</span></span><br><span class="line">    cd[n - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//编码结束符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;<span class="comment">//逐个字符求哈夫曼编码</span></span><br><span class="line">        start = n - <span class="number">1</span>; c = i; f = HT[i].parent;</span><br><span class="line">        <span class="keyword">while</span> (f != <span class="number">0</span>) &#123;<span class="comment">//从叶子结点开始向上回溯直到根节点</span></span><br><span class="line">            start--;<span class="comment">//回溯一次start向前指一个位置</span></span><br><span class="line">            <span class="keyword">if</span> (HT[f].lchild == c) &#123;</span><br><span class="line">                cd[start] = <span class="string">&#x27;0&#x27;</span>;<span class="comment">//结点c是f的左孩子，则生成代码0</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cd[start] = <span class="string">&#x27;1&#x27;</span>;<span class="comment">//结点c是f的右孩子，则生成代码1</span></span><br><span class="line">            &#125;</span><br><span class="line">            c = i; f = HT[i].parent;<span class="comment">//继续向上回溯</span></span><br><span class="line">        &#125;<span class="comment">//求出第i个字符的编码</span></span><br><span class="line">        HC[i] = <span class="keyword">new</span> <span class="type">char</span>[n - start];<span class="comment">//为第i个字符串编码分配空间</span></span><br><span class="line">        <span class="built_in">strpy</span>(HC[i], &amp;cd[start]);<span class="comment">//将求得的编码从临时空间cd复制到HC的当前行中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> cd;<span class="comment">//释放临时空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、并查集"><a href="#三、并查集" class="headerlink" title="三、并查集"></a>三、并查集</h3><h4 id="1-并查集（双亲表示法）"><a href="#1-并查集（双亲表示法）" class="headerlink" title="1.并查集（双亲表示法）"></a>1.并查集（双亲表示法）</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011215536023.png" alt="image-20221011215536023"></p><p>使用<font color='#BAOC2F'>双亲表示法</font>，每个结点中保存指向双亲的指针，并和查的方式更加方便。（声明一个数组S即可表示集合的关系）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011215732244.png" alt="image-20221011215732244"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXTSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PTNode</span> &#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> parent;<span class="comment">//双亲位置域</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    PTNode nodes[MAXTSIZE];<span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> r;<span class="comment">//根结点的位置</span></span><br><span class="line">    <span class="type">int</span> n;<span class="comment">//结点的个数</span></span><br><span class="line">&#125; PTree;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011215812129.png" alt="image-20221011215812129"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并查集初始化</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 13</span></span><br><span class="line"><span class="type">int</span> UFSets[SIZE];<span class="comment">//集合元素数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initial</span><span class="params">(<span class="type">int</span> S[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) S[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并查集基本操作</span></span><br><span class="line"><span class="comment">//Find查操作，找到x所属集合（返回x所属根结点）时间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x] &gt;= <span class="number">0</span>) x = S[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Union并操作，将两个结合合并为一个时间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> Root1, <span class="type">int</span> Root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Root1 == Root2) <span class="keyword">return</span>;<span class="comment">//要求Root1与Root2是不同的集合</span></span><br><span class="line">    S[Root2] = Root1;<span class="comment">//将根Root2连接到另一根Root1的下面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-并查集优化Union（小树并大树）："><a href="#2-并查集优化Union（小树并大树）：" class="headerlink" title="2.并查集优化Union（小树并大树）："></a>2.并查集优化Union（小树并大树）：</h4><p>在并查集的Find操作中，若<font color='#BAOC2F'>结点数量为n</font>则Find最坏时间复杂度为<code>O(n)</code></p><p>优化思路：在每次Union操作构建树的时候，尽可能让<font color='#BAOC2F'>树不长太高</font>（小树合并到大树）。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011220011086.png" alt="image-20221011220011086"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011220036683.png" alt="image-20221011220036683"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并查集基本操作</span></span><br><span class="line"><span class="comment">//Find查操作，找到x所属集合（返回x所属根结点）时间复杂度O(log2n)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x] &gt;= <span class="number">0</span>) x = S[x];</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Union并操作，小树合并到大树时间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> Root1, <span class="type">int</span> Root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Root1 == Root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (S[Root2] &gt; S[Root1]) &#123;<span class="comment">//Root2结点数更少</span></span><br><span class="line">        S[Root1] += S[Root2];<span class="comment">//累加结点总数</span></span><br><span class="line">        S[Root2] = Root1;<span class="comment">//小树合并到大树</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//Root1结点数更少</span></span><br><span class="line">        S[Root2] += S[Root1];</span><br><span class="line">        S[Root1] = Root2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法构造的树高度不超过[log2n] + 1</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011220141745.png" alt="image-20221011220141745"></p><h4 id="3-并查集进一步优化Find（路径压缩）："><a href="#3-并查集进一步优化Find（路径压缩）：" class="headerlink" title="3.并查集进一步优化Find（路径压缩）："></a>3.并查集进一步优化Find（路径压缩）：</h4><p>Find操作的优化：压缩路径，先找到根节点、再将查找路径上的<font color='#BAOC2F'>所有结点</font>都<font color='#BAOC2F'>挂到根结点下面</font>。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011220212030.png" alt="image-20221011220212030"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011220228477.png" alt="image-20221011220228477"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并查集基本操作</span></span><br><span class="line"><span class="comment">//Find查操作优化，先找到根节点再进行路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> root = x;</span><br><span class="line">    <span class="keyword">while</span> (S[root] &gt;= <span class="number">0</span>) root = S[root];<span class="comment">//循环查找根</span></span><br><span class="line">    <span class="keyword">while</span> (x != root) &#123;<span class="comment">//压缩路径</span></span><br><span class="line">        <span class="type">int</span> t = S[x];<span class="comment">//t指向x的父节点</span></span><br><span class="line">        S[x] = root;<span class="comment">//x直接挂到根节点下</span></span><br><span class="line">        x = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;<span class="comment">//返回根节点编号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Union并操作，小树合并到大树时间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> S[], <span class="type">int</span> Root1, <span class="type">int</span> Root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Root1 == Root2) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (S[Root2] &gt; S[Root1]) &#123;<span class="comment">//Root2结点数更少</span></span><br><span class="line">        S[Root1] += S[Root2];<span class="comment">//累加结点总数</span></span><br><span class="line">        S[Root2] = Root1;<span class="comment">//小树合并到大树</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//Root1结点数更少</span></span><br><span class="line">        S[Root2] += S[Root1];</span><br><span class="line">        S[Root1] = Root2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法构造的树高度不超过[log2n] + 1</span></span><br></pre></td></tr></table></figure><p>优化后的并查集的Find、Union操作时间复杂度都很低。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011220310016.png" alt="image-20221011220310016"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221011220618604.png" alt="image-20221011220618604"></p><h3 id="四、二叉树经典问题"><a href="#四、二叉树经典问题" class="headerlink" title="四、二叉树经典问题"></a>四、二叉树经典问题</h3><h4 id="1-数据压缩"><a href="#1-数据压缩" class="headerlink" title="1.数据压缩"></a>1.数据压缩</h4><ul><li>数据压缩：<a href="https://zhuanlan.zhihu.com/p/144562146">https://zhuanlan.zhihu.com/p/144562146</a></li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220505065115558.png" alt="image-20220505065115558"></p><h4 id="2-表达式求值"><a href="#2-表达式求值" class="headerlink" title="2.表达式求值"></a>2.表达式求值</h4><ul><li>Cpp：<a href="https://www.pudn.com/news/62ac953fca7ee606dccd7b69.html">https://www.pudn.com/news/62ac953fca7ee606dccd7b69.html</a></li><li>Java：<a href="https://blog.csdn.net/qq_44028290/article/details/106376961">https://blog.csdn.net/qq_44028290&#x2F;article&#x2F;details&#x2F;106376961</a></li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220505065410225.png" alt="image-20220505065410225"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220506074421842.png" alt="image-20220506074421842"></p>]]></content>
      
      
      <categories>
          
          <category> datestructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> datestructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章：图（上）</title>
      <link href="/2023/02/28/dataStructure/7.%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%9B%BE%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2023/02/28/dataStructure/7.%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%9B%BE%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="第六章：图（上）"><a href="#第六章：图（上）" class="headerlink" title="第六章：图（上）"></a>第六章：图（上）</h1><hr><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><h4 id="1-图G相关概念："><a href="#1-图G相关概念：" class="headerlink" title="1.图G相关概念："></a>1.图G相关概念：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Graph = (Vertex, Edge)</span><br><span class="line">G = (V, E)</span><br><span class="line"><span class="comment">//V:顶点（数据元素）的有穷非空集合</span></span><br><span class="line"><span class="comment">//E:边的有穷集合</span></span><br></pre></td></tr></table></figure><ol><li>无向图：每条边都是无方向的</li><li>有向图：每条边都是有方向的</li><li>完全图：任意两个点都有一条边相连</li><li>稀疏图：有很少边&#x2F;弧的图</li><li>稠密图：有较多边&#x2F;弧的图</li><li>网：边&#x2F;弧带有权重的图</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221129104309288.png" alt="image-20221129104309288"></p><h4 id="2-顶点V相关概念："><a href="#2-顶点V相关概念：" class="headerlink" title="2.顶点V相关概念："></a>2.顶点V相关概念：</h4><ol><li>邻接：边&#x2F;弧相连的两个顶点之间的关系，例如：(vi, vj)称为vi和vj<font color='#BAOC2F'>互为邻接点</font>、&lt;vi, vj&gt;称vi邻接到vj，vj邻接于vi</li><li>关联&#x2F;依附：边&#x2F;弧与顶点之间的关系，例如：(vi, vj)&#x2F;&lt;vi, vj&gt;称为该边&#x2F;弧关联于vi和vj</li><li>顶点的度：与该顶点相关联的边的数目，记为TD(v)，在有向图中<font color='#BAOC2F'>顶点的度</font>等于<font color='#BAOC2F'>该顶点的入度与出度之和</font>。</li><li>顶点的入度：<font color='#BAOC2F'>以v为终点</font>的有向边的条数，记作ID(v)</li><li>顶点的出度：<font color='#BAOC2F'>以v为始点</font>的有向边的条数，记作OD(v)</li></ol><h4 id="3-边E相关的概念："><a href="#3-边E相关的概念：" class="headerlink" title="3.边E相关的概念："></a>3.边E相关的概念：</h4><ol><li>路径：接续的边构成的顶点序列</li><li>路径长度：路径上边&#x2F;弧的数目&#x2F;<font color='#BAOC2F'>权值之和</font></li><li>回路：第一个顶点和最后一个顶点相同的路径。</li><li>简单路径：除路径起点和终点<font color='#BAOC2F'>可以相同</font>外，<font color='#BAOC2F'>其余顶点均不相同</font>的路径。</li><li>简单回路：除路径起点和终点<font color='#BAOC2F'>相同</font>外，其余顶点均不相同的路径。</li><li>连通：无向图中两个顶点间有路径存在，则称为连通。</li><li>强连通：有向图中两个顶点间有正向、逆向的路径，则称为强连通。</li><li>连通图：无向图中任意两个顶点之间都是连通的，则称为连通图</li><li>强连通图：有向图中任意两个顶点之间都是强连通的，则称为强连通图</li></ol><blockquote><p>&#x3D;&#x3D;补充：有向图无向图边数问题&#x3D;&#x3D;</p><ul><li>对于n个顶点的无向图G，若G是<font color='#BAOC2F'>连通图</font>则最少有n-1条边，若G是<font color='#BAOC2F'>非连通图</font>则最多可能有$C_{n-1}^2$条边</li><li>对于n个顶点的有向图G，若G是<font color='#BAOC2F'>强连通图</font>则最少有n条边（即形成一条回路）</li></ul></blockquote><h4 id="4-子图G相关概念："><a href="#4-子图G相关概念：" class="headerlink" title="4.子图G相关概念："></a>4.子图G相关概念：</h4><ol><li><p>连通分量：无向图中的<font color='#BAOC2F'>极大连通子图</font>称为连通分量（子图必须连通，且包含尽可能多的顶点和边）</p></li><li><p>强连通分量：有向图中的<font color='#BAOC2F'>极大强连通子图</font>称为强连通分量（子图必须强连通，同时保留尽可能多的边）</p><p> <img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221130070416074.png" alt="image-20221130070416074"></p></li><li><p>生成树：是一个<font color='#BAOC2F'>连通图</font>中，<font color='#BAOC2F'>包含全部顶点</font>的一个<font color='#BAOC2F'>极小连通子图</font>（边尽可能的少，但要保持连通）。</p><p> 若图中顶点数为n则它的生成树含有n-1条边，对生成树而言若砍去1条边则变成非连通图，若加上1条边则会形成回路。</p><p> <img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221130085552087.png" alt="image-20221130085552087"></p></li><li><p>生成森林：是一个<font color='#BAOC2F'>非连通图</font>中，<font color='#BAOC2F'>连通分量的生成树</font>构成了非连通图的生成森林。</p><p> <img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221130093933281.png" alt="image-20221130093933281"></p></li></ol><h3 id="二、图的存储结构"><a href="#二、图的存储结构" class="headerlink" title="二、图的存储结构"></a>二、图的存储结构</h3><h4 id="1-数组表示法AdjacencyMatrix"><a href="#1-数组表示法AdjacencyMatrix" class="headerlink" title="1.数组表示法AdjacencyMatrix"></a>1.数组表示法AdjacencyMatrix</h4><p>顶点表是一个一维数组<code>Vexs[n]</code>用于存放各个顶点的信息：</p><p>邻接矩阵是一个二维数组<code>A.arcs[n][n]</code>用于存放各个顶点之间边的关系：<br>$$<br>A.arc[i][j]&#x3D;\begin{cases}<br>1,~~~~~if~(Vi, Vj)∈E ~~或&lt;Vi,Vj&gt;∈E \<br>\<br>\<br>0,~~~~~else<br>\end{cases}<br>$$</p><h5 id="（1）无向图邻接矩阵表示"><a href="#（1）无向图邻接矩阵表示" class="headerlink" title="（1）无向图邻接矩阵表示"></a>（1）无向图邻接矩阵表示</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220609102834944.png" alt="image-20220609102834944"></p><ol><li>只要确定了顶点编号，图的邻接矩阵表示方式唯一</li><li>顶点<code>i</code>的度 &#x3D; 第<code>i</code>行&#x2F;列中1的个数</li><li>无向图的邻接矩阵是<font color='#BAOC2F'>对称的</font></li><li><font color='#BAOC2F'>完全图</font>的邻接矩阵中，对角元素为0其余全为1</li><li>设图G的邻接矩阵为A（矩阵元素为0&#x2F;1），则A<sup>n</sup>的元素$A^n[i][j]$等于由顶点<code>i</code>到顶点<code>j</code>的长度为<code>n</code>的路径的数目。</li></ol><h5 id="（2）有向图邻接矩阵表示"><a href="#（2）有向图邻接矩阵表示" class="headerlink" title="（2）有向图邻接矩阵表示"></a>（2）有向图邻接矩阵表示</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221129113028397.png" alt="image-20221129113028397"></p><ol><li>有向图的邻接矩阵可能是<font color='#BAOC2F'>不对称的</font></li><li>顶点的出度&#x3D;第<code>i</code>行元素之和、顶点的入度&#x3D;第<code>i</code>列元素之和</li><li>顶点的度&#x3D;第<code>i</code>行元素之和+第<code>i</code>列元素之和</li></ol><blockquote><p>&#x3D;&#x3D;补充&#x3D;&#x3D;：由<font color='#BAOC2F'>邻接矩阵表示有向图</font>可引出，<font color='#BAOC2F'>邻接矩阵表示有向网</font>：</p><p>其中邻接矩阵重新定义为<code>A.arcs[n][n]</code>：<br>$$<br>A.arc[i][j]&#x3D;\begin{cases}<br>Wij,~~~~~if<del>(Vi, Vj)∈E ~~或&lt;Vi,Vj&gt;∈E \<br>\<br>\<br>\infty,~~~~~else</del>(无边&#x2F;弧)<br>\end{cases}<br>$$<br>如下图所示：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220609111055234.png" alt="image-20220609111055234"></p></blockquote><h5 id="（3）邻接矩阵建立无向网★"><a href="#（3）邻接矩阵建立无向网★" class="headerlink" title="（3）邻接矩阵建立无向网★"></a>（3）邻接矩阵建立无向网★</h5><p>邻接矩阵的存储表示：用两个数组分别存储<font color='#BAOC2F'>顶点表</font>和<font color='#BAOC2F'>邻接矩阵</font>，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxInt IFINITY<span class="comment">//表示极大值无穷</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> VerTexType;<span class="comment">//设置边的权值类型为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> AcrType;<span class="comment">//设置顶点的数据类型字符型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    VerTexType vexs[MVNum];<span class="comment">//顶点表</span></span><br><span class="line">    AcrType arcs[MVNum][MVNum];<span class="comment">//邻接矩阵or边表</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125; AMGraph;<span class="comment">//Adjacency Matrix Graph</span></span><br></pre></td></tr></table></figure><p>采用邻接矩阵表示法创建<font color='#BAOC2F'>无向网</font>：</p><ol><li>输入总顶点vexnum数和总边数arcnum</li><li>建立顶点表：依次输入点的信息存入顶点表中</li><li>初始化邻接矩阵，使每个<font color='#BAOC2F'>权值初始化为极大值</font></li><li>根据图G的边的情况构造邻接矩阵</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">createUDN</span><span class="params">(AMGraph &amp;G)</span> </span>&#123;<span class="comment">//采用邻接矩阵表示法，创建Undirected Net无向网</span></span><br><span class="line">    <span class="comment">//1.输入图的顶点数与边数</span></span><br><span class="line">    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line">    <span class="comment">//2.输入顶点信息</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vernum; ++i) cin &gt;&gt; G.vex[i];</span><br><span class="line">    <span class="comment">//3.初始化邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; G.vexnum; ++j)</span><br><span class="line">            G.arcs[i][j] = MaxInt;<span class="comment">//边的权值均设为最大值</span></span><br><span class="line">    <span class="comment">//4.构造邻接矩阵（输入边信息）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.arcnums; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w;<span class="comment">//输入一条边所依附的顶点及边的权值</span></span><br><span class="line">        i = <span class="built_in">LocateVex</span>(G, v1);</span><br><span class="line">        j = <span class="built_in">LocateVex</span>(G, v2);<span class="comment">//确定v1和v2在G中的位置</span></span><br><span class="line">        G.arcs[i][j] = w;<span class="comment">//边&lt;v1, v2&gt;的权值置为w</span></span><br><span class="line">        G.arcs[j][i] = G.arcs[i][j];<span class="comment">//对称边&lt;v2, v1&gt;的权值置为w</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220609114146677.png" alt="image-20220609114146677"></p><h5 id="（4）邻接矩阵表示法分析："><a href="#（4）邻接矩阵表示法分析：" class="headerlink" title="（4）邻接矩阵表示法分析："></a>（4）邻接矩阵表示法分析：</h5><table><thead><tr><th>优点</th></tr></thead><tbody><tr><td>直观、简单、易于理解</td></tr><tr><td>便于检查<font color='#BAOC2F'>任意一对顶点</font>之间是否存在联系（边）</td></tr><tr><td>便于找到<font color='#BAOC2F'>任意顶点</font>的所有邻接点（有联系的点）</td></tr><tr><td>便于计算<font color='#BAOC2F'>任意顶点</font>的度：从该点出发的边数为出度、指向该点的边数为入度</td></tr></tbody></table><table><thead><tr><th>缺点</th></tr></thead><tbody><tr><td>不利于增加和删除顶点</td></tr><tr><td>浪费空间—存储稀疏图，点很多而边很少有大量无效元素</td></tr><tr><td>浪费时间—统计稀疏图中一共有多少条边</td></tr></tbody></table><h4 id="2-链式表示法AdjacencyList"><a href="#2-链式表示法AdjacencyList" class="headerlink" title="2.链式表示法AdjacencyList"></a>2.链式表示法AdjacencyList</h4><p>建立一个<font color='#BAOC2F'>顶点表</font>记录各个顶点的信息 和一个<font color='#BAOC2F'>线性链表</font>记录关联着同一顶点的边的信息</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221129125459135.png" alt="image-20221129125459135"></p><h5 id="（1）无向图邻接表表示"><a href="#（1）无向图邻接表表示" class="headerlink" title="（1）无向图邻接表表示"></a>（1）无向图邻接表表示</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220609120726654.png" alt="image-20220609120726654"></p><ol><li>邻接表<font color='#BAOC2F'>不是唯一的</font>，链表结点的顺序是可调换的。</li><li>无向图中顶点<code>vi</code>的度即为第<code>i</code>个单链表中的<font color='#BAOC2F'>节点数</font>。</li><li>若无向图中有n个顶点与e条边，则邻接表需要n个头结点与2e个表结点来存储（更适合<font color='#BAOC2F'>稀疏矩阵的存储</font>）</li></ol><h5 id="（2）有向图邻接表表示"><a href="#（2）有向图邻接表表示" class="headerlink" title="（2）有向图邻接表表示"></a>（2）有向图邻接表表示</h5><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220609121444700.png" alt="image-20220609121444700"></p><ol><li>有向图中顶点<code>Vi</code>的<font color='#BAOC2F'>出度</font>即为第<code>i</code>个单链表中的<font color='#BAOC2F'>结点数</font>。</li><li>有向图中顶点<code>Vi</code>的<font color='#BAOC2F'>入度</font>即为<font color='#BAOC2F'>整个单链表中的邻接点域值</font>为<code>i-1</code>的<font color='#BAOC2F'>结点数</font>（困难）。</li></ol><h5 id="（3）邻接表建立无向图★"><a href="#（3）邻接表建立无向图★" class="headerlink" title="（3）邻接表建立无向图★"></a>（3）邻接表建立无向图★</h5><p>邻接表的存储表示：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221129130505524.png" alt="image-20221129130505524"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MVNum 100<span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="comment">//顶点的结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">VNode</span> &#123;</span><br><span class="line">    VerTexTyped data;<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstarc;<span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">&#125; VNode, AdjList[MVNum];<span class="comment">//AdjList表示邻接表类型，即AdjList v;相当于VNode v[MVNum];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//边的结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">ArcNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//该边所指向的顶点的位置</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ArcNode</span> *nextarc;<span class="comment">//指向下一条边的指针</span></span><br><span class="line">    OtherInfo info;<span class="comment">//与边相关的信息</span></span><br><span class="line">&#125; ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图的结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    AdjList vertices;<span class="comment">//vertexs</span></span><br><span class="line">    <span class="type">int</span> vexnum, arcnum;<span class="comment">//图的当前顶点数和边数</span></span><br><span class="line">&#125; ALGraph;</span><br></pre></td></tr></table></figure><p>采用邻接表表示法创建<font color='#BAOC2F'>无向图</font>：</p><ol><li><p>输入总顶点vexnum数和总边数arcnum</p></li><li><p>建立顶点表：依次输入点的信息存入顶点表中，并且使每个<font color='#BAOC2F'>表头结点的指针域</font>初始化为NULL</p></li><li><p>根据图G的边的情况构造邻接表（单链表）：</p><p> 依次输入每条边依附的两个顶点，查找两个顶点的序号<code>i</code>和<code>j</code>建立边结点</p><p> 将此边结点分别插入到<code>vi</code>和<code>vj</code>对应的两个<font color='#BAOC2F'>边链表</font>的头部</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">createUDG</span><span class="params">(ALGraph &amp;G)</span> </span>&#123;<span class="comment">//采用邻接表表示法，创建Undirected Graph无向网</span></span><br><span class="line">    <span class="comment">//1.输入图的顶点数与边数</span></span><br><span class="line">    cin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;</span><br><span class="line">    <span class="comment">//2.输入表头顶点信息 构造表头结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vernum; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; G.vertices[i].data;<span class="comment">//输入顶点值</span></span><br><span class="line">        G.vertices[i].firstarc = <span class="literal">NULL</span>;<span class="comment">//初始化表头结点的指针域</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.输入边结点信息 构造邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.arcnums; ++i) &#123;</span><br><span class="line">        cin &gt;&gt; v1 &gt;&gt; v2;<span class="comment">//输入一条边所依附的两个顶点</span></span><br><span class="line">        i = <span class="built_in">LocateVex</span>(G, v1);</span><br><span class="line">        j = <span class="built_in">LocateVex</span>(G, v2);<span class="comment">//确定v1和v2在G中的位置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//(1)生成一个新的边结点*p1</span></span><br><span class="line">        p1 = <span class="keyword">new</span> ArcNode;</span><br><span class="line">        p1-&gt;adjvex = j;<span class="comment">//邻接点序号为j</span></span><br><span class="line">        p1-&gt;nextarc = G.vertices[i].firstarc;</span><br><span class="line">        G.vertices[i].firstarc = p1;<span class="comment">//将新结点*p1插入顶点Vi的边表头部</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//(2)生成一个新的对称边结点*p2</span></span><br><span class="line">        p2 = <span class="keyword">new</span> ArcNode;</span><br><span class="line">        p2-&gt;adjvex = i;<span class="comment">//邻接点序号为i</span></span><br><span class="line">        p2-&gt;nextarc = G.vertices[j].firstarc;</span><br><span class="line">        G.vertices[j].firstarc = p2;<span class="comment">//将新结点*p2插入顶点Vj的边表头部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（4）邻接表表示法分析："><a href="#（4）邻接表表示法分析：" class="headerlink" title="（4）邻接表表示法分析："></a>（4）邻接表表示法分析：</h5><table><thead><tr><th>优点</th></tr></thead><tbody><tr><td>节约稀疏图的空间：需要N个头指针+2E个结点（每个结点至少2个域）</td></tr><tr><td>便于找到<font color='#BAOC2F'>任意顶点</font>的所有邻接点（有联系的点）</td></tr><tr><td>便于计算<font color='#BAOC2F'>任意顶点</font>的度：对于无向图方便，对于有向图只能计算出度，入度需要逆邻接表来计算</td></tr></tbody></table><table><thead><tr><th>缺点</th></tr></thead><tbody><tr><td>不便于检查<font color='#BAOC2F'>任意一对顶点</font>之间是否存在联系（边）</td></tr></tbody></table><p>&#x3D;&#x3D;邻接矩阵与邻接表之间的对比&#x3D;&#x3D;：</p><p>联系：邻接表中每个<font color='#BAOC2F'>链表</font>对应于邻接<font color='#BAOC2F'>矩阵中的一行</font>，链表中<font color='#BAOC2F'>结点的个数</font>等于矩阵<font color='#BAOC2F'>行中非零元素的个数</font>。</p><table><thead><tr><th>对比</th><th>邻接矩阵</th><th>邻接表</th></tr></thead><tbody><tr><td>复杂度</td><td>邻接矩阵的空间复杂度为O（n<sup>2</sup>）</td><td>邻接表的空间复杂度为O（n+e）顶点数+边数</td></tr><tr><td>应用性</td><td>邻接矩阵多用于稠密图</td><td>邻接表多用于稀疏图</td></tr><tr><td>表示方式</td><td>邻接矩阵是唯一的（行列号与顶点编号一致）</td><td>邻接表不是唯一的（链表次序与顶点编号无关）对于任意<font color='#BAOC2F'>无向图</font></td></tr><tr><td>邻边查找</td><td>邻接矩阵必须遍历对应的行&#x2F;列</td><td>邻接表找<font color='#BAOC2F'>有向图入边</font>不方便（其余很方便）</td></tr></tbody></table><h4 id="3-链式表示法的改进："><a href="#3-链式表示法的改进：" class="headerlink" title="3.链式表示法的改进："></a>3.链式表示法的改进：</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220610133350668.png" alt="image-20220610133350668"></p><table><thead><tr><th>邻接表缺点</th><th>方案</th><th>具体</th></tr></thead><tbody><tr><td>有向图时<font color='#BAOC2F'>度计算困难</font>（邻接表便于求出度、逆邻接表便于求入度）</td><td>十字链表</td><td><font color='#BAOC2F'>邻接表</font>和<font color='#BAOC2F'>逆邻接表</font>结合形成的链表。</td></tr><tr><td>存储无向图时<font color='#BAOC2F'>每条边重复存储</font>的问题</td><td>邻接多重表</td><td>删除边、删除结点等操作十分的方便</td></tr></tbody></table><h5 id="（1）十字链表："><a href="#（1）十字链表：" class="headerlink" title="（1）十字链表："></a>（1）十字链表：</h5><p>十字链表Orthogonal List，</p><ol><li>是<font color='#BAOC2F'>只能用于存储有向图</font>的一种链式存储结构，</li><li>为了解决<font color='#BAOC2F'>有向图度</font>计算困难问题，将有向图的<font color='#BAOC2F'>邻接表</font>和<font color='#BAOC2F'>逆邻接表</font>结合起来形成的链表。</li><li>有向图中的弧对应十字链表中的<font color='#BAOC2F'>弧结点</font>，有向图中的<font color='#BAOC2F'>顶点</font>在十字链表中有对应的<font color='#BAOC2F'>顶点结点</font>。</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221201083212734.png" alt="image-20221201083212734"></p><p>&#x3D;&#x3D;案例演示&#x3D;&#x3D;：根据如下有向图<font color='#BAOC2F'>建立十字链表</font>。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220610140800222.png" alt="image-20220610140800222"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220610141020464.png" alt="image-20220610141020464"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220610141030988.png" alt="image-20220610141030988"></p><p>十字链表建立完毕</p><h5 id="（2）邻接多重表："><a href="#（2）邻接多重表：" class="headerlink" title="（2）邻接多重表："></a>（2）邻接多重表：</h5><p>邻接多重表，</p><ol><li>是<font color='#BAOC2F'>只能用于存储无向图</font>的一种链式存储结构，</li><li>为了解决邻接表存储无向图时<font color='#BAOC2F'>每条边重复存储</font>的问题而提出的。</li><li>删除边、删除结点等操作十分的方便</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221201090033627.png" alt="image-20221201090033627"></p><p>&#x3D;&#x3D;案例演示&#x3D;&#x3D;：根据如下无向图<font color='#BAOC2F'>建立邻接多重表</font>：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220610172039776.png" alt="image-20220610172039776"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220610173331143.png" alt="image-20220610173331143"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220610173341423.png" alt="image-20220610173341423"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220610173350462.png" alt="image-20220610173350462"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221201091650171.png" alt="image-20221201091650171"></p><h3 id="三、图的遍历"><a href="#三、图的遍历" class="headerlink" title="三、图的遍历"></a>三、图的遍历</h3><blockquote><p>注：遍历的实质就是找到<font color='#BAOC2F'>每一个顶点的邻接点</font>的过程（需要设置visit数组避免重复访问结点的问题）</p></blockquote><h4 id="1-广度优先搜索BFS"><a href="#1-广度优先搜索BFS" class="headerlink" title="1.广度优先搜索BFS"></a>1.广度优先搜索BFS</h4><h5 id="（1）BFS思想："><a href="#（1）BFS思想：" class="headerlink" title="（1）BFS思想："></a>（1）BFS思想：</h5><blockquote><p>注：连通图的广度优先遍历类似于<font color='#BAOC2F'>树的层次遍历</font>，需要一个<font color='#BAOC2F'>辅助队列</font>。</p></blockquote><ol><li>从图中某结点出发，首先依次访问该结点的<font color='#BAOC2F'>所有相邻邻接结点</font>vi1、vi2、…vin（同一层）</li><li>再按照这些顶点被访问的先后次序，依次访问与它们<font color='#BAOC2F'>相邻的</font>所有<font color='#BAOC2F'>未被访问的</font>顶点</li><li>重复此过程，直到所有顶点均被访问为止</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220611102814351.png" alt="image-20220611102814351"></p><p>&#x3D;&#x3D;BFS具体过程如下&#x3D;&#x3D;：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220611104125870.png" alt="image-20220611104125870"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221201104427135.png" alt="image-20221201104427135"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221201104546092.png" alt="image-20221201104546092"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221201104842078.png" alt="image-20221201104842078"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221201105009924.png" alt="image-20221201105009924"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221201105321891.png" alt="image-20221201105321891"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221201105330345.png" alt="image-20221201105330345"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221201105442729.png" alt="image-20221201105442729"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221201105523979.png" alt="image-20221201105523979"></p><h5 id="（2）BFS的实现："><a href="#（2）BFS的实现：" class="headerlink" title="（2）BFS的实现："></a>（2）BFS的实现：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];<span class="comment">//访问标记数组（初始值都为false）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph G)</span> </span>&#123;<span class="comment">//对图G进行广度优先遍历（处理非连通图）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) visited[i] = FALSE;<span class="comment">//对访问标记数组初始化</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) &#123;<span class="comment">//从0号顶点开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;<span class="comment">//对每个连通分量调用一次BFS</span></span><br><span class="line">            <span class="built_in">BFS</span>(G, i);<span class="comment">//Vi未访问过则从vi开始BFS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> </span>&#123;<span class="comment">//从顶点v出发 广度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);<span class="comment">//访问初始顶点v</span></span><br><span class="line">    visited[v] = TRUE;<span class="comment">//对v做已标记访问</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);<span class="comment">//辅助队列Q初始化 置空</span></span><br><span class="line">    <span class="built_in">EnQueue</span>(Q, v);<span class="comment">//v入队列Q</span></span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isEmpty</span>(Q)) &#123;</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, u);<span class="comment">//队头元素出队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w = <span class="built_in">FirstNeighbor</span>(G, u); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(G, u, w)) &#123;</span><br><span class="line">            <span class="comment">//w为u的尚未访问的邻接顶点</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                <span class="built_in">visit</span>(w);</span><br><span class="line">                visited[w] = TRUE;</span><br><span class="line">                <span class="built_in">EnQueue</span>(Q, W);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="（3）算法分析："><a href="#（3）算法分析：" class="headerlink" title="（3）算法分析："></a>（3）算法分析：</h5><ul><li>用邻接矩阵来表示图，BFS对于每一个被访问到的顶点，都要循环检测矩阵中的完整一行（n个元素），时间复杂度为O（n<sup>2</sup>）</li><li>用邻接表来表示图，虽然有2e个<font color='#BAOC2F'>表结点</font>但是只需扫描e个结点即可，加上访问n个<font color='#BAOC2F'>头结点</font>的时间，时间复杂度为O（n + e）</li><li>同一个图的<font color='#BAOC2F'>邻接矩阵表示方式唯一</font>，因此广度优先遍历序列唯一</li><li>同一个图的<font color='#BAOC2F'>邻接表表示方式不唯一</font>，因此广度优先遍历序列不唯一</li></ul><h4 id="2-深度优先搜索DFS"><a href="#2-深度优先搜索DFS" class="headerlink" title="2.深度优先搜索DFS"></a>2.深度优先搜索DFS</h4><h5 id="（1）DFS思想："><a href="#（1）DFS思想：" class="headerlink" title="（1）DFS思想："></a>（1）DFS思想：</h5><blockquote><p>注：连通图的深度优先遍历类似于<font color='#BAOC2F'>树的先根遍历</font>，需要一个<font color='#BAOC2F'>辅助栈</font>。</p></blockquote><ol><li><p>在访问图中起始顶点<code>v</code>之后，由顶点<code>v</code>出发访问它的任一<font color='#BAOC2F'>邻接顶点</font><code>v1</code></p></li><li><p>在访问图中邻接顶点<code>v1</code>之后，由顶点<code>v1</code>出发访问它的任一<font color='#BAOC2F'>邻接但是还没有被访问过的</font>顶点<code>v2</code></p></li><li><p>在访问图中邻接顶点<code>v2</code>之后，进行类似的访问v3、v4、v5…直到所有的邻接顶点都被访问过为止</p></li><li><p>当在<font color='#BAOC2F'>某顶点时</font>其<font color='#BAOC2F'>所有邻接顶点都被访问过</font>，退到<font color='#BAOC2F'>上一个访问过的顶点</font>检测其是否还有<font color='#BAOC2F'>没有被访问过的</font>邻接顶点（回溯）</p><p> 如果有则对该<font color='#BAOC2F'>未访问顶点</font>进行访问，再从该顶点出发，进行类似的访问v3、v4、v5…直到所有的邻接顶点都被访问过为止</p><p> 如果没有则<font color='#BAOC2F'>再退到上一个访问过的顶点</font>检测其是否还有<font color='#BAOC2F'>没有被访问过的</font>邻接顶点（继续回溯）</p></li><li><p>重复上述过程，直到连通图中的所有顶点都被访问过为止。</p></li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220611100033459.png" alt="image-20220611100033459"></p><h5 id="（2）DFS的实现："><a href="#（2）DFS的实现：" class="headerlink" title="（2）DFS的实现："></a>（2）DFS的实现：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> visited[MAX_VERTEX_NUM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph G)</span> </span>&#123;<span class="comment">//对图G进行深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G.vexnum; ++i) visited[i] = FALSE;<span class="comment">//初始标记化数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; G,vexnum; ++i) &#123;<span class="comment">//从v = 0开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(G, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS</span><span class="params">(Graph G, <span class="type">int</span> v)</span> </span>&#123;<span class="comment">//从顶点v出发 深度优先遍历图G</span></span><br><span class="line">    <span class="built_in">visit</span>(v);<span class="comment">//访问顶点v</span></span><br><span class="line">    visited[v] = TRUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> w = <span class="built_in">FirstNeighbor</span>(G, v); w &gt;= <span class="number">0</span>; w = <span class="built_in">NextNeighbor</span>(G, v, w)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[w]) &#123;<span class="comment">//w为u的尚未访问的邻接结点</span></span><br><span class="line">            <span class="built_in">DFS</span>(G, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>如果图的存储结构确定（此处邻接矩阵结构确定）时，则DFS遍历的顺序只有一种</li><li>回溯的过程即为if不执行的情况，无需书写！</li></ol><h5 id="（3）算法分析：-1"><a href="#（3）算法分析：-1" class="headerlink" title="（3）算法分析："></a>（3）算法分析：</h5><ul><li>用邻接矩阵来表示图，遍历图中的每一个顶点都要<font color='#BAOC2F'>从头扫描该顶点所在的行</font>，时间复杂度为O（n<sup>2</sup>）</li><li>用邻接表来表示图，虽然有2e个<font color='#BAOC2F'>表结点</font>但是只需扫描e个结点即可，加上访问n个<font color='#BAOC2F'>头结点</font>的时间，时间复杂度为O（n + e）</li></ul><p>&#x3D;&#x3D;DFS与BFS算法效率比较&#x3D;&#x3D;：</p><ol><li>空间复杂度相同O（n）：DFS借用了栈，而BFS借用了队列</li><li>时间复杂度<font color='#BAOC2F'>只与存储结构有关</font>，而与搜索的路径无关DFS&#x2F;BFS</li></ol>]]></content>
      
      
      <categories>
          
          <category> datestructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> datestructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章：查找</title>
      <link href="/2023/02/27/dataStructure/9.%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%9F%A5%E6%89%BE/"/>
      <url>/2023/02/27/dataStructure/9.%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="第七章：查找"><a href="#第七章：查找" class="headerlink" title="第七章：查找"></a>第七章：查找</h1><hr><ul><li>主关键字：可唯一标识记录的关键字</li><li>次关键字：用以识别若干记录的关键字</li><li>关键字的平均比较次数，平均查找长度ASL（Average Search Length）</li></ul><p>$$<br>ASL &#x3D; \sum_{i&#x3D;1}^np_ic_i<br>$$</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">n</td><td align="center">记录的个数</td></tr><tr><td align="center">p<sub>i</sub></td><td align="center">查找到第i个记录的概率</td></tr><tr><td align="center">c<sub>i</sub></td><td align="center">查找到第i个记录所需的比较次数</td></tr></tbody></table><h3 id="一、线性表的查找"><a href="#一、线性表的查找" class="headerlink" title="一、线性表的查找"></a>一、线性表的查找</h3><h4 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1.顺序查找"></a>1.顺序查找</h4><p>应用范围：顺序表或线性表表示的<font color='#BAOC2F'>静态查找表</font>（表内元素无序）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType *R;<span class="comment">//表基址</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//表长</span></span><br><span class="line">&#125; SSTable;<span class="comment">//Sequential Search Table</span></span><br><span class="line">SSTable ST;<span class="comment">//定义顺序表ST</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529101335983.png" alt="image-20220529101335983"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529101622530.png" alt="image-20220529101622530"></p><p>注意到每执行一次循环都要进行两次比较，</p><p> 改进：&#x3D;&#x3D;利用哨兵简化减少for循环比较次数&#x3D;&#x3D;，将待查关键字key存入表头，可免去查找过程中每一步都要检测是否查找完毕（加快速度）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529102444216.png" alt="image-20220529102444216"></p><blockquote><p>注意：当<code>ST.length</code>比较大时，此改进能使进行一次查找所需要的平均时间几乎减少一半。</p></blockquote><p>顺序查找法优点：算法简单，逻辑次序无要求，且不同存储结构均适用</p><p>顺序查找法缺点：ASL太长时间效率太低</p><h4 id="2-折半查找"><a href="#2-折半查找" class="headerlink" title="2.折半查找"></a>2.折半查找</h4><p>折半查找每次可将待查找记录所在的区间缩小一半，</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529110344292.png" alt="image-20220529110344292"></p><ol><li><p>low、hight、mid分别指向待查找元素所在区间的上届、下界和中点，key为给定需要查找的值：</p></li><li><p>使key与mid值做比较<br> 若<code>key = R[mid]</code>查找成功</p><p> 若<code>key &lt; R[mid]</code>，则<code>high = mid - 1</code></p><p> 若<code>key &gt; R[mid]</code>，则<code>low = mid + 1</code></p></li><li><p>重复上述操作，直至<code>low &gt; high</code>查找失败</p></li></ol><p>非递归二叉查找：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binSearch</span><span class="params">(SqList sql, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> high = sql.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;low : &quot;</span> &lt;&lt; low &lt;&lt; <span class="string">&quot; high : &quot;</span> &lt;&lt; high &lt;&lt; <span class="string">&quot; mid : &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (target == sql.elem[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; sql.elem[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归二分查找：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//low = 0; high = sql.length - 1;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binSearch</span><span class="params">(SqList sql, <span class="type">int</span> target, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (target == sql.elem[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; sql.elem[mid]) &#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">binSearch</span>(sql, target, low, high);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">binSearch</span>(sql, target, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-折半查找分析"><a href="#3-折半查找分析" class="headerlink" title="3.折半查找分析"></a>3.折半查找分析</h4><p>利用<font color='#BAOC2F'>判定树</font>对折半查找进行算法效率分析：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530191759480.png" alt="image-20220530191759480"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530191815113.png" alt="image-20220530191815113"></p><p>平均查找长度ASL（成功时）：</p><p>设表长为n &#x3D; 2<sup>h</sup> - 1，则<code>h = log2(n + 1)</code>其中树为深度为h的满二叉树，且表中每个记录的查找概率相等P<sub>i</sub> &#x3D; 1&#x2F;n</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530192320664.png" alt="image-20220530192320664"></p><p>折半查找优点：效率比顺序查找更高</p><p>折半查找缺点：只适用于有序表，且仅限于顺序存储结构（对线性链表无效）</p><h4 id="4-分块查找"><a href="#4-分块查找" class="headerlink" title="4.分块查找"></a>4.分块查找</h4><p>查找条件：</p><ol><li>将表分成若干块，且表或者有序或者分块有序，若<code>i &lt; j</code>则第<code>j</code>块中所有记录的关键字均大于第<code>i</code>块中的最大关键字</li><li>建立索引表（每个结点含有最大关键字域 和 指向本块第一个结点的指针，且按关键字有序）</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529122849938.png" alt="image-20220529122849938"></p><p>查找过程：先确定待查找记录所在块（顺序查找or折半查找），再在块内查找（顺序查找）</p><p>查找效率：<br>$$<br>ALS &#x3D; L_b + L_w<br>$$</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">L<sub>b</sub></td><td align="center">对索引表查找的ASL</td></tr><tr><td align="center">L<sub>w</sub></td><td align="center">对块内查找的ASL</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529123208021.png" alt="image-20220529123208021"></p><p>分块查找法优点：插入和删除比较容易，无需移动大量元素</p><p>分块查找法缺点：要增加一个索引表的存储空间，并对初始索引表进行排序运算</p><p>分块查找法适用情况：线性表既要快速查找又经常动态变化，则可采用分块查找</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529123649281.png" alt="image-20220529123649281"></p><h3 id="二、树表的查找"><a href="#二、树表的查找" class="headerlink" title="二、树表的查找"></a>二、树表的查找</h3><p>当表插入删除操作频繁时，为维护表的有序性<font color='#BAOC2F'>需要移动表中的很多记录</font>，</p><p>可以改用动态查找表（表结构在查找过程中动态生成）几种特殊的树进行优化：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529124210420.png" alt="image-20220529124210420"></p><h4 id="1-二叉排序树BST"><a href="#1-二叉排序树BST" class="headerlink" title="1.二叉排序树BST"></a>1.二叉排序树BST</h4><h5 id="（1）基本概念："><a href="#（1）基本概念：" class="headerlink" title="（1）基本概念："></a>（1）基本概念：</h5><p>二叉排序树（Binary Sort Tree）又称为二叉搜索树、二叉查找树，二叉排序树满足：</p><ol><li>若左子树非空，则左子树上所有的结点的<font color='#BAOC2F'>值均小于</font>根节点的值</li><li>若右子树非空，则右子树上所有的结点的<font color='#BAOC2F'>值均大于等于</font>根节点的值</li><li>其左右子树本身又各是一棵二叉排序树</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529125047822.png" alt="image-20220529125047822"></p><p>&#x3D;&#x3D;二叉排序树的性质&#x3D;&#x3D;：</p><p>中序遍历非空的二叉排序树，所得到的数据元素序列是一个<font color='#BAOC2F'>按关键字排列</font>的<font color='#BAOC2F'>递增有序序列</font>。</p><h5 id="（2）二叉排序树查找："><a href="#（2）二叉排序树查找：" class="headerlink" title="（2）二叉排序树查找："></a>（2）二叉排序树查找：</h5><ol><li>查找的<font color='#BAOC2F'>关键字等于根节点</font>查找成功，否则</li><li>若小于根节点，查其左子树</li><li>若大于根节点，查其右子树</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529130344425.png" alt="image-20220529130344425"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;<span class="comment">//关键字项</span></span><br><span class="line">    InfoType otherInfo;<span class="comment">//其他数据域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span> &#123;</span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTNode</span> *lchild, *rchild;<span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line">BSTree T;<span class="comment">//定义二叉排序树T</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529131232550.png" alt="image-20220529131232550"></p><p>&#x3D;&#x3D;算法分析&#x3D;&#x3D;：</p><p>二叉排序树上查找某关键字，实际上走了一条<font color='#BAOC2F'>从根节点到该节点的路径</font>：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529131734492.png" alt="image-20220529131734492"></p><p>比较的关键字次数 &#x3D; 此结点所在层次数，最多的比较次数 &#x3D; 树的深度</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529132305258.png" alt="image-20220529132305258"></p><blockquote><p>注：提高形态不均衡的二叉排序树查找效率，可以通过&#x3D;&#x3D;对二叉排序树平衡化处理&#x3D;&#x3D;，尽量让二叉树的形状均衡化。</p></blockquote><h5 id="（3）二叉排序树插入："><a href="#（3）二叉排序树插入：" class="headerlink" title="（3）二叉排序树插入："></a>（3）二叉排序树插入：</h5><ol><li>若二叉排序树为空，则将<font color='#BAOC2F'>插入结点作为根节点</font>插入到空树中</li><li>否则继续在其左右子树上查找：</li><li>若树中已有，则不再插入</li><li>若树中没有，则查找直至某个叶子结点的左&#x2F;右子树为空为止，然后进行插入</li><li>若大于根节点，查其右子树</li></ol><blockquote><p>注意：插入的元素一定在叶子结点上</p></blockquote><h5 id="（4）二叉排序树生成："><a href="#（4）二叉排序树生成：" class="headerlink" title="（4）二叉排序树生成："></a>（4）二叉排序树生成：</h5><p>从空树出发，经过一系列的查找插入操作之后，可生成一棵二叉排序树：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529133418805.png" alt="image-20220529133418805"></p><p>一个无序序列可<font color='#BAOC2F'>通过构造二叉排序树</font>变成一个有序序列，构造树的过程就是对无序序列进行排序的过程。</p><p>插入结点均为叶子结点故无需移动其他结点，相当于在有序序列上插入记录而<font color='#BAOC2F'>无需移动其他记录</font>。</p><blockquote><p>注意：关键字的输入顺序不同，建立的二叉排序树形态也不同（查找效率也不同！）</p></blockquote><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529133907375.png" alt="image-20220529133907375"></p><h5 id="（5）二叉排序树删除："><a href="#（5）二叉排序树删除：" class="headerlink" title="（5）二叉排序树删除："></a>（5）二叉排序树删除：</h5><p>从二叉排序树中删除一个结点，不能把以该节点为根的子树都删去而只能删掉该结点，</p><p>并且还应保证删除后所得的二叉树，仍然满足二叉排序树的性质（中序遍历有序）。</p><p>应考虑的问题：</p><ol><li>将因删除结点断开的二叉链表重新链接起来</li><li>防止重新链接后树的<font color='#BAOC2F'>高度增加</font>（高度增加查找效率变差）</li></ol><p>&#x3D;&#x3D;删除的结点为叶子结点&#x3D;&#x3D;：直接删去该结点，双亲结点相应的指针域改为空</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529135002536.png" alt="image-20220529135002536"></p><p>&#x3D;&#x3D;删除的结点只有左&#x2F;右子树&#x3D;&#x3D;：用其左子树或右子树替换即可（结点替换）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529135320532.png" alt="image-20220529135320532"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529135345532.png" alt="image-20220529135345532"></p><p>&#x3D;&#x3D;删除的结点既有左子树、又有右子树&#x3D;&#x3D;：</p><p>方法1：用中序前驱值替换，然后删除该前驱结点（前驱是左子树中最大的结点）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529140433835.png" alt="image-20220529140433835"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529140445842.png" alt="image-20220529140445842"></p><p>方法2：用中序后继值替换，然后删除该后继结点（后继是右子树中最小的结点）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529140734195.png" alt="image-20220529140734195"></p><h4 id="2-平衡二叉树AVL"><a href="#2-平衡二叉树AVL" class="headerlink" title="2.平衡二叉树AVL"></a>2.平衡二叉树AVL</h4><h5 id="（1）基本概念：-1"><a href="#（1）基本概念：-1" class="headerlink" title="（1）基本概念："></a>（1）基本概念：</h5><p>平衡二叉树（balanced binary tree）又称AVL树（Adelson-Velskii and Landis），</p><p>一棵平衡二叉树是具有以下性质的<font color='#BAOC2F'>二叉排序树</font>：</p><ol><li>左子树与右子树的<font color='#BAOC2F'>高度之差的绝对值</font> ≤ 1</li><li>左子树与右子树也是<font color='#BAOC2F'>平衡</font>二叉树排序树</li></ol><p>为每个结点附加一个数字，给出该结点左子树与右子树的高度差，称为结点的<font color='#BAOC2F'>平衡因子</font>（BF）</p><blockquote><p>注意：平衡二叉树的平衡因子只有可能是-1、0、1</p></blockquote><h5 id="（2）失衡二叉排序树调整："><a href="#（2）失衡二叉排序树调整：" class="headerlink" title="（2）失衡二叉排序树调整："></a>（2）失衡二叉排序树调整：</h5><p>如果在一棵AVL树中插入一个新的结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530152129865.png" alt="image-20220530152129865"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530152929523.png" alt="image-20220530152929523"></p><h6 id="case1：LL型调整"><a href="#case1：LL型调整" class="headerlink" title="case1：LL型调整"></a>case1：LL型调整</h6><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530153744511.png" alt="image-20220530153744511"></p><ol><li>B结点带其左子树α一起上升</li><li>A结点成为B结点的右孩子</li><li>B结点原来的右子树β作为A结点的左子树</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530154319586.png" alt="image-20220530154319586"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530154412738.png" alt="image-20220530154412738"></p><h6 id="case2：RR型调整"><a href="#case2：RR型调整" class="headerlink" title="case2：RR型调整"></a>case2：RR型调整</h6><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530160002922.png" alt="image-20220530160002922"></p><ol><li>B结点带右子树β一起上升</li><li>A结点成为B结点的左孩子</li><li>原来B结点的左子树α作为A结点的右子树</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530161415494.png" alt="image-20220530161415494"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530170917668.png" alt="image-20220530170917668"></p><h6 id="case3：LR型调整"><a href="#case3：LR型调整" class="headerlink" title="case3：LR型调整"></a>case3：LR型调整</h6><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530171246758.png" alt="image-20220530171246758"></p><ol><li>C结点穿过A、B结点上升</li><li>B结点成为C结点的左孩子</li><li>A结点成为C结点的右孩子</li><li>原来C结点的左子树β作为B结点的右子树</li><li>原来C结点的右子树γ作为A结点的左子树</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530172401086.png" alt="image-20220530172401086"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530172455200.png" alt="image-20220530172455200"></p><h6 id="case4：RL型调整："><a href="#case4：RL型调整：" class="headerlink" title="case4：RL型调整："></a>case4：RL型调整：</h6><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530172550969.png" alt="image-20220530172550969"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530172846397.png" alt="image-20220530172846397"></p><h5 id="（3）失衡调整案例："><a href="#（3）失衡调整案例：" class="headerlink" title="（3）失衡调整案例："></a>（3）失衡调整案例：</h5><p>输入关键字序列（16， 3， 7， 11， 9， 26， 18， 14， 15），给出构造AVL树的步骤以及结果：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530173625903.png" alt="image-20220530173625903"></p><h4 id="3-红黑树"><a href="#3-红黑树" class="headerlink" title="3.红黑树"></a>3.红黑树</h4><h3 id="三、Hash表的查找"><a href="#三、Hash表的查找" class="headerlink" title="三、Hash表的查找"></a>三、Hash表的查找</h3><p>记录的存储位置与关键字之间存在对应关系，对应关系的函数—hash函数<code>Loc(i) = H(keyi)</code></p><p>根据散列函数<code>H(key) = k</code>，若查找不到则返回一个特殊值（空指针 或 空记录）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530174658566.png" alt="image-20220530174658566"></p><ul><li>优点：查找效率高</li><li>缺点：空间效率低</li></ul><p>使用散列表要解决好的两个问题：</p><ol><li>构造<font color='#BAOC2F'>好的散列函数</font>（函数尽可能简单—提高转换速度、key值计算出的地址应集中均匀分布—减少空间浪费）</li><li>制定一个好的冲突解决方案</li></ol><h4 id="1-Hash函数构造"><a href="#1-Hash函数构造" class="headerlink" title="1.Hash函数构造"></a>1.Hash函数构造</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530175621951.png" alt="image-20220530175621951"></p><p>根据元素集合的特性构造：</p><ul><li>要求1：n个数据源仅占用n个地址，虽然散列查找是以空间换时间但是仍希望散列的地址空间尽量小</li><li>要求2：无论用什么方法存储，目的都是尽量均匀的存放元素避免冲突</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530180015427.png" alt="image-20220530180015427"></p><h5 id="（1）直接定值法："><a href="#（1）直接定值法：" class="headerlink" title="（1）直接定值法："></a>（1）直接定值法：</h5><p>$$<br>Hash(key) &#x3D; a*key + b<br>$$</p><p>优点：以关键码key的<font color='#BAOC2F'>某个线性函数值</font>为Hash地址，不会产生冲突</p><p>缺点：要占用连续的地址空间，空间效率较低</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530180232923.png" alt="image-20220530180232923"></p><h5 id="（2）除留余数法："><a href="#（2）除留余数法：" class="headerlink" title="（2）除留余数法："></a>（2）除留余数法：</h5><p>$$<br>Hash(key) &#x3D; key<del>mod</del>p<br>$$</p><blockquote><p>注意：如何选取合适的p值？设表长为m，取<code>p ≤ m</code>且为质数</p></blockquote><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530180653114.png" alt="image-20220530180653114"></p><h4 id="2-Hash函数冲突解决方案"><a href="#2-Hash函数冲突解决方案" class="headerlink" title="2.Hash函数冲突解决方案"></a>2.Hash函数冲突解决方案</h4><h5 id="（1）开地址法："><a href="#（1）开地址法：" class="headerlink" title="（1）开地址法："></a>（1）开地址法：</h5><p>有冲突时就去寻找下一个空的散列表，只要散列表足够大，空的散列地址总能找到并将数据元素存入。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530181105793.png" alt="image-20220530181105793"></p><p>线性探测法：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530181617687.png" alt="image-20220530181617687"></p><p>二次探测法：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530182316313.png" alt="image-20220530182316313"></p><p>伪随机探测法：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530182427474.png" alt="image-20220530182427474"></p><h5 id="（2）链地址法："><a href="#（2）链地址法：" class="headerlink" title="（2）链地址法："></a>（2）链地址法：</h5><p>相同Hash地址的记录链成一条单链表，m个地址设m个单链表，然后<font color='#BAOC2F'>用一个数组</font>将m个单链表的<font color='#BAOC2F'>表头指针</font>存储起来（形成动态结构）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530182943727.png" alt="image-20220530182943727"></p><p>链地址法建立散列表步骤：</p><ol><li>取数据元素的关键字key，计算其Hash&#x2F;散列函数值（地址）</li><li>若计算的Hash函数值为空，则将该元素添加到此数组中</li><li>若计算的Hash函数值非空，则利用链表的前插法 或 后插法将该元素插入此链表</li></ol><p>链地址法优点：</p><ol><li>非同义词不会冲突，无聚集现象</li><li>链表上的结点是动态申请的，更适用于表长不定的情况</li></ol><h4 id="3-Hash表的查找"><a href="#3-Hash表的查找" class="headerlink" title="3.Hash表的查找"></a>3.Hash表的查找</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530184002090.png" alt="image-20220530184002090"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530185359102.png" alt="image-20220530185359102"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530185513761.png" alt="image-20220530185513761"></p><p>&#x3D;&#x3D;Hash表的查找效率分析&#x3D;&#x3D;：</p><p>使用平均查找长度ASL来衡量查找算法，ASL取决于：</p><ol><li>散列函数</li><li>处理冲突的方法</li><li>散列表的装填因子α（α &#x3D; 表中填入的记录数 &#x2F; Hash表的长度）</li></ol><blockquote><p>注意：α越大，表中记录的数量越多、表装的越满、发生冲突的可能性越大、查找时比较的次数越多</p></blockquote><p>ASL与装填因子有关：既不是严格的O(1)，也不是O(n)</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530190222372.png" alt="image-20220530190222372"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530190322007.png" alt="image-20220530190322007"></p>]]></content>
      
      
      <categories>
          
          <category> datestructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> datestructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章：查找</title>
      <link href="/2023/02/27/dataStructure/8.%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%9B%BE%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2023/02/27/dataStructure/8.%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%9B%BE%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="第七章：查找"><a href="#第七章：查找" class="headerlink" title="第七章：查找"></a>第七章：查找</h1><hr><ul><li>主关键字：可唯一标识记录的关键字</li><li>次关键字：用以识别若干记录的关键字</li><li>关键字的平均比较次数，平均查找长度ASL（Average Search Length）</li></ul><p>$$<br>ASL &#x3D; \sum_{i&#x3D;1}^np_ic_i<br>$$</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">n</td><td align="center">记录的个数</td></tr><tr><td align="center">p<sub>i</sub></td><td align="center">查找到第i个记录的概率</td></tr><tr><td align="center">c<sub>i</sub></td><td align="center">查找到第i个记录所需的比较次数</td></tr></tbody></table><h3 id="一、线性表的查找"><a href="#一、线性表的查找" class="headerlink" title="一、线性表的查找"></a>一、线性表的查找</h3><h4 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1.顺序查找"></a>1.顺序查找</h4><p>应用范围：顺序表或线性表表示的<font color='#BAOC2F'>静态查找表</font>（表内元素无序）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType *R;<span class="comment">//表基址</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//表长</span></span><br><span class="line">&#125; SSTable;<span class="comment">//Sequential Search Table</span></span><br><span class="line">SSTable ST;<span class="comment">//定义顺序表ST</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529101335983.png" alt="image-20220529101335983"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529101622530.png" alt="image-20220529101622530"></p><p>注意到每执行一次循环都要进行两次比较，</p><p> 改进：&#x3D;&#x3D;利用哨兵简化减少for循环比较次数&#x3D;&#x3D;，将待查关键字key存入表头，可免去查找过程中每一步都要检测是否查找完毕（加快速度）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529102444216.png" alt="image-20220529102444216"></p><blockquote><p>注意：当<code>ST.length</code>比较大时，此改进能使进行一次查找所需要的平均时间几乎减少一半。</p></blockquote><p>顺序查找法优点：算法简单，逻辑次序无要求，且不同存储结构均适用</p><p>顺序查找法缺点：ASL太长时间效率太低</p><h4 id="2-折半查找"><a href="#2-折半查找" class="headerlink" title="2.折半查找"></a>2.折半查找</h4><p>折半查找每次可将待查找记录所在的区间缩小一半，</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529110344292.png" alt="image-20220529110344292"></p><ol><li><p>low、hight、mid分别指向待查找元素所在区间的上届、下界和中点，key为给定需要查找的值：</p></li><li><p>使key与mid值做比较<br> 若<code>key = R[mid]</code>查找成功</p><p> 若<code>key &lt; R[mid]</code>，则<code>high = mid - 1</code></p><p> 若<code>key &gt; R[mid]</code>，则<code>low = mid + 1</code></p></li><li><p>重复上述操作，直至<code>low &gt; high</code>查找失败</p></li></ol><p>非递归二叉查找：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binSearch</span><span class="params">(SqList sql, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> high = sql.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;low : &quot;</span> &lt;&lt; low &lt;&lt; <span class="string">&quot; high : &quot;</span> &lt;&lt; high &lt;&lt; <span class="string">&quot; mid : &quot;</span> &lt;&lt; mid &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (target == sql.elem[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; sql.elem[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归二分查找：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//low = 0; high = sql.length - 1;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binSearch</span><span class="params">(SqList sql, <span class="type">int</span> target, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (target == sql.elem[mid]) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; sql.elem[mid]) &#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">binSearch</span>(sql, target, low, high);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">binSearch</span>(sql, target, low, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-折半查找分析"><a href="#3-折半查找分析" class="headerlink" title="3.折半查找分析"></a>3.折半查找分析</h4><p>利用<font color='#BAOC2F'>判定树</font>对折半查找进行算法效率分析：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530191759480.png" alt="image-20220530191759480"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530191815113.png" alt="image-20220530191815113"></p><p>平均查找长度ASL（成功时）：</p><p>设表长为n &#x3D; 2<sup>h</sup> - 1，则<code>h = log2(n + 1)</code>其中树为深度为h的满二叉树，且表中每个记录的查找概率相等P<sub>i</sub> &#x3D; 1&#x2F;n</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530192320664.png" alt="image-20220530192320664"></p><p>折半查找优点：效率比顺序查找更高</p><p>折半查找缺点：只适用于有序表，且仅限于顺序存储结构（对线性链表无效）</p><h4 id="4-分块查找"><a href="#4-分块查找" class="headerlink" title="4.分块查找"></a>4.分块查找</h4><p>查找条件：</p><ol><li>将表分成若干块，且表或者有序或者分块有序，若<code>i &lt; j</code>则第<code>j</code>块中所有记录的关键字均大于第<code>i</code>块中的最大关键字</li><li>建立索引表（每个结点含有最大关键字域 和 指向本块第一个结点的指针，且按关键字有序）</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529122849938.png" alt="image-20220529122849938"></p><p>查找过程：先确定待查找记录所在块（顺序查找or折半查找），再在块内查找（顺序查找）</p><p>查找效率：<br>$$<br>ALS &#x3D; L_b + L_w<br>$$</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">L<sub>b</sub></td><td align="center">对索引表查找的ASL</td></tr><tr><td align="center">L<sub>w</sub></td><td align="center">对块内查找的ASL</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529123208021.png" alt="image-20220529123208021"></p><p>分块查找法优点：插入和删除比较容易，无需移动大量元素</p><p>分块查找法缺点：要增加一个索引表的存储空间，并对初始索引表进行排序运算</p><p>分块查找法适用情况：线性表既要快速查找又经常动态变化，则可采用分块查找</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529123649281.png" alt="image-20220529123649281"></p><h3 id="二、树表的查找"><a href="#二、树表的查找" class="headerlink" title="二、树表的查找"></a>二、树表的查找</h3><p>当表插入删除操作频繁时，为维护表的有序性<font color='#BAOC2F'>需要移动表中的很多记录</font>，</p><p>可以改用动态查找表（表结构在查找过程中动态生成）几种特殊的树进行优化：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529124210420.png" alt="image-20220529124210420"></p><h4 id="1-二叉排序树BST"><a href="#1-二叉排序树BST" class="headerlink" title="1.二叉排序树BST"></a>1.二叉排序树BST</h4><h5 id="（1）基本概念："><a href="#（1）基本概念：" class="headerlink" title="（1）基本概念："></a>（1）基本概念：</h5><p>二叉排序树（Binary Sort Tree）又称为二叉搜索树、二叉查找树，二叉排序树满足：</p><ol><li>若左子树非空，则左子树上所有的结点的<font color='#BAOC2F'>值均小于</font>根节点的值</li><li>若右子树非空，则右子树上所有的结点的<font color='#BAOC2F'>值均大于等于</font>根节点的值</li><li>其左右子树本身又各是一棵二叉排序树</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529125047822.png" alt="image-20220529125047822"></p><p>&#x3D;&#x3D;二叉排序树的性质&#x3D;&#x3D;：</p><p>中序遍历非空的二叉排序树，所得到的数据元素序列是一个<font color='#BAOC2F'>按关键字排列</font>的<font color='#BAOC2F'>递增有序序列</font>。</p><h5 id="（2）二叉排序树查找："><a href="#（2）二叉排序树查找：" class="headerlink" title="（2）二叉排序树查找："></a>（2）二叉排序树查找：</h5><ol><li>查找的<font color='#BAOC2F'>关键字等于根节点</font>查找成功，否则</li><li>若小于根节点，查其左子树</li><li>若大于根节点，查其右子树</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529130344425.png" alt="image-20220529130344425"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    KeyType key;<span class="comment">//关键字项</span></span><br><span class="line">    InfoType otherInfo;<span class="comment">//其他数据域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BSTNode</span> &#123;</span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BSTNode</span> *lchild, *rchild;<span class="comment">//左右孩子指针</span></span><br><span class="line">&#125; BSTNode, *BSTree;</span><br><span class="line"></span><br><span class="line">BSTree T;<span class="comment">//定义二叉排序树T</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529131232550.png" alt="image-20220529131232550"></p><p>&#x3D;&#x3D;算法分析&#x3D;&#x3D;：</p><p>二叉排序树上查找某关键字，实际上走了一条<font color='#BAOC2F'>从根节点到该节点的路径</font>：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529131734492.png" alt="image-20220529131734492"></p><p>比较的关键字次数 &#x3D; 此结点所在层次数，最多的比较次数 &#x3D; 树的深度</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529132305258.png" alt="image-20220529132305258"></p><blockquote><p>注：提高形态不均衡的二叉排序树查找效率，可以通过&#x3D;&#x3D;对二叉排序树平衡化处理&#x3D;&#x3D;，尽量让二叉树的形状均衡化。</p></blockquote><h5 id="（3）二叉排序树插入："><a href="#（3）二叉排序树插入：" class="headerlink" title="（3）二叉排序树插入："></a>（3）二叉排序树插入：</h5><ol><li>若二叉排序树为空，则将<font color='#BAOC2F'>插入结点作为根节点</font>插入到空树中</li><li>否则继续在其左右子树上查找：</li><li>若树中已有，则不再插入</li><li>若树中没有，则查找直至某个叶子结点的左&#x2F;右子树为空为止，然后进行插入</li><li>若大于根节点，查其右子树</li></ol><blockquote><p>注意：插入的元素一定在叶子结点上</p></blockquote><h5 id="（4）二叉排序树生成："><a href="#（4）二叉排序树生成：" class="headerlink" title="（4）二叉排序树生成："></a>（4）二叉排序树生成：</h5><p>从空树出发，经过一系列的查找插入操作之后，可生成一棵二叉排序树：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529133418805.png" alt="image-20220529133418805"></p><p>一个无序序列可<font color='#BAOC2F'>通过构造二叉排序树</font>变成一个有序序列，构造树的过程就是对无序序列进行排序的过程。</p><p>插入结点均为叶子结点故无需移动其他结点，相当于在有序序列上插入记录而<font color='#BAOC2F'>无需移动其他记录</font>。</p><blockquote><p>注意：关键字的输入顺序不同，建立的二叉排序树形态也不同（查找效率也不同！）</p></blockquote><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529133907375.png" alt="image-20220529133907375"></p><h5 id="（5）二叉排序树删除："><a href="#（5）二叉排序树删除：" class="headerlink" title="（5）二叉排序树删除："></a>（5）二叉排序树删除：</h5><p>从二叉排序树中删除一个结点，不能把以该节点为根的子树都删去而只能删掉该结点，</p><p>并且还应保证删除后所得的二叉树，仍然满足二叉排序树的性质（中序遍历有序）。</p><p>应考虑的问题：</p><ol><li>将因删除结点断开的二叉链表重新链接起来</li><li>防止重新链接后树的<font color='#BAOC2F'>高度增加</font>（高度增加查找效率变差）</li></ol><p>&#x3D;&#x3D;删除的结点为叶子结点&#x3D;&#x3D;：直接删去该结点，双亲结点相应的指针域改为空</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529135002536.png" alt="image-20220529135002536"></p><p>&#x3D;&#x3D;删除的结点只有左&#x2F;右子树&#x3D;&#x3D;：用其左子树或右子树替换即可（结点替换）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529135320532.png" alt="image-20220529135320532"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529135345532.png" alt="image-20220529135345532"></p><p>&#x3D;&#x3D;删除的结点既有左子树、又有右子树&#x3D;&#x3D;：</p><p>方法1：用中序前驱值替换，然后删除该前驱结点（前驱是左子树中最大的结点）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529140433835.png" alt="image-20220529140433835"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529140445842.png" alt="image-20220529140445842"></p><p>方法2：用中序后继值替换，然后删除该后继结点（后继是右子树中最小的结点）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529140734195.png" alt="image-20220529140734195"></p><h4 id="2-平衡二叉树AVL"><a href="#2-平衡二叉树AVL" class="headerlink" title="2.平衡二叉树AVL"></a>2.平衡二叉树AVL</h4><h5 id="（1）基本概念：-1"><a href="#（1）基本概念：-1" class="headerlink" title="（1）基本概念："></a>（1）基本概念：</h5><p>平衡二叉树（balanced binary tree）又称AVL树（Adelson-Velskii and Landis），</p><p>一棵平衡二叉树是具有以下性质的<font color='#BAOC2F'>二叉排序树</font>：</p><ol><li>左子树与右子树的<font color='#BAOC2F'>高度之差的绝对值</font> ≤ 1</li><li>左子树与右子树也是<font color='#BAOC2F'>平衡</font>二叉树排序树</li></ol><p>为每个结点附加一个数字，给出该结点左子树与右子树的高度差，称为结点的<font color='#BAOC2F'>平衡因子</font>（BF）</p><blockquote><p>注意：平衡二叉树的平衡因子只有可能是-1、0、1</p></blockquote><h5 id="（2）失衡二叉排序树调整："><a href="#（2）失衡二叉排序树调整：" class="headerlink" title="（2）失衡二叉排序树调整："></a>（2）失衡二叉排序树调整：</h5><p>如果在一棵AVL树中插入一个新的结点后造成失衡，则必须重新调整树的结构，使之恢复平衡。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530152129865.png" alt="image-20220530152129865"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530152929523.png" alt="image-20220530152929523"></p><h6 id="case1：LL型调整"><a href="#case1：LL型调整" class="headerlink" title="case1：LL型调整"></a>case1：LL型调整</h6><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530153744511.png" alt="image-20220530153744511"></p><ol><li>B结点带其左子树α一起上升</li><li>A结点成为B结点的右孩子</li><li>B结点原来的右子树β作为A结点的左子树</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530154319586.png" alt="image-20220530154319586"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530154412738.png" alt="image-20220530154412738"></p><h6 id="case2：RR型调整"><a href="#case2：RR型调整" class="headerlink" title="case2：RR型调整"></a>case2：RR型调整</h6><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530160002922.png" alt="image-20220530160002922"></p><ol><li>B结点带右子树β一起上升</li><li>A结点成为B结点的左孩子</li><li>原来B结点的左子树α作为A结点的右子树</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530161415494.png" alt="image-20220530161415494"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530170917668.png" alt="image-20220530170917668"></p><h6 id="case3：LR型调整"><a href="#case3：LR型调整" class="headerlink" title="case3：LR型调整"></a>case3：LR型调整</h6><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530171246758.png" alt="image-20220530171246758"></p><ol><li>C结点穿过A、B结点上升</li><li>B结点成为C结点的左孩子</li><li>A结点成为C结点的右孩子</li><li>原来C结点的左子树β作为B结点的右子树</li><li>原来C结点的右子树γ作为A结点的左子树</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530172401086.png" alt="image-20220530172401086"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530172455200.png" alt="image-20220530172455200"></p><h6 id="case4：RL型调整："><a href="#case4：RL型调整：" class="headerlink" title="case4：RL型调整："></a>case4：RL型调整：</h6><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530172550969.png" alt="image-20220530172550969"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530172846397.png" alt="image-20220530172846397"></p><h5 id="（3）失衡调整案例："><a href="#（3）失衡调整案例：" class="headerlink" title="（3）失衡调整案例："></a>（3）失衡调整案例：</h5><p>输入关键字序列（16， 3， 7， 11， 9， 26， 18， 14， 15），给出构造AVL树的步骤以及结果：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530173625903.png" alt="image-20220530173625903"></p><h4 id="3-红黑树"><a href="#3-红黑树" class="headerlink" title="3.红黑树"></a>3.红黑树</h4><h3 id="三、Hash表的查找"><a href="#三、Hash表的查找" class="headerlink" title="三、Hash表的查找"></a>三、Hash表的查找</h3><p>记录的存储位置与关键字之间存在对应关系，对应关系的函数—hash函数<code>Loc(i) = H(keyi)</code></p><p>根据散列函数<code>H(key) = k</code>，若查找不到则返回一个特殊值（空指针 或 空记录）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530174658566.png" alt="image-20220530174658566"></p><ul><li>优点：查找效率高</li><li>缺点：空间效率低</li></ul><p>使用散列表要解决好的两个问题：</p><ol><li>构造<font color='#BAOC2F'>好的散列函数</font>（函数尽可能简单—提高转换速度、key值计算出的地址应集中均匀分布—减少空间浪费）</li><li>制定一个好的冲突解决方案</li></ol><h4 id="1-Hash函数构造"><a href="#1-Hash函数构造" class="headerlink" title="1.Hash函数构造"></a>1.Hash函数构造</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530175621951.png" alt="image-20220530175621951"></p><p>根据元素集合的特性构造：</p><ul><li>要求1：n个数据源仅占用n个地址，虽然散列查找是以空间换时间但是仍希望散列的地址空间尽量小</li><li>要求2：无论用什么方法存储，目的都是尽量均匀的存放元素避免冲突</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530180015427.png" alt="image-20220530180015427"></p><h5 id="（1）直接定值法："><a href="#（1）直接定值法：" class="headerlink" title="（1）直接定值法："></a>（1）直接定值法：</h5><p>$$<br>Hash(key) &#x3D; a*key + b<br>$$</p><p>优点：以关键码key的<font color='#BAOC2F'>某个线性函数值</font>为Hash地址，不会产生冲突</p><p>缺点：要占用连续的地址空间，空间效率较低</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530180232923.png" alt="image-20220530180232923"></p><h5 id="（2）除留余数法："><a href="#（2）除留余数法：" class="headerlink" title="（2）除留余数法："></a>（2）除留余数法：</h5><p>$$<br>Hash(key) &#x3D; key<del>mod</del>p<br>$$</p><blockquote><p>注意：如何选取合适的p值？设表长为m，取<code>p ≤ m</code>且为质数</p></blockquote><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530180653114.png" alt="image-20220530180653114"></p><h4 id="2-Hash函数冲突解决方案"><a href="#2-Hash函数冲突解决方案" class="headerlink" title="2.Hash函数冲突解决方案"></a>2.Hash函数冲突解决方案</h4><h5 id="（1）开地址法："><a href="#（1）开地址法：" class="headerlink" title="（1）开地址法："></a>（1）开地址法：</h5><p>有冲突时就去寻找下一个空的散列表，只要散列表足够大，空的散列地址总能找到并将数据元素存入。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530181105793.png" alt="image-20220530181105793"></p><p>线性探测法：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530181617687.png" alt="image-20220530181617687"></p><p>二次探测法：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530182316313.png" alt="image-20220530182316313"></p><p>伪随机探测法：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530182427474.png" alt="image-20220530182427474"></p><h5 id="（2）链地址法："><a href="#（2）链地址法：" class="headerlink" title="（2）链地址法："></a>（2）链地址法：</h5><p>相同Hash地址的记录链成一条单链表，m个地址设m个单链表，然后<font color='#BAOC2F'>用一个数组</font>将m个单链表的<font color='#BAOC2F'>表头指针</font>存储起来（形成动态结构）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530182943727.png" alt="image-20220530182943727"></p><p>链地址法建立散列表步骤：</p><ol><li>取数据元素的关键字key，计算其Hash&#x2F;散列函数值（地址）</li><li>若计算的Hash函数值为空，则将该元素添加到此数组中</li><li>若计算的Hash函数值非空，则利用链表的前插法 或 后插法将该元素插入此链表</li></ol><p>链地址法优点：</p><ol><li>非同义词不会冲突，无聚集现象</li><li>链表上的结点是动态申请的，更适用于表长不定的情况</li></ol><h4 id="3-Hash表的查找"><a href="#3-Hash表的查找" class="headerlink" title="3.Hash表的查找"></a>3.Hash表的查找</h4><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530184002090.png" alt="image-20220530184002090"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530185359102.png" alt="image-20220530185359102"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530185513761.png" alt="image-20220530185513761"></p><p>&#x3D;&#x3D;Hash表的查找效率分析&#x3D;&#x3D;：</p><p>使用平均查找长度ASL来衡量查找算法，ASL取决于：</p><ol><li>散列函数</li><li>处理冲突的方法</li><li>散列表的装填因子α（α &#x3D; 表中填入的记录数 &#x2F; Hash表的长度）</li></ol><blockquote><p>注意：α越大，表中记录的数量越多、表装的越满、发生冲突的可能性越大、查找时比较的次数越多</p></blockquote><p>ASL与装填因子有关：既不是严格的O(1)，也不是O(n)</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530190222372.png" alt="image-20220530190222372"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220530190322007.png" alt="image-20220530190322007"></p>]]></content>
      
      
      <categories>
          
          <category> datestructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> datestructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八章排序</title>
      <link href="/2023/02/27/dataStructure/10.%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/02/27/dataStructure/10.%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="第八章：排序"><a href="#第八章：排序" class="headerlink" title="第八章：排序"></a>第八章：排序</h1><hr><table><thead><tr><th>分类标准</th><th>类别1</th><th>类别2</th></tr></thead><tbody><tr><td>按存储介质</td><td>内部排序：数据量不大数据在内存，无需内外存交换数据</td><td>外部排序：数据量较大数据在外存（文件排序）</td></tr><tr><td>按比较器个数</td><td>串行排序：单处理机（同一时刻比较一对元素）</td><td>并行排序：多处理机（同一时刻比较多对元素）</td></tr><tr><td>按主要操作</td><td>比较排序：使用比较的方法，包括插入排序、交换排序、选择排序、归并排序</td><td>基数排序：不比较元素的大小，<font color='#BAOC2F'>仅仅根据元素本身的取值</font>确定其有序位置</td></tr><tr><td>按辅助空间</td><td>原地排序：辅助空间用量为<code>O(1)</code></td><td>非原地排序</td></tr><tr><td>按稳定性</td><td>稳定排序：使<font color='#BAOC2F'>任何数值</font>相等的元素，排序以后相对次序不变</td><td>非稳定排序</td></tr><tr><td>按自然性</td><td>自然排序：输入数据越有序，排序的速度越快</td><td>非自然排序</td></tr></tbody></table><ol><li>外部排序时，要将数据分批调入内存来排序，中间结果还要及时放入外存，显然外部排序要复杂得多。</li><li>排序稳定性只对<font color='#BAOC2F'>结构类型的数据</font>排序有意义，例如student类型</li><li>排序方法是否稳定，并不能衡量一个排序算法的优劣</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例中使用的数据结构</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLENGTH 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> elem[MAXLENGTH];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125; SqList;</span><br></pre></td></tr></table></figure><h3 id="一、插入排序"><a href="#一、插入排序" class="headerlink" title="一、插入排序"></a>一、插入排序</h3><p>每步将1个待排序的对象，<font color='#BAOC2F'>按照大小</font>插入到前面<font color='#BAOC2F'>已经排好序</font>的一组对象的适当位置上，直到对象全部插入为止，</p><p>即边插入边排序保证子序列中<font color='#BAOC2F'>随时都是排好序的</font>。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/insertionSort.gif" alt="insertionSort"></p><ol><li>在有序序列中插入一个元素，保持序列有序（有序长度不断增加）</li><li>起初a[0]是长度为1的子序列，然后逐一将a[1]至a[n-1]插入到<font color='#BAOC2F'>有序子序列中</font>。</li><li>插入a[i]使a[0]~a[i-1]有序，也就是要为a[i] <font color='#BAOC2F'>找到有序位置</font> j，将a[i]插入在a[j]的位置上</li></ol><p>根据<font color='#BAOC2F'>寻找插入位置方式</font>的不同，可将插入排序分为3类：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220527201727191.png" alt="image-20220527201727191"></p><h4 id="1-直接插入排序"><a href="#1-直接插入排序" class="headerlink" title="1.直接插入排序"></a>1.直接插入排序</h4><p>采用<font color='#BAOC2F'>顺序查找法</font>查找插入位置：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/insertSort.gif" alt="insertSort"></p><ol><li><p>复制插入元素<code>x = a[i];</code></p></li><li><p>记录后移查找插入位置</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (j = i - <span class="number">1</span>; a[j] &gt; x &amp;&amp; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">    a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>插入到寻找到的正确位置<code>a[j - 1] = x;</code></p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序 不带哨兵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; L.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.elem[i] &lt; L.elem[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="type">int</span> x = L.elem[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; L.elem[j] &gt; x &amp;&amp; j &gt;= <span class="number">0</span>; --j)<span class="comment">//顺序查找找到插入的位置</span></span><br><span class="line">                L.elem[j + <span class="number">1</span>] = L.elem[j];<span class="comment">//所有大于x的记录都将后移</span></span><br><span class="line">            L.elem[j + <span class="number">1</span>] = x;<span class="comment">//插入元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//直接插入排序 利用哨兵省略掉 j &gt;= 0 的判断语句</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertSort</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= L.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.elem[i] &lt; L.elem[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            L.elem[<span class="number">0</span>] = L.elem[i];<span class="comment">//赋值为哨兵</span></span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; L.elem[j] &gt; L.elem[<span class="number">0</span>]; --j)<span class="comment">//顺序查找找到插入的位置</span></span><br><span class="line">                L.elem[j + <span class="number">1</span>] = L.elem[j];<span class="comment">//所有大于哨兵的元素记录都将后移</span></span><br><span class="line">            L.elem[j + <span class="number">1</span>] = L.elem[<span class="number">0</span>];<span class="comment">//将哨兵插入到正确的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220527203906050.png" alt="image-20220527203906050"></p><h4 id="2-折半插入排序"><a href="#2-折半插入排序" class="headerlink" title="2.折半插入排序"></a>2.折半插入排序</h4><p>采用<font color='#BAOC2F'>二分查找法</font>查找插入位置：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220529083530509.png" alt="image-20220529083530509"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折半插入排序 不带哨兵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BInsertSort1</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x = L.elem[i];<span class="comment">//插入排序目标值</span></span><br><span class="line">        <span class="comment">//利用二分查找寻找插入位置 high + 1为插入位置</span></span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; L.elem[mid]) high = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查找位置结束后 进行常规插入操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; --j) L.elem[j + <span class="number">1</span>] = L.elem[j];<span class="comment">//j+1插入位置后的元素后移</span></span><br><span class="line">        L.elem[high + <span class="number">1</span>] = x;<span class="comment">//插入元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">直到low &gt; high时才停止折半查找</span></span><br><span class="line"><span class="comment">当mid所指元素等于当元素时 应继续令low = mid + 1以保证稳定性</span></span><br><span class="line"><span class="comment">最终应将当前元素插入到low所指的位置(high + 1)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//折半插入排序 带哨兵</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BInsertSort2</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; L.length + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        L.elem[<span class="number">0</span>] = L.elem[i];<span class="comment">//插入排序目标值</span></span><br><span class="line">        <span class="comment">//利用二分查找寻找插入位置 high + 1为插入位置</span></span><br><span class="line">        <span class="type">int</span> low = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> high = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (L.elem[mid] &gt; L.elem[<span class="number">0</span>]) high = mid - <span class="number">1</span>;<span class="comment">//查找左半边子表</span></span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;<span class="comment">//查找右半边子表</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查找位置结束后 进行常规插入操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; --j) L.elem[j + <span class="number">1</span>] = L.elem[j];<span class="comment">//j+1插入位置后的元素后移</span></span><br><span class="line">        L.elem[high + <span class="number">1</span>] = L.elem[<span class="number">0</span>];<span class="comment">//插入元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>折半查找是一种<font color='#BAOC2F'>稳定的排序方法</font>。</li><li>折半查找排序时间复杂度为O(n<sup>2</sup>)，空间复杂度为O(1)</li><li>折半查找的<font color='#BAOC2F'>关键码比较次数</font>与待排序对象序列的初始排列无关，仅依赖于<font color='#BAOC2F'>对象的个数</font>。</li><li>插入第i个对象时需要经过[log<sub>2</sub>i + 1]次关键码的比较，才能确定插入位置</li><li>当n较大时，总关键码的比较次数比直接插入排序的<font color='#BAOC2F'>最坏情况</font>要好很多，但是比其<font color='#BAOC2F'>最好的情况</font>要差</li><li>在对象的初始序列<font color='#BAOC2F'>已经按关键码排好序</font> or <font color='#BAOC2F'>接近有序时</font>，直接插入排序比折半插入排序执行的关键码比较次数要少</li></ol><blockquote><p>注：折半插入排序减少了<font color='#BAOC2F'>比较次数</font>，但是没有减少<font color='#BAOC2F'>移动次数</font>。</p></blockquote><h4 id="3-希尔排序"><a href="#3-希尔排序" class="headerlink" title="3.希尔排序"></a>3.希尔排序</h4><p>直接插入排序在<font color='#BAOC2F'>基本有序</font>时、待排序的<font color='#BAOC2F'>记录个数较少时</font>效率较高，其是针对直接插入排序算法的改进。</p><p>&#x3D;&#x3D;基本思想&#x3D;&#x3D;：</p><ol><li>先将整个待排序记录序列分割成若干子序列（缩小增量），分别进行直接插入排序，</li><li>待整个序列中的记录<font color='#BAOC2F'>基本有序</font>时，再对全体记录进行一次直接插入排序（多遍插入排序）。</li><li>即先追求元素部分有序，再逐渐逼近全局有序。</li></ol><p>&#x3D;&#x3D;希尔排序的特点&#x3D;&#x3D;：</p><ol><li>一次移动移动的位置较大，跳跃式地接近排序后的最终位置，最后一次只需要少量的移动位置</li><li>增量序列必须是递减的，且最后一个必须是1</li><li>增量序列应该是<font color='#BAOC2F'>互质的</font>。</li><li>自定义增量序列D<sub>k</sub>，D<sub>M</sub> &gt; D<sub>M-1</sub> &gt; … &gt;D<sub>1</sub> &#x3D; 1，对每个D<sub>k</sub>进行D<sub>k</sub>间隔的插入排序（k &#x3D; M, M -1, …1）</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220531175923814.png" alt="image-20220531175923814"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现方案1:间隔内直接插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> dk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对顺序表L进行一趟增量为dk的shell排序，其中dk为步长因子</span></span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = dk - <span class="number">1</span>; i &lt; L.length; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.elem[i] &lt; L.elem[i - dk]) &#123;</span><br><span class="line">            <span class="type">int</span> x  = L.elem[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - dk; L.elem[j] &gt; x &amp;&amp; j &gt;= <span class="number">0</span>; j = j - dk)<span class="comment">//顺序查找找到插入的位置</span></span><br><span class="line">                L.elem[j + dk] = L.elem[j];<span class="comment">//所有大于x的记录都将后移</span></span><br><span class="line">            L.elem[j + dk] = x;<span class="comment">//插入元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> dlta[], <span class="type">int</span> max)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dk值依次存在dlta[t]中</span></span><br><span class="line">    <span class="comment">//按增量序列dlta[0..L.length]对顺序表L作希尔排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; max; ++k) &#123;</span><br><span class="line">        <span class="built_in">shellInsert</span>(L, dlta[k]);<span class="comment">//一趟增量为dlta[k]的直接插入排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现方案2:间隔间切换进行直接插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort1</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//A[0]只是暂存单元不是哨兵 当j&lt;=0时插入位置已到</span></span><br><span class="line">    <span class="type">int</span> dk;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (dk = n/<span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk = dk/<span class="number">2</span>) &#123;<span class="comment">//步长变化</span></span><br><span class="line">        <span class="keyword">for</span> (i = dk + <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] &lt; A[i - dk]) &#123;</span><br><span class="line">                A[<span class="number">0</span>] = A[i];<span class="comment">//暂存在A[0]</span></span><br><span class="line">                <span class="keyword">for</span> (j = i - dk; A[j] &gt; A[<span class="number">0</span>] &amp;&amp; j &gt; <span class="number">0</span>; j = j - dk) A[j + dk] = A[j];<span class="comment">//元素后移</span></span><br><span class="line">                A[j + dk] = A[<span class="number">0</span>];<span class="comment">//元素插入</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>希尔排序是一种<font color='#BAOC2F'>不稳定</font>的排序方法</li><li>希尔排序<font color='#BAOC2F'>不适合在链式存储上</font>实现</li><li>希尔排序的时间复杂度：O(n<sup>1.25</sup> ~ O(1.6n<sup>1.25</sup>))，空间复杂度为O(1)</li><li><font color='#BAOC2F'>最后一个增量必须为1</font>，其他序列除了1之外不能有公因子（互质）</li><li>希尔排序算法效率与<font color='#BAOC2F'>增量序列取值</font>有关（希尔建议每次将增量缩小一半）</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220531182300379.png" alt="image-20220531182300379"></p><h4 id="4-表插入排序"><a href="#4-表插入排序" class="headerlink" title="4.表插入排序"></a>4.表插入排序</h4><p>折半插入排序和二路插入排序分别减少了记录<font color='#BAOC2F'>关键字的比较次数</font>和<font color='#BAOC2F'>记录的移动次数</font>，但都不能避免非重要数据的移动</p><p>&#x3D;&#x3D;算法思想&#x3D;&#x3D;：</p><ol><li>设置顺序表（数组）中下标为0的分量为表头结点，并令表头结点记录的关键字取最大整数</li><li>首先将静态链表中<font color='#BAOC2F'>数组下标为1的结点</font>和<font color='#BAOC2F'>表头结点</font>构成一个循环链表</li><li>然后依次将<font color='#BAOC2F'>下标为2至n的结点</font>按照<font color='#BAOC2F'>关键字非递减</font>有序插入到循环链表中</li></ol><p>&#x3D;&#x3D;表插入排序特点&#x3D;&#x3D;：</p><ol><li>表插入排序采用了<font color='#BAOC2F'>静态链表的存储结构</font>实现，其核心仍是将记录<font color='#BAOC2F'>插入到已排好序的有序表中</font>。</li><li>与直接插入排序相比，表插入排序不同之处仅是以<font color='#BAOC2F'>修改2n次指针值</font>来替代记录的移动</li><li>表插入排序过程中所需要进行的关键字间比较次数仍然相同，时间复杂度仍为O(n<sup>2</sup>)</li><li>表插入排序得到到的是一个有序链表，因此只能进行随机查找不能顺序查找（为了进行有序表折半查找，可能需要对记录重新排列）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tableInsertSort</span><span class="params">(Table &amp;tb, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.将静态链表中数组下标为1的结点和表头结点构成一个循环链表</span></span><br><span class="line">    tb[<span class="number">0</span>].next = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//2.依次将下标为 2~n 的结点按照 关键字非递减 有序插入到循环链表中</span></span><br><span class="line">    <span class="type">int</span> p, q;<span class="comment">//q为p的前驱</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">//调整p、q位置</span></span><br><span class="line">        q = <span class="number">0</span>;</span><br><span class="line">        p = tb[<span class="number">0</span>].next;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="number">0</span> &amp;&amp; tb[p].data &lt;= tb[i].data) &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = tb[p].next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行插入操作</span></span><br><span class="line">        tb[i].next = tb[q].next;</span><br><span class="line">        tb[q].next = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221128105612919.png" alt="image-20221128105612919"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221128112307250.png" alt="image-20221128112307250"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221128112417198.png" alt="image-20221128112417198"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221128112458893.png" alt="image-20221128112458893"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221128112506762.png" alt="image-20221128112506762"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221128113113984.png" alt="image-20221128113113984"></p><p>&#x3D;&#x3D;对表插入排序后的记录进行重排序&#x3D;&#x3D;：</p><p>顺序扫描有序链表，将链表中第i个结点移动至数组的第i个分量中（使链表中的项与地址下标项对应）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据静态链表tb中各结点的指针值调整记录位置 使得tb中记录 按关键字非递减</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Arrange</span><span class="params">(Table &amp;tb,<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p, q;</span><br><span class="line">    p = tb[<span class="number">0</span>].next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">//1.调整p、q位置</span></span><br><span class="line">        <span class="keyword">while</span> (p &lt; i) p = tb[p].next;<span class="comment">//找到第i个记录 并用p指示其在tb中当前的位置</span></span><br><span class="line">        q = tb[p].next;<span class="comment">//q指示尚未调整的表尾</span></span><br><span class="line">        <span class="comment">//2.进行调整</span></span><br><span class="line">        <span class="keyword">if</span> (p != i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(tb[p], tb[i]);<span class="comment">//交换整个记录(包括 data和 next) 使第i个记录到位</span></span><br><span class="line">            tb[i].next = p;<span class="comment">//tb[i].next指向被移动的记录 使得后续可由 while循环找回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.p指向尚未调整的表尾 为找第i + 1个记录作准备</span></span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221128141458693.png" alt="image-20221128141458693"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221128141507417.png" alt="image-20221128141507417"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221128141514807.png" alt="image-20221128141514807"></p><p>&#x3D;&#x3D;调试程序&#x3D;&#x3D;：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVALUE 9999</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typedef struct &#123;</span></span><br><span class="line"><span class="comment">//     int data;</span></span><br><span class="line"><span class="comment">//     int next;</span></span><br><span class="line"><span class="comment">// &#125; Table[MAXSIZE];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> next;</span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="keyword">typedef</span> Node Table[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initTable</span><span class="params">(Table &amp;tb, <span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化首元结点</span></span><br><span class="line">    tb[<span class="number">0</span>].data = MAXVALUE;</span><br><span class="line">    tb[<span class="number">0</span>].next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        tb[i].data = arr[i];<span class="comment">//将arr中的数据放入到Table中</span></span><br><span class="line">        tb[i].next = <span class="number">0</span>;<span class="comment">//所有结点都指向首元结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Table tb, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cout &lt;&lt; tb[i].data &lt;&lt; <span class="string">&quot;         &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cout &lt;&lt; tb[i].next &lt;&lt; <span class="string">&quot;          &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) cout &lt;&lt; i &lt;&lt; <span class="string">&quot;          &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//表插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tableInsertSort</span><span class="params">(Table &amp;tb, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.将静态链表中数组下标为1的结点和表头结点构成一个循环链表</span></span><br><span class="line">    tb[<span class="number">0</span>].next = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//2.依次将下标为 2~n 的结点按照 关键字非递减 有序插入到循环链表中</span></span><br><span class="line">    <span class="type">int</span> p, q;<span class="comment">//q为p的前驱</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">//调整p、q位置</span></span><br><span class="line">        q = <span class="number">0</span>;</span><br><span class="line">        p = tb[<span class="number">0</span>].next;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="number">0</span> &amp;&amp; tb[p].data &lt;= tb[i].data) &#123;</span><br><span class="line">            q = p;</span><br><span class="line">            p = tb[p].next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行插入操作</span></span><br><span class="line">        tb[i].next = tb[q].next;</span><br><span class="line">        tb[q].next = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据静态链表tb中各结点的指针值调整记录位置 使得tb中记录 按关键字非递减</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Arrange</span><span class="params">(Table &amp;tb,<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p, q;</span><br><span class="line">    p = tb[<span class="number">0</span>].next;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">//1.调整p、q位置</span></span><br><span class="line">        <span class="keyword">while</span> (p &lt; i) p = tb[p].next;<span class="comment">//找到第i个记录 并用p指示其在tb中当前的位置</span></span><br><span class="line">        q = tb[p].next;<span class="comment">//q指示尚未调整的表尾</span></span><br><span class="line">        <span class="comment">//2.进行调整</span></span><br><span class="line">        <span class="keyword">if</span> (p != i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(tb[p], tb[i]);<span class="comment">//交换整个记录(包括 data和 next) 使第i个记录到位</span></span><br><span class="line">            tb[i].next = p;<span class="comment">//tb[i].next指向被移动的记录 使得后续可由 while循环找回</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//print(tb, n); cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">//3.p指向尚未调整的表尾 为找第i + 1个记录作准备</span></span><br><span class="line">        p = q;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot; p = &quot; &lt;&lt; p &lt;&lt; &quot; q = &quot; &lt;&lt; q &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.准备静态链表</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> arr[MAXSIZE] = &#123;<span class="number">0</span>, <span class="number">49</span>, <span class="number">38</span>, <span class="number">65</span>, <span class="number">97</span>, <span class="number">76</span>, <span class="number">13</span>, <span class="number">27</span>, <span class="number">49</span>&#125;;</span><br><span class="line">    Table tb;</span><br><span class="line">    <span class="built_in">initTable</span>(tb, arr, n);<span class="comment">//用arr数组初始化table</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.进行表插入排序</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;tableInsertSort:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">tableInsertSort</span>(tb, n); <span class="built_in">print</span>(tb, n); cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.进行表插入排序后的重排序</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Arrange:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">Arrange</span>(tb, n); <span class="built_in">print</span>(tb, n); cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、交换排序"><a href="#二、交换排序" class="headerlink" title="二、交换排序"></a>二、交换排序</h3><h4 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h4><p>每一趟将记录进行两两比较，并按照<font color='#BAOC2F'>前小后大</font>的规则进行交换（n个记录总共需要比较n-1趟，第m趟需要比较n-m次）：</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221125105032681.png" alt="image-20221125105032681"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下标易读化写法 i范围为(0 ~ n-2) 修改j范围为(0 ~ n-i-2)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort1</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = L.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;<span class="comment">//需要n - 1趟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (L.elem[j] &gt; L.elem[j + <span class="number">1</span>]) </span><br><span class="line">                <span class="built_in">swap</span>(L.elem[j], L.elem[j + <span class="number">1</span>]);<span class="comment">//发生逆序则进行交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下标简化的等价写法 修改i范围为(1 ~ n-1) 则修改j的范围可简化写(0 ~ n-i-1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort2</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = L.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;<span class="comment">//需要n - 1趟</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (L.elem[j] &gt; L.elem[j + <span class="number">1</span>]) </span><br><span class="line">                <span class="built_in">swap</span>(L.elem[j], L.elem[j + <span class="number">1</span>]);<span class="comment">//发生逆序则进行交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改进的冒泡排序算法:若发现某次遍历后已经是有序的序列，则可直接跳出循环无需再遍历</span></span><br><span class="line"><span class="comment">//新增flag用于标记是否发生交换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort3</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n = L.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n &amp;&amp; flag; ++i) &#123;<span class="comment">//需要n - 1趟</span></span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n - i; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (L.elem[j] &gt; L.elem[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">swap</span>(L.elem[j], L.elem[j + <span class="number">1</span>]);<span class="comment">//发生逆序则进行交换</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>优点：每一趟结束时，不仅能挤出一个<font color='#BAOC2F'>最大值到最后面的位置</font>，还能同时<font color='#BAOC2F'>部分理顺其他元素</font>，稳定的排序。</li><li>最好情况：比较次数n-1（1趟）、移动次数0，时间负责度为O（n）</li><li>最差情况：时间负复杂度为O（n^2）</li><li>平均时间复杂度：O（n^2）、空间复杂度为：O（1）</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220605090017759.png" alt="image-20220605090017759"></p><h4 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h4><p>快速排序是一种改进的冒泡排序算法，</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/quickSort.gif" alt="quickSort"></p><p>&#x3D;&#x3D;基本思想&#x3D;&#x3D;：</p><ol><li><font color='#BAOC2F'>任取一个元素</font>作为中心pivot</li><li>所有比pivot小的元素都放在前面，比pivot大的元素都放在后面，形成左右两个子表</li><li>对各子表重新选择中心元素pivot，并按照规则进行调整（递归思想）</li><li>直到每个子表的元素都只剩一个，结束排序</li><li>每一趟的子表的形成是采用<font color='#BAOC2F'>从两头向中间交替</font>式的<font color='#BAOC2F'>逼近法</font>。</li></ol><p>&#x3D;&#x3D;算法改进&#x3D;&#x3D;：减小算法使用的空间（只需要1个额外位置）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220606224504165.png" alt="image-20220606224504165"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选出pivot并对SqList进行排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> key = L.elem[low];<span class="comment">//取low处元素的值作为比较参考</span></span><br><span class="line">    <span class="keyword">while</span>(low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.elem[high] &gt;= key) --high;<span class="comment">//右侧比temp元素大的元素结点不动</span></span><br><span class="line">        L.elem[low] = L.elem[high];<span class="comment">//将比key元素小的结点搬到low位置</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high &amp;&amp; L.elem[low] &lt;= key) ++low;<span class="comment">//左侧比temp元素小的元素结点不动</span></span><br><span class="line">        L.elem[high] = L.elem[low];<span class="comment">//将比key元素大的结点搬到high位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.elem[low] = key;<span class="comment">//low = high = pivot</span></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QSort</span><span class="params">(SqList &amp;L, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;<span class="comment">//快速排序调用并指明排序下标范围(low ~ high)</span></span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;<span class="comment">//排序区间长度大于1则继续递归,否则退出递归</span></span><br><span class="line">        <span class="type">int</span> pivot = <span class="built_in">partition</span>(L, low, high);<span class="comment">//选出pivot并对SqList进行排序</span></span><br><span class="line">        <span class="built_in">QSort</span>(L, low, pivot - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">QSort</span>(L, pivot + <span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><font color='#BAOC2F'>快速排序</font>是所有内部排序方法中最好的一个</li><li>快速排序是一种<font color='#BAOC2F'>不稳定</font>的排序方法</li><li>快速排序<font color='#BAOC2F'>不是原地排序</font>（程序中使用了递归需要递归调用栈的支持，而栈的长度取决于递归调用的深度）</li><li>平均时间复杂度O(nlog<sub>2</sub>n)：QSort—O(log<sub>2</sub>n)、Partition—O(n)</li><li>平均情况下需要使用O(logn)的栈空间，最坏情况下栈空间可以达到O(n)</li><li>快速排序不适用与对<font color='#BAOC2F'>原本有序或基本有序</font>的记录序列进行排序（划分元素值的<font color='#BAOC2F'>随机性越好</font>，排序速度越快，即<font color='#BAOC2F'>非自然排序</font>）</li><li>改变<font color='#BAOC2F'>划分元素的选取方法</font>，最多只能改变算法<font color='#BAOC2F'>平均时间性能</font>，无法改变最坏情况下的时间性能O(n<sup>2</sup>)</li><li>由于每次枢轴pivot记录的关键字都是大于其他所有记录的关键字，致使一次划分之后得到的子序列（1）的长度为0，这时的快速排序就已经退化成为了没有改进措施的冒泡排序了。</li></ol><h3 id="三、选择排序"><a href="#三、选择排序" class="headerlink" title="三、选择排序"></a>三、选择排序</h3><h4 id="1-选择排序"><a href="#1-选择排序" class="headerlink" title="1.选择排序"></a>1.选择排序</h4><p>&#x3D;&#x3D;基本思想&#x3D;&#x3D;：在待排序的数据中<font color='#BAOC2F'>选出最大&#x2F;小</font>的元素，放在其最终的位置（符合人类的排序思维）。</p><ol><li>首先通过n-1次关键字比较，从n个记录中找出<font color='#BAOC2F'>关键字最小的记录</font>，将其与第一个记录交换。</li><li>再通过n-2次比较，从剩余的n-1个记录中找出<font color='#BAOC2F'>关键字次小的记录</font>，将其与第二个记录交换。</li><li><font color='#BAOC2F'>重复上述操作</font>，共进行n-1趟排序之后，排序结束。</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220607154734714.png" alt="image-20220607154734714"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectSort</span><span class="params">(SqList &amp;L)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">//从待排序序列中选出最小值</span></span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; L.length; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (L.elem[j] &lt; L.elem[min]) min = j;<span class="comment">//更新最小值位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果最小值为自己则不进行元素交换</span></span><br><span class="line">        <span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">            <span class="type">int</span> temp = L.elem[i];</span><br><span class="line">            L.elem[i] = L.elem[min];</span><br><span class="line">            L.elem[min] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>选择排序记录移动次数：最好的情况为0、最坏的情况为3(n-1)</p></li><li><p>无论<font color='#BAOC2F'>待排序序列处于什么状态</font>，选择排序所需要进行<font color='#BAOC2F'>比较的次数都相同</font>：时间复杂度为O(n<sup>2</sup>)</p></li><li><p>简单选择排序是<font color='#BAOC2F'>不稳定排序</font></p></li></ol><h4 id="2-堆排序"><a href="#2-堆排序" class="headerlink" title="2.堆排序"></a>2.堆排序</h4><p>堆的实质其实是满足如下性质的<font color='#BAOC2F'>完全二叉树</font>，二叉树中<font color='#BAOC2F'>非叶子结点</font>均小于&#x2F;大于<font color='#BAOC2F'>其孩子结点</font>的树，</p><p>如果输出堆顶值最大&#x2F;最小值后，<font color='#BAOC2F'>使得剩余元素重新形成一个堆</font>，反复循环则便能够得到一个有序的序列。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220607161447078.png" alt="image-20220607161447078"></p><h5 id="（1）堆初始化："><a href="#（1）堆初始化：" class="headerlink" title="（1）堆初始化："></a>（1）堆初始化：</h5><ol><li>单结点的二叉树是堆（无需调整树中的叶子结点）</li><li>在完全二叉树中所有<font color='#BAOC2F'>以叶子结点为根的子树</font>是堆（无需调整）</li><li>堆的调整只需要从<font color='#BAOC2F'>最后一个非叶子结点</font>开始即可</li><li>需要依次将以序号为n&#x2F;2、n&#x2F;2-1、…1的结点为根的<font color='#BAOC2F'>子树</font>均调整为堆即可（筛选需<font color='#BAOC2F'>从第n&#x2F;2个元素开始</font>）</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220608082817149.png" alt="image-20220608082817149"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221125195627761.png" alt="image-20221125195627761"></p><p>将初始无序序列调整成小根堆（筛选过程），可以利用以算法实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调整R[x]的关键字，使R[x...n]成为一个大根堆</span></span><br><span class="line">    <span class="type">int</span> rc = R[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>*x; i &lt;= n; i *= <span class="number">2</span>) &#123;<span class="comment">//沿较大的孩子结点向下筛选（2*x即为较大孩子）</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; n &amp;&amp; R[i] &lt; R[i + <span class="number">1</span>]) i = i + <span class="number">1</span>;<span class="comment">//对比左右孩子的大小 取key为较大的孩子节点的下标（保证有右孩子）</span></span><br><span class="line">        <span class="keyword">if</span> (rc &gt;= R[i]) <span class="keyword">break</span>;<span class="comment">//若rc已经满足大根堆的要求 则筛选直接结束</span></span><br><span class="line">        eles &#123;</span><br><span class="line">            R[x] = R[i];<span class="comment">//将A[i]调整到双亲结点上</span></span><br><span class="line">            x = i;<span class="comment">//修改x值为i继续向下筛选（实现树的继续向下筛选）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    R[x] = rc;<span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//依次将以序号为n/2、n/2-1...1的结点为根的子树调整为堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) <span class="built_in">HeapAdjust</span>(R, i, n);</span><br></pre></td></tr></table></figure><h5 id="（2）堆去顶重构："><a href="#（2）堆去顶重构：" class="headerlink" title="（2）堆去顶重构："></a>（2）堆去顶重构：</h5><ol><li>输出堆顶元素之后，以<font color='#BAOC2F'>堆中最后一个元素</font>替代其位置</li><li>将根结点值与左、右子树的根节点值进行比较，并与其中<font color='#BAOC2F'>较小者</font>进行交换。</li><li>重复上述操作<font color='#BAOC2F'>直至叶子结点</font>，得到的新的堆（称从这个堆顶至叶子的调整过程为筛选）</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221125203254989.png" alt="image-20221125203254989"></p><blockquote><p>从上述算法可以看出，对一个<font color='#BAOC2F'>无序的序列进行反复的筛选</font>就可以得到一个堆。（建堆过程即是一个反复筛选的过程）</p></blockquote><h5 id="（3）堆排序算法："><a href="#（3）堆排序算法：" class="headerlink" title="（3）堆排序算法："></a>（3）堆排序算法：</h5><p>若对一个无序序列建堆，然后输出根（堆顶），重复过程就可以由一个无序序列输出有序序列（实现堆排序）。</p><blockquote><p>注意：堆排序实质上就是利用完全二叉树中<font color='#BAOC2F'>父节点与孩子结点之间的内在联系</font>来排序的。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将以x为根的子树调整为大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapAdjust</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> rc = R[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>*x; i &lt;= n; i *= <span class="number">2</span>) &#123;<span class="comment">//沿较大的孩子结点向下筛选（2*x即为较大孩子）</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; n &amp;&amp; R[i] &lt; R[i + <span class="number">1</span>]) i = i + <span class="number">1</span>;<span class="comment">//对比左右孩子的大小 取key为较大的孩子节点的下标（保证有右孩子）</span></span><br><span class="line">        <span class="keyword">if</span> (rc &gt;= R[i]) <span class="keyword">break</span>;<span class="comment">//若rc已经满足大根堆的要求 则筛选直接结束</span></span><br><span class="line">        eles &#123;</span><br><span class="line">            R[x] = R[i];<span class="comment">//将A[i]调整到双亲结点上</span></span><br><span class="line">            x = i;<span class="comment">//修改x值为i继续向下筛选（实现树的继续向下筛选）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    R[x] = rc;<span class="comment">//被筛选结点的值放入最终位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆排序下标范围为  0 - length-1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> n)</span> </span>&#123;<span class="comment">//对R[1]到R[n]进行堆排序</span></span><br><span class="line">    <span class="comment">//1.建立初始堆O(n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = (n<span class="number">-1</span>)/<span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) <span class="built_in">HeapAdjust</span>(R, i, n);</span><br><span class="line">    <span class="comment">//2.堆去顶后重构O(nlogn)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i) &#123;<span class="comment">//去顶重构n-1次</span></span><br><span class="line">        <span class="built_in">swap</span>(R[<span class="number">0</span>], R[i]);<span class="comment">//根与最后一个元素交换（去顶）</span></span><br><span class="line">        <span class="built_in">HeapAdjust</span>(R, <span class="number">0</span>, i - <span class="number">1</span>);<span class="comment">//重新建堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆排序下标范围为 1 - length</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> R[], <span class="type">int</span> n)</span> </span>&#123;<span class="comment">//对R[1]到R[n]进行堆排序</span></span><br><span class="line">    <span class="comment">//1.建立初始堆O(n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) <span class="built_in">HeapAdjust</span>(R, i, n);</span><br><span class="line">    <span class="comment">//2.堆去顶后重构O(nlogn)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; --i) &#123;<span class="comment">//去顶重构n-1次</span></span><br><span class="line">        <span class="built_in">swap</span>(R[<span class="number">1</span>], R[i]);<span class="comment">//根与最后一个元素交换（去顶）</span></span><br><span class="line">        <span class="built_in">HeapAdjust</span>(R, <span class="number">1</span>, i - <span class="number">1</span>);<span class="comment">//重新建堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>堆排序的时间主要消耗在<font color='#BAOC2F'>建立初始堆</font>和<font color='#BAOC2F'>调整建立新堆</font>操作的反复进行</li><li>堆排序无论是在最好&#x2F;坏的情况下<font color='#BAOC2F'>时间复杂度都为O（nlog<sub>2</sub>n）</font>，无论序列中的记录是否有序。这是堆排序最大的优点</li><li>堆排序仅需要一个记录大小的存储空间（供交换使用）</li><li>堆排序是一种<font color='#BAOC2F'>不稳定</font>的排序算法</li><li>堆排序对<font color='#BAOC2F'>数量较大</font>的的排序是比较有效，不适用于数量较少的情况</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221125213719221.png" alt="image-20221125213719221"></p><h5 id="（4）堆的插入与删除："><a href="#（4）堆的插入与删除：" class="headerlink" title="（4）堆的插入与删除："></a>（4）堆的插入与删除：</h5><ul><li>小根堆插入：新元素放到表尾与父节点进行对比，若新元素更小则将二者位置交换，新元素就这样一路上升到无法继续为止。</li><li>小根堆删除：被删除的元素用堆底的元素替代，然后让元素不断下坠直到无法下坠为止（下方有2个孩子与1个孩子对比次数）。</li></ul><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221125215158688.png" alt="image-20221125215158688"></p><h3 id="四、归并排序"><a href="#四、归并排序" class="headerlink" title="四、归并排序"></a>四、归并排序</h3><p>&#x3D;&#x3D;基本思想&#x3D;&#x3D;：将多个<font color='#BAOC2F'>有序子序列</font>归并为一个有序序列称为归并排序，算法的核心在于将数组内有序的两个序列合并为一个。</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221125223205730.png" alt="image-20221125223205730"></p><blockquote><p>注：m路归并每选出一个元素需要对比关键字m-1次</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//[low...mid]和A[mid+1...high]各自有序 将两个部分归并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> *B = (<span class="type">int</span> *)<span class="built_in">malloc</span>(n*<span class="built_in">sizeof</span>(<span class="type">int</span>));<span class="comment">//辅助数组B</span></span><br><span class="line">    <span class="keyword">for</span> (k = low; k &lt;= high; ++k) B[k] = A[k];<span class="comment">//将A中的所有元素复制到B中</span></span><br><span class="line">    <span class="keyword">for</span> (i = low, j = mid + <span class="number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= high; ++k) &#123;<span class="comment">//归并操作</span></span><br><span class="line">        <span class="keyword">if</span> (B[i] &lt;= B[j]) A[k] = B[i++];<span class="comment">//将较小值复制到A中</span></span><br><span class="line">        <span class="keyword">else</span> A[k] = B[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) A[k++] = B[i++];<span class="comment">//未归并完的部分直接复制到尾部</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= high) A[k++] = B[j++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> n, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high)/<span class="number">2</span>;<span class="comment">//从中间划分</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(A, n, low, mid);<span class="comment">//左半部分归并排序</span></span><br><span class="line">        <span class="built_in">mergeSort</span>(A, n, mid + <span class="number">1</span>, high);<span class="comment">//右半部分归并排序</span></span><br><span class="line">        <span class="built_in">merge</span>(A, n, low, mid, high);<span class="comment">//归并操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">mergeSort</span>(L.elem, L.length, <span class="number">0</span>, L.length - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ol><li>归并排序时间效率为O（nlog<sub>2</sub>n）</li><li>归并排序空间效率为O（n）</li><li>归并排序是一个稳定的排序算法</li></ol><blockquote><p>注：关于2路归并的归并树（倒立的二叉树）</p><ol><li>二叉树的第h层最多有2<sup>h-1</sup>个结点，即满足 n ≤ 2<sup>h-1</sup> 即为 h - 1 &#x3D; $\lceil log_2n \rceil$</li><li>n个元素进行2路归并，归并趟数为$\lceil log_2n \rceil$</li></ol></blockquote><h3 id="五、基数排序"><a href="#五、基数排序" class="headerlink" title="五、基数排序"></a>五、基数排序</h3><p>&#x3D;&#x3D;基本思想&#x3D;&#x3D;：分配+收集（基数排序不是一种基于比较思想的排序算法）</p><p>基数排序&#x2F;桶排序&#x2F;箱排序：设置<font color='#BAOC2F'>多个箱子</font>将<font color='#BAOC2F'>关键字为k的记录放入第k个箱子中</font>（分配），然后再<font color='#BAOC2F'>按照序号</font>将非空的连接（收集）</p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220608101753033.png" alt="image-20220608101753033"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220608101804684.png" alt="image-20220608101804684"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220608101815373.png" alt="image-20220608101815373"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220608101827376.png" alt="image-20220608101827376"></p><p>&#x3D;&#x3D;算法分析&#x3D;&#x3D;：</p><ol><li><p>基数排序时间效率：O(k*(n+m))，其中k为关键字个数、m为关键字取值范围为m个值</p></li><li><p>基数排序空间效率：O(m+n)</p></li><li><p>基数排是一种<font color='#BAOC2F'>稳定的排序算法</font></p></li><li><p>数据元素关键字可以拆分为d组且d较小、每组关键字的取值范围不大&#x2F;r较小、数据元素个数n较大（针对的问题）</p></li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221125231305217.png" alt="image-20221125231305217"></p><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20221125231713007.png" alt="image-20221125231713007"></p><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><table><thead><tr><th>时间复杂度</th><th>排序方法</th></tr></thead><tbody><tr><td>O（nlogn）</td><td>快速排序、堆排序、归并排序（其中快速排序最好）</td></tr><tr><td>O（n<sup>2</sup>）</td><td>直接插入排序、冒泡排序、简单选择排序（其中直接插入排序最好）</td></tr><tr><td>O（n）</td><td>基数排序</td></tr></tbody></table><ol><li>当待排序序列<font color='#BAOC2F'>关键字顺序有序</font>时，直接插入排序和冒泡排序能达到O（n）的时间复杂度，而对于<font color='#BAOC2F'>快速排序将退化</font>为O（n<sup>2</sup>）</li><li>简单选择排序、堆排序和归并排序的<font color='#BAOC2F'>时间性能不随</font>记录序列中的关键字的分布而变化。</li><li>所有的简单排序方法（包括直接插入、冒泡和简单选择）的堆排序的空间复杂度为O（1）</li><li>快速排序栈需要使用辅助空间，空间复杂度为O（logn）</li><li>归并排序所需要使用的辅助空间为最多O（n）</li><li>链式基数排序需要附设队列首位指针，空间复杂度为O（r*d）</li></ol><p><img src="https://raw.githubusercontent.com/Polaris-hzn8/TyporaImg/main/hexo/dataStructure/image-20220608094139356.png" alt="image-20220608094139356"></p>]]></content>
      
      
      <categories>
          
          <category> datestructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> datestructure </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
